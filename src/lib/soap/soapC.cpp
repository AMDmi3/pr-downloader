/* soapC.cpp
   Generated by gSOAP 2.7.9l from plasma.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.9l 2011-10-30 14:23:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_Plasma__ProgramType:
		return soap_in_Plasma__ProgramType(soap, NULL, NULL, "Plasma:ProgramType");
	case SOAP_TYPE_Plasma__ReturnValue:
		return soap_in_Plasma__ReturnValue(soap, NULL, NULL, "Plasma:ReturnValue");
	case SOAP_TYPE_Plasma__AutohostMode:
		return soap_in_Plasma__AutohostMode(soap, NULL, NULL, "Plasma:AutohostMode");
	case SOAP_TYPE_Plasma__ResourceType:
		return soap_in_Plasma__ResourceType(soap, NULL, NULL, "Plasma:ResourceType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_Plasma__PlayerStats:
		return soap_in_Plasma__PlayerStats(soap, NULL, NULL, "Plasma:PlayerStats");
	case SOAP_TYPE_Plasma__ArrayOfPlayerStats:
		return soap_in_Plasma__ArrayOfPlayerStats(soap, NULL, NULL, "Plasma:ArrayOfPlayerStats");
	case SOAP_TYPE_Plasma__PlayerAward:
		return soap_in_Plasma__PlayerAward(soap, NULL, NULL, "Plasma:PlayerAward");
	case SOAP_TYPE_Plasma__ArrayOfPlayerAward:
		return soap_in_Plasma__ArrayOfPlayerAward(soap, NULL, NULL, "Plasma:ArrayOfPlayerAward");
	case SOAP_TYPE_Plasma__BattlePlayerResult:
		return soap_in_Plasma__BattlePlayerResult(soap, NULL, NULL, "Plasma:BattlePlayerResult");
	case SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult:
		return soap_in_Plasma__ArrayOfBattlePlayerResult(soap, NULL, NULL, "Plasma:ArrayOfBattlePlayerResult");
	case SOAP_TYPE_Plasma__BattleResult:
		return soap_in_Plasma__BattleResult(soap, NULL, NULL, "Plasma:BattleResult");
	case SOAP_TYPE_Plasma__UserCustomParameters:
		return soap_in_Plasma__UserCustomParameters(soap, NULL, NULL, "Plasma:UserCustomParameters");
	case SOAP_TYPE_Plasma__ArrayOfUserCustomParameters:
		return soap_in_Plasma__ArrayOfUserCustomParameters(soap, NULL, NULL, "Plasma:ArrayOfUserCustomParameters");
	case SOAP_TYPE_Plasma__ScriptKeyValuePair:
		return soap_in_Plasma__ScriptKeyValuePair(soap, NULL, NULL, "Plasma:ScriptKeyValuePair");
	case SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair:
		return soap_in_Plasma__ArrayOfScriptKeyValuePair(soap, NULL, NULL, "Plasma:ArrayOfScriptKeyValuePair");
	case SOAP_TYPE_Plasma__SpringBattleStartSetup:
		return soap_in_Plasma__SpringBattleStartSetup(soap, NULL, NULL, "Plasma:SpringBattleStartSetup");
	case SOAP_TYPE_Plasma__BattleStartSetupPlayer:
		return soap_in_Plasma__BattleStartSetupPlayer(soap, NULL, NULL, "Plasma:BattleStartSetupPlayer");
	case SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer:
		return soap_in_Plasma__ArrayOfBattleStartSetupPlayer(soap, NULL, NULL, "Plasma:ArrayOfBattleStartSetupPlayer");
	case SOAP_TYPE_Plasma__ScriptMissionData:
		return soap_in_Plasma__ScriptMissionData(soap, NULL, NULL, "Plasma:ScriptMissionData");
	case SOAP_TYPE_Plasma__ArrayOfResourceData:
		return soap_in_Plasma__ArrayOfResourceData(soap, NULL, NULL, "Plasma:ArrayOfResourceData");
	case SOAP_TYPE_Plasma__SpringHashEntry:
		return soap_in_Plasma__SpringHashEntry(soap, NULL, NULL, "Plasma:SpringHashEntry");
	case SOAP_TYPE_Plasma__ArrayOfSpringHashEntry:
		return soap_in_Plasma__ArrayOfSpringHashEntry(soap, NULL, NULL, "Plasma:ArrayOfSpringHashEntry");
	case SOAP_TYPE_Plasma__ResourceData:
		return soap_in_Plasma__ResourceData(soap, NULL, NULL, "Plasma:ResourceData");
	case SOAP_TYPE_Plasma__RecommendedMapResult:
		return soap_in_Plasma__RecommendedMapResult(soap, NULL, NULL, "Plasma:RecommendedMapResult");
	case SOAP_TYPE_Plasma__EloInfo:
		return soap_in_Plasma__EloInfo(soap, NULL, NULL, "Plasma:EloInfo");
	case SOAP_TYPE_Plasma__ArrayOfString:
		return soap_in_Plasma__ArrayOfString(soap, NULL, NULL, "Plasma:ArrayOfString");
	case SOAP_TYPE_Plasma__BotTeam:
		return soap_in_Plasma__BotTeam(soap, NULL, NULL, "Plasma:BotTeam");
	case SOAP_TYPE_Plasma__ArrayOfBotTeam:
		return soap_in_Plasma__ArrayOfBotTeam(soap, NULL, NULL, "Plasma:ArrayOfBotTeam");
	case SOAP_TYPE_Plasma__BalanceTeamsResult:
		return soap_in_Plasma__BalanceTeamsResult(soap, NULL, NULL, "Plasma:BalanceTeamsResult");
	case SOAP_TYPE_Plasma__AccountTeam:
		return soap_in_Plasma__AccountTeam(soap, NULL, NULL, "Plasma:AccountTeam");
	case SOAP_TYPE_Plasma__ArrayOfAccountTeam:
		return soap_in_Plasma__ArrayOfAccountTeam(soap, NULL, NULL, "Plasma:ArrayOfAccountTeam");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountDataResponse:
		return soap_in_PointerTo_Plasma__VerifyAccountDataResponse(soap, NULL, NULL, "Plasma:VerifyAccountDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountData:
		return soap_in_PointerTo_Plasma__VerifyAccountData(soap, NULL, NULL, "Plasma:VerifyAccountData");
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTraceResponse:
		return soap_in_PointerTo_Plasma__SubmitStackTraceResponse(soap, NULL, NULL, "Plasma:SubmitStackTraceResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTrace:
		return soap_in_PointerTo_Plasma__SubmitStackTrace(soap, NULL, NULL, "Plasma:SubmitStackTrace");
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResultResponse:
		return soap_in_PointerTo_Plasma__SubmitSpringBattleResultResponse(soap, NULL, NULL, "Plasma:SubmitSpringBattleResultResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResult:
		return soap_in_PointerTo_Plasma__SubmitSpringBattleResult(soap, NULL, NULL, "Plasma:SubmitSpringBattleResult");
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScoreResponse:
		return soap_in_PointerTo_Plasma__SubmitMissionScoreResponse(soap, NULL, NULL, "Plasma:SubmitMissionScoreResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScore:
		return soap_in_PointerTo_Plasma__SubmitMissionScore(soap, NULL, NULL, "Plasma:SubmitMissionScore");
	case SOAP_TYPE_PointerTo_Plasma__RegisterResourceResponse:
		return soap_in_PointerTo_Plasma__RegisterResourceResponse(soap, NULL, NULL, "Plasma:RegisterResourceResponse");
	case SOAP_TYPE_PointerTo_Plasma__RegisterResource:
		return soap_in_PointerTo_Plasma__RegisterResource(soap, NULL, NULL, "Plasma:RegisterResource");
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRunResponse:
		return soap_in_PointerTo_Plasma__NotifyMissionRunResponse(soap, NULL, NULL, "Plasma:NotifyMissionRunResponse");
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRun:
		return soap_in_PointerTo_Plasma__NotifyMissionRun(soap, NULL, NULL, "Plasma:NotifyMissionRun");
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetupResponse:
		return soap_in_PointerTo_Plasma__GetSpringBattleStartSetupResponse(soap, NULL, NULL, "Plasma:GetSpringBattleStartSetupResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetup:
		return soap_in_PointerTo_Plasma__GetSpringBattleStartSetup(soap, NULL, NULL, "Plasma:GetSpringBattleStartSetup");
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionDataResponse:
		return soap_in_PointerTo_Plasma__GetScriptMissionDataResponse(soap, NULL, NULL, "Plasma:GetScriptMissionDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionData:
		return soap_in_PointerTo_Plasma__GetScriptMissionData(soap, NULL, NULL, "Plasma:GetScriptMissionData");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceListResponse:
		return soap_in_PointerTo_Plasma__GetResourceListResponse(soap, NULL, NULL, "Plasma:GetResourceListResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceList:
		return soap_in_PointerTo_Plasma__GetResourceList(soap, NULL, NULL, "Plasma:GetResourceList");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceDataResponse:
		return soap_in_PointerTo_Plasma__GetResourceDataResponse(soap, NULL, NULL, "Plasma:GetResourceDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceData:
		return soap_in_PointerTo_Plasma__GetResourceData(soap, NULL, NULL, "Plasma:GetResourceData");
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMapResponse:
		return soap_in_PointerTo_Plasma__GetRecommendedMapResponse(soap, NULL, NULL, "Plasma:GetRecommendedMapResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMap:
		return soap_in_PointerTo_Plasma__GetRecommendedMap(soap, NULL, NULL, "Plasma:GetRecommendedMap");
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10Response:
		return soap_in_PointerTo_Plasma__GetEloTop10Response(soap, NULL, NULL, "Plasma:GetEloTop10Response");
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10:
		return soap_in_PointerTo_Plasma__GetEloTop10(soap, NULL, NULL, "Plasma:GetEloTop10");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByNameResponse:
		return soap_in_PointerTo_Plasma__GetEloByNameResponse(soap, NULL, NULL, "Plasma:GetEloByNameResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByName:
		return soap_in_PointerTo_Plasma__GetEloByName(soap, NULL, NULL, "Plasma:GetEloByName");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountIDResponse:
		return soap_in_PointerTo_Plasma__GetEloByAccountIDResponse(soap, NULL, NULL, "Plasma:GetEloByAccountIDResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountID:
		return soap_in_PointerTo_Plasma__GetEloByAccountID(soap, NULL, NULL, "Plasma:GetEloByAccountID");
	case SOAP_TYPE_PointerTo_Plasma__DownloadFileResponse:
		return soap_in_PointerTo_Plasma__DownloadFileResponse(soap, NULL, NULL, "Plasma:DownloadFileResponse");
	case SOAP_TYPE_PointerTo_Plasma__DownloadFile:
		return soap_in_PointerTo_Plasma__DownloadFile(soap, NULL, NULL, "Plasma:DownloadFile");
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeamsResponse:
		return soap_in_PointerTo_Plasma__BalanceTeamsResponse(soap, NULL, NULL, "Plasma:BalanceTeamsResponse");
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeams:
		return soap_in_PointerTo_Plasma__BalanceTeams(soap, NULL, NULL, "Plasma:BalanceTeams");
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoinedResponse:
		return soap_in_PointerTo_Plasma__AutohostPlayerJoinedResponse(soap, NULL, NULL, "Plasma:AutohostPlayerJoinedResponse");
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoined:
		return soap_in_PointerTo_Plasma__AutohostPlayerJoined(soap, NULL, NULL, "Plasma:AutohostPlayerJoined");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattlePlayerResult:
		return soap_in_PointerToPlasma__ArrayOfBattlePlayerResult(soap, NULL, NULL, "Plasma:ArrayOfBattlePlayerResult");
	case SOAP_TYPE_PointerToPlasma__BattleResult:
		return soap_in_PointerToPlasma__BattleResult(soap, NULL, NULL, "Plasma:BattleResult");
	case SOAP_TYPE_PointerToPlasma__SpringBattleStartSetup:
		return soap_in_PointerToPlasma__SpringBattleStartSetup(soap, NULL, NULL, "Plasma:SpringBattleStartSetup");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattleStartSetupPlayer:
		return soap_in_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, NULL, NULL, "Plasma:ArrayOfBattleStartSetupPlayer");
	case SOAP_TYPE_PointerToPlasma__ScriptMissionData:
		return soap_in_PointerToPlasma__ScriptMissionData(soap, NULL, NULL, "Plasma:ScriptMissionData");
	case SOAP_TYPE_PointerToPlasma__ArrayOfResourceData:
		return soap_in_PointerToPlasma__ArrayOfResourceData(soap, NULL, NULL, "Plasma:ArrayOfResourceData");
	case SOAP_TYPE_PointerToPlasma__RecommendedMapResult:
		return soap_in_PointerToPlasma__RecommendedMapResult(soap, NULL, NULL, "Plasma:RecommendedMapResult");
	case SOAP_TYPE_PointerToPlasma__EloInfo:
		return soap_in_PointerToPlasma__EloInfo(soap, NULL, NULL, "Plasma:EloInfo");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToPlasma__BalanceTeamsResult:
		return soap_in_PointerToPlasma__BalanceTeamsResult(soap, NULL, NULL, "Plasma:BalanceTeamsResult");
	case SOAP_TYPE_PointerToPlasma__PlayerStats:
		return soap_in_PointerToPlasma__PlayerStats(soap, NULL, NULL, "Plasma:PlayerStats");
	case SOAP_TYPE_PointerToPlasma__PlayerAward:
		return soap_in_PointerToPlasma__PlayerAward(soap, NULL, NULL, "Plasma:PlayerAward");
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerStats:
		return soap_in_PointerToPlasma__ArrayOfPlayerStats(soap, NULL, NULL, "Plasma:ArrayOfPlayerStats");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerAward:
		return soap_in_PointerToPlasma__ArrayOfPlayerAward(soap, NULL, NULL, "Plasma:ArrayOfPlayerAward");
	case SOAP_TYPE_PointerToPlasma__BattlePlayerResult:
		return soap_in_PointerToPlasma__BattlePlayerResult(soap, NULL, NULL, "Plasma:BattlePlayerResult");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPlasma__UserCustomParameters:
		return soap_in_PointerToPlasma__UserCustomParameters(soap, NULL, NULL, "Plasma:UserCustomParameters");
	case SOAP_TYPE_PointerToPlasma__ScriptKeyValuePair:
		return soap_in_PointerToPlasma__ScriptKeyValuePair(soap, NULL, NULL, "Plasma:ScriptKeyValuePair");
	case SOAP_TYPE_PointerToPlasma__ArrayOfUserCustomParameters:
		return soap_in_PointerToPlasma__ArrayOfUserCustomParameters(soap, NULL, NULL, "Plasma:ArrayOfUserCustomParameters");
	case SOAP_TYPE_PointerToPlasma__ArrayOfScriptKeyValuePair:
		return soap_in_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, NULL, NULL, "Plasma:ArrayOfScriptKeyValuePair");
	case SOAP_TYPE_PointerToPlasma__BattleStartSetupPlayer:
		return soap_in_PointerToPlasma__BattleStartSetupPlayer(soap, NULL, NULL, "Plasma:BattleStartSetupPlayer");
	case SOAP_TYPE_PointerToPlasma__ResourceData:
		return soap_in_PointerToPlasma__ResourceData(soap, NULL, NULL, "Plasma:ResourceData");
	case SOAP_TYPE_PointerToPlasma__SpringHashEntry:
		return soap_in_PointerToPlasma__SpringHashEntry(soap, NULL, NULL, "Plasma:SpringHashEntry");
	case SOAP_TYPE_PointerToPlasma__ArrayOfSpringHashEntry:
		return soap_in_PointerToPlasma__ArrayOfSpringHashEntry(soap, NULL, NULL, "Plasma:ArrayOfSpringHashEntry");
	case SOAP_TYPE_PointerToPlasma__ArrayOfString:
		return soap_in_PointerToPlasma__ArrayOfString(soap, NULL, NULL, "Plasma:ArrayOfString");
	case SOAP_TYPE_PointerToPlasma__BotTeam:
		return soap_in_PointerToPlasma__BotTeam(soap, NULL, NULL, "Plasma:BotTeam");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBotTeam:
		return soap_in_PointerToPlasma__ArrayOfBotTeam(soap, NULL, NULL, "Plasma:ArrayOfBotTeam");
	case SOAP_TYPE_PointerToPlasma__ArrayOfAccountTeam:
		return soap_in_PointerToPlasma__ArrayOfAccountTeam(soap, NULL, NULL, "Plasma:ArrayOfAccountTeam");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPlasma__AccountTeam:
		return soap_in_PointerToPlasma__AccountTeam(soap, NULL, NULL, "Plasma:AccountTeam");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:PlayerStats"))
		{	*type = SOAP_TYPE_Plasma__PlayerStats;
			return soap_in_Plasma__PlayerStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfPlayerStats"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfPlayerStats;
			return soap_in_Plasma__ArrayOfPlayerStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:PlayerAward"))
		{	*type = SOAP_TYPE_Plasma__PlayerAward;
			return soap_in_Plasma__PlayerAward(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfPlayerAward"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfPlayerAward;
			return soap_in_Plasma__ArrayOfPlayerAward(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BattlePlayerResult"))
		{	*type = SOAP_TYPE_Plasma__BattlePlayerResult;
			return soap_in_Plasma__BattlePlayerResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfBattlePlayerResult"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult;
			return soap_in_Plasma__ArrayOfBattlePlayerResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BattleResult"))
		{	*type = SOAP_TYPE_Plasma__BattleResult;
			return soap_in_Plasma__BattleResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:UserCustomParameters"))
		{	*type = SOAP_TYPE_Plasma__UserCustomParameters;
			return soap_in_Plasma__UserCustomParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfUserCustomParameters"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfUserCustomParameters;
			return soap_in_Plasma__ArrayOfUserCustomParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ScriptKeyValuePair"))
		{	*type = SOAP_TYPE_Plasma__ScriptKeyValuePair;
			return soap_in_Plasma__ScriptKeyValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfScriptKeyValuePair"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair;
			return soap_in_Plasma__ArrayOfScriptKeyValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SpringBattleStartSetup"))
		{	*type = SOAP_TYPE_Plasma__SpringBattleStartSetup;
			return soap_in_Plasma__SpringBattleStartSetup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BattleStartSetupPlayer"))
		{	*type = SOAP_TYPE_Plasma__BattleStartSetupPlayer;
			return soap_in_Plasma__BattleStartSetupPlayer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfBattleStartSetupPlayer"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer;
			return soap_in_Plasma__ArrayOfBattleStartSetupPlayer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ScriptMissionData"))
		{	*type = SOAP_TYPE_Plasma__ScriptMissionData;
			return soap_in_Plasma__ScriptMissionData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfResourceData"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfResourceData;
			return soap_in_Plasma__ArrayOfResourceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SpringHashEntry"))
		{	*type = SOAP_TYPE_Plasma__SpringHashEntry;
			return soap_in_Plasma__SpringHashEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfSpringHashEntry"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfSpringHashEntry;
			return soap_in_Plasma__ArrayOfSpringHashEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ResourceData"))
		{	*type = SOAP_TYPE_Plasma__ResourceData;
			return soap_in_Plasma__ResourceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:RecommendedMapResult"))
		{	*type = SOAP_TYPE_Plasma__RecommendedMapResult;
			return soap_in_Plasma__RecommendedMapResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:EloInfo"))
		{	*type = SOAP_TYPE_Plasma__EloInfo;
			return soap_in_Plasma__EloInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfString"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfString;
			return soap_in_Plasma__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BotTeam"))
		{	*type = SOAP_TYPE_Plasma__BotTeam;
			return soap_in_Plasma__BotTeam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfBotTeam"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfBotTeam;
			return soap_in_Plasma__ArrayOfBotTeam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BalanceTeamsResult"))
		{	*type = SOAP_TYPE_Plasma__BalanceTeamsResult;
			return soap_in_Plasma__BalanceTeamsResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:AccountTeam"))
		{	*type = SOAP_TYPE_Plasma__AccountTeam;
			return soap_in_Plasma__AccountTeam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ArrayOfAccountTeam"))
		{	*type = SOAP_TYPE_Plasma__ArrayOfAccountTeam;
			return soap_in_Plasma__ArrayOfAccountTeam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ProgramType"))
		{	*type = SOAP_TYPE_Plasma__ProgramType;
			return soap_in_Plasma__ProgramType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ReturnValue"))
		{	*type = SOAP_TYPE_Plasma__ReturnValue;
			return soap_in_Plasma__ReturnValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:AutohostMode"))
		{	*type = SOAP_TYPE_Plasma__AutohostMode;
			return soap_in_Plasma__AutohostMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:ResourceType"))
		{	*type = SOAP_TYPE_Plasma__ResourceType;
			return soap_in_Plasma__ResourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "Plasma:VerifyAccountDataResponse"))
		{	*type = SOAP_TYPE__Plasma__VerifyAccountDataResponse;
			return soap_in__Plasma__VerifyAccountDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:VerifyAccountData"))
		{	*type = SOAP_TYPE__Plasma__VerifyAccountData;
			return soap_in__Plasma__VerifyAccountData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitStackTraceResponse"))
		{	*type = SOAP_TYPE__Plasma__SubmitStackTraceResponse;
			return soap_in__Plasma__SubmitStackTraceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitStackTrace"))
		{	*type = SOAP_TYPE__Plasma__SubmitStackTrace;
			return soap_in__Plasma__SubmitStackTrace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitSpringBattleResultResponse"))
		{	*type = SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse;
			return soap_in__Plasma__SubmitSpringBattleResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitSpringBattleResult"))
		{	*type = SOAP_TYPE__Plasma__SubmitSpringBattleResult;
			return soap_in__Plasma__SubmitSpringBattleResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitMissionScoreResponse"))
		{	*type = SOAP_TYPE__Plasma__SubmitMissionScoreResponse;
			return soap_in__Plasma__SubmitMissionScoreResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:SubmitMissionScore"))
		{	*type = SOAP_TYPE__Plasma__SubmitMissionScore;
			return soap_in__Plasma__SubmitMissionScore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:RegisterResourceResponse"))
		{	*type = SOAP_TYPE__Plasma__RegisterResourceResponse;
			return soap_in__Plasma__RegisterResourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:RegisterResource"))
		{	*type = SOAP_TYPE__Plasma__RegisterResource;
			return soap_in__Plasma__RegisterResource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:NotifyMissionRunResponse"))
		{	*type = SOAP_TYPE__Plasma__NotifyMissionRunResponse;
			return soap_in__Plasma__NotifyMissionRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:NotifyMissionRun"))
		{	*type = SOAP_TYPE__Plasma__NotifyMissionRun;
			return soap_in__Plasma__NotifyMissionRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetSpringBattleStartSetupResponse"))
		{	*type = SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse;
			return soap_in__Plasma__GetSpringBattleStartSetupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetSpringBattleStartSetup"))
		{	*type = SOAP_TYPE__Plasma__GetSpringBattleStartSetup;
			return soap_in__Plasma__GetSpringBattleStartSetup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetScriptMissionDataResponse"))
		{	*type = SOAP_TYPE__Plasma__GetScriptMissionDataResponse;
			return soap_in__Plasma__GetScriptMissionDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetScriptMissionData"))
		{	*type = SOAP_TYPE__Plasma__GetScriptMissionData;
			return soap_in__Plasma__GetScriptMissionData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetResourceListResponse"))
		{	*type = SOAP_TYPE__Plasma__GetResourceListResponse;
			return soap_in__Plasma__GetResourceListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetResourceList"))
		{	*type = SOAP_TYPE__Plasma__GetResourceList;
			return soap_in__Plasma__GetResourceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetResourceDataResponse"))
		{	*type = SOAP_TYPE__Plasma__GetResourceDataResponse;
			return soap_in__Plasma__GetResourceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetResourceData"))
		{	*type = SOAP_TYPE__Plasma__GetResourceData;
			return soap_in__Plasma__GetResourceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetRecommendedMapResponse"))
		{	*type = SOAP_TYPE__Plasma__GetRecommendedMapResponse;
			return soap_in__Plasma__GetRecommendedMapResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetRecommendedMap"))
		{	*type = SOAP_TYPE__Plasma__GetRecommendedMap;
			return soap_in__Plasma__GetRecommendedMap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloTop10Response"))
		{	*type = SOAP_TYPE__Plasma__GetEloTop10Response;
			return soap_in__Plasma__GetEloTop10Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloTop10"))
		{	*type = SOAP_TYPE__Plasma__GetEloTop10;
			return soap_in__Plasma__GetEloTop10(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloByNameResponse"))
		{	*type = SOAP_TYPE__Plasma__GetEloByNameResponse;
			return soap_in__Plasma__GetEloByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloByName"))
		{	*type = SOAP_TYPE__Plasma__GetEloByName;
			return soap_in__Plasma__GetEloByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloByAccountIDResponse"))
		{	*type = SOAP_TYPE__Plasma__GetEloByAccountIDResponse;
			return soap_in__Plasma__GetEloByAccountIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:GetEloByAccountID"))
		{	*type = SOAP_TYPE__Plasma__GetEloByAccountID;
			return soap_in__Plasma__GetEloByAccountID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:DownloadFileResponse"))
		{	*type = SOAP_TYPE__Plasma__DownloadFileResponse;
			return soap_in__Plasma__DownloadFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:DownloadFile"))
		{	*type = SOAP_TYPE__Plasma__DownloadFile;
			return soap_in__Plasma__DownloadFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BalanceTeamsResponse"))
		{	*type = SOAP_TYPE__Plasma__BalanceTeamsResponse;
			return soap_in__Plasma__BalanceTeamsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:BalanceTeams"))
		{	*type = SOAP_TYPE__Plasma__BalanceTeams;
			return soap_in__Plasma__BalanceTeams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:AutohostPlayerJoinedResponse"))
		{	*type = SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse;
			return soap_in__Plasma__AutohostPlayerJoinedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Plasma:AutohostPlayerJoined"))
		{	*type = SOAP_TYPE__Plasma__AutohostPlayerJoined;
			return soap_in__Plasma__AutohostPlayerJoined(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_Plasma__ProgramType:
		return soap_out_Plasma__ProgramType(soap, tag, id, (const enum Plasma__ProgramType *)ptr, "Plasma:ProgramType");
	case SOAP_TYPE_Plasma__ReturnValue:
		return soap_out_Plasma__ReturnValue(soap, tag, id, (const enum Plasma__ReturnValue *)ptr, "Plasma:ReturnValue");
	case SOAP_TYPE_Plasma__AutohostMode:
		return soap_out_Plasma__AutohostMode(soap, tag, id, (const enum Plasma__AutohostMode *)ptr, "Plasma:AutohostMode");
	case SOAP_TYPE_Plasma__ResourceType:
		return soap_out_Plasma__ResourceType(soap, tag, id, (const enum Plasma__ResourceType *)ptr, "Plasma:ResourceType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__Plasma__VerifyAccountDataResponse:
		return ((_Plasma__VerifyAccountDataResponse *)ptr)->soap_out(soap, "Plasma:VerifyAccountDataResponse", id, NULL);
	case SOAP_TYPE__Plasma__VerifyAccountData:
		return ((_Plasma__VerifyAccountData *)ptr)->soap_out(soap, "Plasma:VerifyAccountData", id, NULL);
	case SOAP_TYPE__Plasma__SubmitStackTraceResponse:
		return ((_Plasma__SubmitStackTraceResponse *)ptr)->soap_out(soap, "Plasma:SubmitStackTraceResponse", id, NULL);
	case SOAP_TYPE__Plasma__SubmitStackTrace:
		return ((_Plasma__SubmitStackTrace *)ptr)->soap_out(soap, "Plasma:SubmitStackTrace", id, NULL);
	case SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse:
		return ((_Plasma__SubmitSpringBattleResultResponse *)ptr)->soap_out(soap, "Plasma:SubmitSpringBattleResultResponse", id, NULL);
	case SOAP_TYPE__Plasma__SubmitSpringBattleResult:
		return ((_Plasma__SubmitSpringBattleResult *)ptr)->soap_out(soap, "Plasma:SubmitSpringBattleResult", id, NULL);
	case SOAP_TYPE__Plasma__SubmitMissionScoreResponse:
		return ((_Plasma__SubmitMissionScoreResponse *)ptr)->soap_out(soap, "Plasma:SubmitMissionScoreResponse", id, NULL);
	case SOAP_TYPE__Plasma__SubmitMissionScore:
		return ((_Plasma__SubmitMissionScore *)ptr)->soap_out(soap, "Plasma:SubmitMissionScore", id, NULL);
	case SOAP_TYPE__Plasma__RegisterResourceResponse:
		return ((_Plasma__RegisterResourceResponse *)ptr)->soap_out(soap, "Plasma:RegisterResourceResponse", id, NULL);
	case SOAP_TYPE__Plasma__RegisterResource:
		return ((_Plasma__RegisterResource *)ptr)->soap_out(soap, "Plasma:RegisterResource", id, NULL);
	case SOAP_TYPE__Plasma__NotifyMissionRunResponse:
		return ((_Plasma__NotifyMissionRunResponse *)ptr)->soap_out(soap, "Plasma:NotifyMissionRunResponse", id, NULL);
	case SOAP_TYPE__Plasma__NotifyMissionRun:
		return ((_Plasma__NotifyMissionRun *)ptr)->soap_out(soap, "Plasma:NotifyMissionRun", id, NULL);
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse:
		return ((_Plasma__GetSpringBattleStartSetupResponse *)ptr)->soap_out(soap, "Plasma:GetSpringBattleStartSetupResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetup:
		return ((_Plasma__GetSpringBattleStartSetup *)ptr)->soap_out(soap, "Plasma:GetSpringBattleStartSetup", id, NULL);
	case SOAP_TYPE__Plasma__GetScriptMissionDataResponse:
		return ((_Plasma__GetScriptMissionDataResponse *)ptr)->soap_out(soap, "Plasma:GetScriptMissionDataResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetScriptMissionData:
		return ((_Plasma__GetScriptMissionData *)ptr)->soap_out(soap, "Plasma:GetScriptMissionData", id, NULL);
	case SOAP_TYPE__Plasma__GetResourceListResponse:
		return ((_Plasma__GetResourceListResponse *)ptr)->soap_out(soap, "Plasma:GetResourceListResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetResourceList:
		return ((_Plasma__GetResourceList *)ptr)->soap_out(soap, "Plasma:GetResourceList", id, NULL);
	case SOAP_TYPE__Plasma__GetResourceDataResponse:
		return ((_Plasma__GetResourceDataResponse *)ptr)->soap_out(soap, "Plasma:GetResourceDataResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetResourceData:
		return ((_Plasma__GetResourceData *)ptr)->soap_out(soap, "Plasma:GetResourceData", id, NULL);
	case SOAP_TYPE__Plasma__GetRecommendedMapResponse:
		return ((_Plasma__GetRecommendedMapResponse *)ptr)->soap_out(soap, "Plasma:GetRecommendedMapResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetRecommendedMap:
		return ((_Plasma__GetRecommendedMap *)ptr)->soap_out(soap, "Plasma:GetRecommendedMap", id, NULL);
	case SOAP_TYPE__Plasma__GetEloTop10Response:
		return ((_Plasma__GetEloTop10Response *)ptr)->soap_out(soap, "Plasma:GetEloTop10Response", id, NULL);
	case SOAP_TYPE__Plasma__GetEloTop10:
		return ((_Plasma__GetEloTop10 *)ptr)->soap_out(soap, "Plasma:GetEloTop10", id, NULL);
	case SOAP_TYPE__Plasma__GetEloByNameResponse:
		return ((_Plasma__GetEloByNameResponse *)ptr)->soap_out(soap, "Plasma:GetEloByNameResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetEloByName:
		return ((_Plasma__GetEloByName *)ptr)->soap_out(soap, "Plasma:GetEloByName", id, NULL);
	case SOAP_TYPE__Plasma__GetEloByAccountIDResponse:
		return ((_Plasma__GetEloByAccountIDResponse *)ptr)->soap_out(soap, "Plasma:GetEloByAccountIDResponse", id, NULL);
	case SOAP_TYPE__Plasma__GetEloByAccountID:
		return ((_Plasma__GetEloByAccountID *)ptr)->soap_out(soap, "Plasma:GetEloByAccountID", id, NULL);
	case SOAP_TYPE__Plasma__DownloadFileResponse:
		return ((_Plasma__DownloadFileResponse *)ptr)->soap_out(soap, "Plasma:DownloadFileResponse", id, NULL);
	case SOAP_TYPE__Plasma__DownloadFile:
		return ((_Plasma__DownloadFile *)ptr)->soap_out(soap, "Plasma:DownloadFile", id, NULL);
	case SOAP_TYPE__Plasma__BalanceTeamsResponse:
		return ((_Plasma__BalanceTeamsResponse *)ptr)->soap_out(soap, "Plasma:BalanceTeamsResponse", id, NULL);
	case SOAP_TYPE__Plasma__BalanceTeams:
		return ((_Plasma__BalanceTeams *)ptr)->soap_out(soap, "Plasma:BalanceTeams", id, NULL);
	case SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse:
		return ((_Plasma__AutohostPlayerJoinedResponse *)ptr)->soap_out(soap, "Plasma:AutohostPlayerJoinedResponse", id, NULL);
	case SOAP_TYPE__Plasma__AutohostPlayerJoined:
		return ((_Plasma__AutohostPlayerJoined *)ptr)->soap_out(soap, "Plasma:AutohostPlayerJoined", id, NULL);
	case SOAP_TYPE_Plasma__PlayerStats:
		return ((Plasma__PlayerStats *)ptr)->soap_out(soap, tag, id, "Plasma:PlayerStats");
	case SOAP_TYPE_Plasma__ArrayOfPlayerStats:
		return ((Plasma__ArrayOfPlayerStats *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfPlayerStats");
	case SOAP_TYPE_Plasma__PlayerAward:
		return ((Plasma__PlayerAward *)ptr)->soap_out(soap, tag, id, "Plasma:PlayerAward");
	case SOAP_TYPE_Plasma__ArrayOfPlayerAward:
		return ((Plasma__ArrayOfPlayerAward *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfPlayerAward");
	case SOAP_TYPE_Plasma__BattlePlayerResult:
		return ((Plasma__BattlePlayerResult *)ptr)->soap_out(soap, tag, id, "Plasma:BattlePlayerResult");
	case SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult:
		return ((Plasma__ArrayOfBattlePlayerResult *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfBattlePlayerResult");
	case SOAP_TYPE_Plasma__BattleResult:
		return ((Plasma__BattleResult *)ptr)->soap_out(soap, tag, id, "Plasma:BattleResult");
	case SOAP_TYPE_Plasma__UserCustomParameters:
		return ((Plasma__UserCustomParameters *)ptr)->soap_out(soap, tag, id, "Plasma:UserCustomParameters");
	case SOAP_TYPE_Plasma__ArrayOfUserCustomParameters:
		return ((Plasma__ArrayOfUserCustomParameters *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfUserCustomParameters");
	case SOAP_TYPE_Plasma__ScriptKeyValuePair:
		return ((Plasma__ScriptKeyValuePair *)ptr)->soap_out(soap, tag, id, "Plasma:ScriptKeyValuePair");
	case SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair:
		return ((Plasma__ArrayOfScriptKeyValuePair *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfScriptKeyValuePair");
	case SOAP_TYPE_Plasma__SpringBattleStartSetup:
		return ((Plasma__SpringBattleStartSetup *)ptr)->soap_out(soap, tag, id, "Plasma:SpringBattleStartSetup");
	case SOAP_TYPE_Plasma__BattleStartSetupPlayer:
		return ((Plasma__BattleStartSetupPlayer *)ptr)->soap_out(soap, tag, id, "Plasma:BattleStartSetupPlayer");
	case SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer:
		return ((Plasma__ArrayOfBattleStartSetupPlayer *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfBattleStartSetupPlayer");
	case SOAP_TYPE_Plasma__ScriptMissionData:
		return ((Plasma__ScriptMissionData *)ptr)->soap_out(soap, tag, id, "Plasma:ScriptMissionData");
	case SOAP_TYPE_Plasma__ArrayOfResourceData:
		return ((Plasma__ArrayOfResourceData *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfResourceData");
	case SOAP_TYPE_Plasma__SpringHashEntry:
		return ((Plasma__SpringHashEntry *)ptr)->soap_out(soap, tag, id, "Plasma:SpringHashEntry");
	case SOAP_TYPE_Plasma__ArrayOfSpringHashEntry:
		return ((Plasma__ArrayOfSpringHashEntry *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfSpringHashEntry");
	case SOAP_TYPE_Plasma__ResourceData:
		return ((Plasma__ResourceData *)ptr)->soap_out(soap, tag, id, "Plasma:ResourceData");
	case SOAP_TYPE_Plasma__RecommendedMapResult:
		return ((Plasma__RecommendedMapResult *)ptr)->soap_out(soap, tag, id, "Plasma:RecommendedMapResult");
	case SOAP_TYPE_Plasma__EloInfo:
		return ((Plasma__EloInfo *)ptr)->soap_out(soap, tag, id, "Plasma:EloInfo");
	case SOAP_TYPE_Plasma__ArrayOfString:
		return ((Plasma__ArrayOfString *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfString");
	case SOAP_TYPE_Plasma__BotTeam:
		return ((Plasma__BotTeam *)ptr)->soap_out(soap, tag, id, "Plasma:BotTeam");
	case SOAP_TYPE_Plasma__ArrayOfBotTeam:
		return ((Plasma__ArrayOfBotTeam *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfBotTeam");
	case SOAP_TYPE_Plasma__BalanceTeamsResult:
		return ((Plasma__BalanceTeamsResult *)ptr)->soap_out(soap, tag, id, "Plasma:BalanceTeamsResult");
	case SOAP_TYPE_Plasma__AccountTeam:
		return ((Plasma__AccountTeam *)ptr)->soap_out(soap, tag, id, "Plasma:AccountTeam");
	case SOAP_TYPE_Plasma__ArrayOfAccountTeam:
		return ((Plasma__ArrayOfAccountTeam *)ptr)->soap_out(soap, tag, id, "Plasma:ArrayOfAccountTeam");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountDataResponse:
		return soap_out_PointerTo_Plasma__VerifyAccountDataResponse(soap, tag, id, (_Plasma__VerifyAccountDataResponse *const*)ptr, "Plasma:VerifyAccountDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountData:
		return soap_out_PointerTo_Plasma__VerifyAccountData(soap, tag, id, (_Plasma__VerifyAccountData *const*)ptr, "Plasma:VerifyAccountData");
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTraceResponse:
		return soap_out_PointerTo_Plasma__SubmitStackTraceResponse(soap, tag, id, (_Plasma__SubmitStackTraceResponse *const*)ptr, "Plasma:SubmitStackTraceResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTrace:
		return soap_out_PointerTo_Plasma__SubmitStackTrace(soap, tag, id, (_Plasma__SubmitStackTrace *const*)ptr, "Plasma:SubmitStackTrace");
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResultResponse:
		return soap_out_PointerTo_Plasma__SubmitSpringBattleResultResponse(soap, tag, id, (_Plasma__SubmitSpringBattleResultResponse *const*)ptr, "Plasma:SubmitSpringBattleResultResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResult:
		return soap_out_PointerTo_Plasma__SubmitSpringBattleResult(soap, tag, id, (_Plasma__SubmitSpringBattleResult *const*)ptr, "Plasma:SubmitSpringBattleResult");
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScoreResponse:
		return soap_out_PointerTo_Plasma__SubmitMissionScoreResponse(soap, tag, id, (_Plasma__SubmitMissionScoreResponse *const*)ptr, "Plasma:SubmitMissionScoreResponse");
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScore:
		return soap_out_PointerTo_Plasma__SubmitMissionScore(soap, tag, id, (_Plasma__SubmitMissionScore *const*)ptr, "Plasma:SubmitMissionScore");
	case SOAP_TYPE_PointerTo_Plasma__RegisterResourceResponse:
		return soap_out_PointerTo_Plasma__RegisterResourceResponse(soap, tag, id, (_Plasma__RegisterResourceResponse *const*)ptr, "Plasma:RegisterResourceResponse");
	case SOAP_TYPE_PointerTo_Plasma__RegisterResource:
		return soap_out_PointerTo_Plasma__RegisterResource(soap, tag, id, (_Plasma__RegisterResource *const*)ptr, "Plasma:RegisterResource");
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRunResponse:
		return soap_out_PointerTo_Plasma__NotifyMissionRunResponse(soap, tag, id, (_Plasma__NotifyMissionRunResponse *const*)ptr, "Plasma:NotifyMissionRunResponse");
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRun:
		return soap_out_PointerTo_Plasma__NotifyMissionRun(soap, tag, id, (_Plasma__NotifyMissionRun *const*)ptr, "Plasma:NotifyMissionRun");
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetupResponse:
		return soap_out_PointerTo_Plasma__GetSpringBattleStartSetupResponse(soap, tag, id, (_Plasma__GetSpringBattleStartSetupResponse *const*)ptr, "Plasma:GetSpringBattleStartSetupResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetup:
		return soap_out_PointerTo_Plasma__GetSpringBattleStartSetup(soap, tag, id, (_Plasma__GetSpringBattleStartSetup *const*)ptr, "Plasma:GetSpringBattleStartSetup");
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionDataResponse:
		return soap_out_PointerTo_Plasma__GetScriptMissionDataResponse(soap, tag, id, (_Plasma__GetScriptMissionDataResponse *const*)ptr, "Plasma:GetScriptMissionDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionData:
		return soap_out_PointerTo_Plasma__GetScriptMissionData(soap, tag, id, (_Plasma__GetScriptMissionData *const*)ptr, "Plasma:GetScriptMissionData");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceListResponse:
		return soap_out_PointerTo_Plasma__GetResourceListResponse(soap, tag, id, (_Plasma__GetResourceListResponse *const*)ptr, "Plasma:GetResourceListResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceList:
		return soap_out_PointerTo_Plasma__GetResourceList(soap, tag, id, (_Plasma__GetResourceList *const*)ptr, "Plasma:GetResourceList");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceDataResponse:
		return soap_out_PointerTo_Plasma__GetResourceDataResponse(soap, tag, id, (_Plasma__GetResourceDataResponse *const*)ptr, "Plasma:GetResourceDataResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetResourceData:
		return soap_out_PointerTo_Plasma__GetResourceData(soap, tag, id, (_Plasma__GetResourceData *const*)ptr, "Plasma:GetResourceData");
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMapResponse:
		return soap_out_PointerTo_Plasma__GetRecommendedMapResponse(soap, tag, id, (_Plasma__GetRecommendedMapResponse *const*)ptr, "Plasma:GetRecommendedMapResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMap:
		return soap_out_PointerTo_Plasma__GetRecommendedMap(soap, tag, id, (_Plasma__GetRecommendedMap *const*)ptr, "Plasma:GetRecommendedMap");
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10Response:
		return soap_out_PointerTo_Plasma__GetEloTop10Response(soap, tag, id, (_Plasma__GetEloTop10Response *const*)ptr, "Plasma:GetEloTop10Response");
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10:
		return soap_out_PointerTo_Plasma__GetEloTop10(soap, tag, id, (_Plasma__GetEloTop10 *const*)ptr, "Plasma:GetEloTop10");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByNameResponse:
		return soap_out_PointerTo_Plasma__GetEloByNameResponse(soap, tag, id, (_Plasma__GetEloByNameResponse *const*)ptr, "Plasma:GetEloByNameResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByName:
		return soap_out_PointerTo_Plasma__GetEloByName(soap, tag, id, (_Plasma__GetEloByName *const*)ptr, "Plasma:GetEloByName");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountIDResponse:
		return soap_out_PointerTo_Plasma__GetEloByAccountIDResponse(soap, tag, id, (_Plasma__GetEloByAccountIDResponse *const*)ptr, "Plasma:GetEloByAccountIDResponse");
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountID:
		return soap_out_PointerTo_Plasma__GetEloByAccountID(soap, tag, id, (_Plasma__GetEloByAccountID *const*)ptr, "Plasma:GetEloByAccountID");
	case SOAP_TYPE_PointerTo_Plasma__DownloadFileResponse:
		return soap_out_PointerTo_Plasma__DownloadFileResponse(soap, tag, id, (_Plasma__DownloadFileResponse *const*)ptr, "Plasma:DownloadFileResponse");
	case SOAP_TYPE_PointerTo_Plasma__DownloadFile:
		return soap_out_PointerTo_Plasma__DownloadFile(soap, tag, id, (_Plasma__DownloadFile *const*)ptr, "Plasma:DownloadFile");
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeamsResponse:
		return soap_out_PointerTo_Plasma__BalanceTeamsResponse(soap, tag, id, (_Plasma__BalanceTeamsResponse *const*)ptr, "Plasma:BalanceTeamsResponse");
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeams:
		return soap_out_PointerTo_Plasma__BalanceTeams(soap, tag, id, (_Plasma__BalanceTeams *const*)ptr, "Plasma:BalanceTeams");
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoinedResponse:
		return soap_out_PointerTo_Plasma__AutohostPlayerJoinedResponse(soap, tag, id, (_Plasma__AutohostPlayerJoinedResponse *const*)ptr, "Plasma:AutohostPlayerJoinedResponse");
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoined:
		return soap_out_PointerTo_Plasma__AutohostPlayerJoined(soap, tag, id, (_Plasma__AutohostPlayerJoined *const*)ptr, "Plasma:AutohostPlayerJoined");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattlePlayerResult:
		return soap_out_PointerToPlasma__ArrayOfBattlePlayerResult(soap, tag, id, (Plasma__ArrayOfBattlePlayerResult *const*)ptr, "Plasma:ArrayOfBattlePlayerResult");
	case SOAP_TYPE_PointerToPlasma__BattleResult:
		return soap_out_PointerToPlasma__BattleResult(soap, tag, id, (Plasma__BattleResult *const*)ptr, "Plasma:BattleResult");
	case SOAP_TYPE_PointerToPlasma__SpringBattleStartSetup:
		return soap_out_PointerToPlasma__SpringBattleStartSetup(soap, tag, id, (Plasma__SpringBattleStartSetup *const*)ptr, "Plasma:SpringBattleStartSetup");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattleStartSetupPlayer:
		return soap_out_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, tag, id, (Plasma__ArrayOfBattleStartSetupPlayer *const*)ptr, "Plasma:ArrayOfBattleStartSetupPlayer");
	case SOAP_TYPE_PointerToPlasma__ScriptMissionData:
		return soap_out_PointerToPlasma__ScriptMissionData(soap, tag, id, (Plasma__ScriptMissionData *const*)ptr, "Plasma:ScriptMissionData");
	case SOAP_TYPE_PointerToPlasma__ArrayOfResourceData:
		return soap_out_PointerToPlasma__ArrayOfResourceData(soap, tag, id, (Plasma__ArrayOfResourceData *const*)ptr, "Plasma:ArrayOfResourceData");
	case SOAP_TYPE_PointerToPlasma__RecommendedMapResult:
		return soap_out_PointerToPlasma__RecommendedMapResult(soap, tag, id, (Plasma__RecommendedMapResult *const*)ptr, "Plasma:RecommendedMapResult");
	case SOAP_TYPE_PointerToPlasma__EloInfo:
		return soap_out_PointerToPlasma__EloInfo(soap, tag, id, (Plasma__EloInfo *const*)ptr, "Plasma:EloInfo");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToPlasma__BalanceTeamsResult:
		return soap_out_PointerToPlasma__BalanceTeamsResult(soap, tag, id, (Plasma__BalanceTeamsResult *const*)ptr, "Plasma:BalanceTeamsResult");
	case SOAP_TYPE_PointerToPlasma__PlayerStats:
		return soap_out_PointerToPlasma__PlayerStats(soap, tag, id, (Plasma__PlayerStats *const*)ptr, "Plasma:PlayerStats");
	case SOAP_TYPE_PointerToPlasma__PlayerAward:
		return soap_out_PointerToPlasma__PlayerAward(soap, tag, id, (Plasma__PlayerAward *const*)ptr, "Plasma:PlayerAward");
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerStats:
		return soap_out_PointerToPlasma__ArrayOfPlayerStats(soap, tag, id, (Plasma__ArrayOfPlayerStats *const*)ptr, "Plasma:ArrayOfPlayerStats");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerAward:
		return soap_out_PointerToPlasma__ArrayOfPlayerAward(soap, tag, id, (Plasma__ArrayOfPlayerAward *const*)ptr, "Plasma:ArrayOfPlayerAward");
	case SOAP_TYPE_PointerToPlasma__BattlePlayerResult:
		return soap_out_PointerToPlasma__BattlePlayerResult(soap, tag, id, (Plasma__BattlePlayerResult *const*)ptr, "Plasma:BattlePlayerResult");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPlasma__UserCustomParameters:
		return soap_out_PointerToPlasma__UserCustomParameters(soap, tag, id, (Plasma__UserCustomParameters *const*)ptr, "Plasma:UserCustomParameters");
	case SOAP_TYPE_PointerToPlasma__ScriptKeyValuePair:
		return soap_out_PointerToPlasma__ScriptKeyValuePair(soap, tag, id, (Plasma__ScriptKeyValuePair *const*)ptr, "Plasma:ScriptKeyValuePair");
	case SOAP_TYPE_PointerToPlasma__ArrayOfUserCustomParameters:
		return soap_out_PointerToPlasma__ArrayOfUserCustomParameters(soap, tag, id, (Plasma__ArrayOfUserCustomParameters *const*)ptr, "Plasma:ArrayOfUserCustomParameters");
	case SOAP_TYPE_PointerToPlasma__ArrayOfScriptKeyValuePair:
		return soap_out_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, tag, id, (Plasma__ArrayOfScriptKeyValuePair *const*)ptr, "Plasma:ArrayOfScriptKeyValuePair");
	case SOAP_TYPE_PointerToPlasma__BattleStartSetupPlayer:
		return soap_out_PointerToPlasma__BattleStartSetupPlayer(soap, tag, id, (Plasma__BattleStartSetupPlayer *const*)ptr, "Plasma:BattleStartSetupPlayer");
	case SOAP_TYPE_PointerToPlasma__ResourceData:
		return soap_out_PointerToPlasma__ResourceData(soap, tag, id, (Plasma__ResourceData *const*)ptr, "Plasma:ResourceData");
	case SOAP_TYPE_PointerToPlasma__SpringHashEntry:
		return soap_out_PointerToPlasma__SpringHashEntry(soap, tag, id, (Plasma__SpringHashEntry *const*)ptr, "Plasma:SpringHashEntry");
	case SOAP_TYPE_PointerToPlasma__ArrayOfSpringHashEntry:
		return soap_out_PointerToPlasma__ArrayOfSpringHashEntry(soap, tag, id, (Plasma__ArrayOfSpringHashEntry *const*)ptr, "Plasma:ArrayOfSpringHashEntry");
	case SOAP_TYPE_PointerToPlasma__ArrayOfString:
		return soap_out_PointerToPlasma__ArrayOfString(soap, tag, id, (Plasma__ArrayOfString *const*)ptr, "Plasma:ArrayOfString");
	case SOAP_TYPE_PointerToPlasma__BotTeam:
		return soap_out_PointerToPlasma__BotTeam(soap, tag, id, (Plasma__BotTeam *const*)ptr, "Plasma:BotTeam");
	case SOAP_TYPE_PointerToPlasma__ArrayOfBotTeam:
		return soap_out_PointerToPlasma__ArrayOfBotTeam(soap, tag, id, (Plasma__ArrayOfBotTeam *const*)ptr, "Plasma:ArrayOfBotTeam");
	case SOAP_TYPE_PointerToPlasma__ArrayOfAccountTeam:
		return soap_out_PointerToPlasma__ArrayOfAccountTeam(soap, tag, id, (Plasma__ArrayOfAccountTeam *const*)ptr, "Plasma:ArrayOfAccountTeam");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPlasma__AccountTeam:
		return soap_out_PointerToPlasma__AccountTeam(soap, tag, id, (Plasma__AccountTeam *const*)ptr, "Plasma:AccountTeam");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__Plasma__VerifyAccountDataResponse:
		((_Plasma__VerifyAccountDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__VerifyAccountData:
		((_Plasma__VerifyAccountData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitStackTraceResponse:
		((_Plasma__SubmitStackTraceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitStackTrace:
		((_Plasma__SubmitStackTrace *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse:
		((_Plasma__SubmitSpringBattleResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitSpringBattleResult:
		((_Plasma__SubmitSpringBattleResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitMissionScoreResponse:
		((_Plasma__SubmitMissionScoreResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__SubmitMissionScore:
		((_Plasma__SubmitMissionScore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__RegisterResourceResponse:
		((_Plasma__RegisterResourceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__RegisterResource:
		((_Plasma__RegisterResource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__NotifyMissionRunResponse:
		((_Plasma__NotifyMissionRunResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__NotifyMissionRun:
		((_Plasma__NotifyMissionRun *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse:
		((_Plasma__GetSpringBattleStartSetupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetup:
		((_Plasma__GetSpringBattleStartSetup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetScriptMissionDataResponse:
		((_Plasma__GetScriptMissionDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetScriptMissionData:
		((_Plasma__GetScriptMissionData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetResourceListResponse:
		((_Plasma__GetResourceListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetResourceList:
		((_Plasma__GetResourceList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetResourceDataResponse:
		((_Plasma__GetResourceDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetResourceData:
		((_Plasma__GetResourceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetRecommendedMapResponse:
		((_Plasma__GetRecommendedMapResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetRecommendedMap:
		((_Plasma__GetRecommendedMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloTop10Response:
		((_Plasma__GetEloTop10Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloTop10:
		((_Plasma__GetEloTop10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloByNameResponse:
		((_Plasma__GetEloByNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloByName:
		((_Plasma__GetEloByName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloByAccountIDResponse:
		((_Plasma__GetEloByAccountIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__GetEloByAccountID:
		((_Plasma__GetEloByAccountID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__DownloadFileResponse:
		((_Plasma__DownloadFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__DownloadFile:
		((_Plasma__DownloadFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__BalanceTeamsResponse:
		((_Plasma__BalanceTeamsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__BalanceTeams:
		((_Plasma__BalanceTeams *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse:
		((_Plasma__AutohostPlayerJoinedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__Plasma__AutohostPlayerJoined:
		((_Plasma__AutohostPlayerJoined *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__PlayerStats:
		((Plasma__PlayerStats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfPlayerStats:
		((Plasma__ArrayOfPlayerStats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__PlayerAward:
		((Plasma__PlayerAward *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfPlayerAward:
		((Plasma__ArrayOfPlayerAward *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__BattlePlayerResult:
		((Plasma__BattlePlayerResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult:
		((Plasma__ArrayOfBattlePlayerResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__BattleResult:
		((Plasma__BattleResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__UserCustomParameters:
		((Plasma__UserCustomParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfUserCustomParameters:
		((Plasma__ArrayOfUserCustomParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ScriptKeyValuePair:
		((Plasma__ScriptKeyValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair:
		((Plasma__ArrayOfScriptKeyValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__SpringBattleStartSetup:
		((Plasma__SpringBattleStartSetup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__BattleStartSetupPlayer:
		((Plasma__BattleStartSetupPlayer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer:
		((Plasma__ArrayOfBattleStartSetupPlayer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ScriptMissionData:
		((Plasma__ScriptMissionData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfResourceData:
		((Plasma__ArrayOfResourceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__SpringHashEntry:
		((Plasma__SpringHashEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfSpringHashEntry:
		((Plasma__ArrayOfSpringHashEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ResourceData:
		((Plasma__ResourceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__RecommendedMapResult:
		((Plasma__RecommendedMapResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__EloInfo:
		((Plasma__EloInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfString:
		((Plasma__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__BotTeam:
		((Plasma__BotTeam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfBotTeam:
		((Plasma__ArrayOfBotTeam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__BalanceTeamsResult:
		((Plasma__BalanceTeamsResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__AccountTeam:
		((Plasma__AccountTeam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Plasma__ArrayOfAccountTeam:
		((Plasma__ArrayOfAccountTeam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___Plasma3__VerifyAccountData:
		soap_serialize___Plasma3__VerifyAccountData(soap, (const struct __Plasma3__VerifyAccountData *)ptr);
		break;
	case SOAP_TYPE___Plasma3__SubmitStackTrace:
		soap_serialize___Plasma3__SubmitStackTrace(soap, (const struct __Plasma3__SubmitStackTrace *)ptr);
		break;
	case SOAP_TYPE___Plasma3__SubmitSpringBattleResult:
		soap_serialize___Plasma3__SubmitSpringBattleResult(soap, (const struct __Plasma3__SubmitSpringBattleResult *)ptr);
		break;
	case SOAP_TYPE___Plasma3__SubmitMissionScore:
		soap_serialize___Plasma3__SubmitMissionScore(soap, (const struct __Plasma3__SubmitMissionScore *)ptr);
		break;
	case SOAP_TYPE___Plasma3__RegisterResource:
		soap_serialize___Plasma3__RegisterResource(soap, (const struct __Plasma3__RegisterResource *)ptr);
		break;
	case SOAP_TYPE___Plasma3__NotifyMissionRun:
		soap_serialize___Plasma3__NotifyMissionRun(soap, (const struct __Plasma3__NotifyMissionRun *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetSpringBattleStartSetup:
		soap_serialize___Plasma3__GetSpringBattleStartSetup(soap, (const struct __Plasma3__GetSpringBattleStartSetup *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetScriptMissionData:
		soap_serialize___Plasma3__GetScriptMissionData(soap, (const struct __Plasma3__GetScriptMissionData *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetResourceList:
		soap_serialize___Plasma3__GetResourceList(soap, (const struct __Plasma3__GetResourceList *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetResourceData:
		soap_serialize___Plasma3__GetResourceData(soap, (const struct __Plasma3__GetResourceData *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetRecommendedMap:
		soap_serialize___Plasma3__GetRecommendedMap(soap, (const struct __Plasma3__GetRecommendedMap *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetEloTop10:
		soap_serialize___Plasma3__GetEloTop10(soap, (const struct __Plasma3__GetEloTop10 *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetEloByName:
		soap_serialize___Plasma3__GetEloByName(soap, (const struct __Plasma3__GetEloByName *)ptr);
		break;
	case SOAP_TYPE___Plasma3__GetEloByAccountID:
		soap_serialize___Plasma3__GetEloByAccountID(soap, (const struct __Plasma3__GetEloByAccountID *)ptr);
		break;
	case SOAP_TYPE___Plasma3__DownloadFile:
		soap_serialize___Plasma3__DownloadFile(soap, (const struct __Plasma3__DownloadFile *)ptr);
		break;
	case SOAP_TYPE___Plasma3__BalanceTeams:
		soap_serialize___Plasma3__BalanceTeams(soap, (const struct __Plasma3__BalanceTeams *)ptr);
		break;
	case SOAP_TYPE___Plasma3__AutohostPlayerJoined:
		soap_serialize___Plasma3__AutohostPlayerJoined(soap, (const struct __Plasma3__AutohostPlayerJoined *)ptr);
		break;
	case SOAP_TYPE___Plasma2__VerifyAccountData:
		soap_serialize___Plasma2__VerifyAccountData(soap, (const struct __Plasma2__VerifyAccountData *)ptr);
		break;
	case SOAP_TYPE___Plasma2__SubmitStackTrace:
		soap_serialize___Plasma2__SubmitStackTrace(soap, (const struct __Plasma2__SubmitStackTrace *)ptr);
		break;
	case SOAP_TYPE___Plasma2__SubmitSpringBattleResult:
		soap_serialize___Plasma2__SubmitSpringBattleResult(soap, (const struct __Plasma2__SubmitSpringBattleResult *)ptr);
		break;
	case SOAP_TYPE___Plasma2__SubmitMissionScore:
		soap_serialize___Plasma2__SubmitMissionScore(soap, (const struct __Plasma2__SubmitMissionScore *)ptr);
		break;
	case SOAP_TYPE___Plasma2__RegisterResource:
		soap_serialize___Plasma2__RegisterResource(soap, (const struct __Plasma2__RegisterResource *)ptr);
		break;
	case SOAP_TYPE___Plasma2__NotifyMissionRun:
		soap_serialize___Plasma2__NotifyMissionRun(soap, (const struct __Plasma2__NotifyMissionRun *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetSpringBattleStartSetup:
		soap_serialize___Plasma2__GetSpringBattleStartSetup(soap, (const struct __Plasma2__GetSpringBattleStartSetup *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetScriptMissionData:
		soap_serialize___Plasma2__GetScriptMissionData(soap, (const struct __Plasma2__GetScriptMissionData *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetResourceList:
		soap_serialize___Plasma2__GetResourceList(soap, (const struct __Plasma2__GetResourceList *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetResourceData:
		soap_serialize___Plasma2__GetResourceData(soap, (const struct __Plasma2__GetResourceData *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetRecommendedMap:
		soap_serialize___Plasma2__GetRecommendedMap(soap, (const struct __Plasma2__GetRecommendedMap *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetEloTop10:
		soap_serialize___Plasma2__GetEloTop10(soap, (const struct __Plasma2__GetEloTop10 *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetEloByName:
		soap_serialize___Plasma2__GetEloByName(soap, (const struct __Plasma2__GetEloByName *)ptr);
		break;
	case SOAP_TYPE___Plasma2__GetEloByAccountID:
		soap_serialize___Plasma2__GetEloByAccountID(soap, (const struct __Plasma2__GetEloByAccountID *)ptr);
		break;
	case SOAP_TYPE___Plasma2__DownloadFile:
		soap_serialize___Plasma2__DownloadFile(soap, (const struct __Plasma2__DownloadFile *)ptr);
		break;
	case SOAP_TYPE___Plasma2__BalanceTeams:
		soap_serialize___Plasma2__BalanceTeams(soap, (const struct __Plasma2__BalanceTeams *)ptr);
		break;
	case SOAP_TYPE___Plasma2__AutohostPlayerJoined:
		soap_serialize___Plasma2__AutohostPlayerJoined(soap, (const struct __Plasma2__AutohostPlayerJoined *)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountDataResponse:
		soap_serialize_PointerTo_Plasma__VerifyAccountDataResponse(soap, (_Plasma__VerifyAccountDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__VerifyAccountData:
		soap_serialize_PointerTo_Plasma__VerifyAccountData(soap, (_Plasma__VerifyAccountData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTraceResponse:
		soap_serialize_PointerTo_Plasma__SubmitStackTraceResponse(soap, (_Plasma__SubmitStackTraceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitStackTrace:
		soap_serialize_PointerTo_Plasma__SubmitStackTrace(soap, (_Plasma__SubmitStackTrace *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResultResponse:
		soap_serialize_PointerTo_Plasma__SubmitSpringBattleResultResponse(soap, (_Plasma__SubmitSpringBattleResultResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResult:
		soap_serialize_PointerTo_Plasma__SubmitSpringBattleResult(soap, (_Plasma__SubmitSpringBattleResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScoreResponse:
		soap_serialize_PointerTo_Plasma__SubmitMissionScoreResponse(soap, (_Plasma__SubmitMissionScoreResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__SubmitMissionScore:
		soap_serialize_PointerTo_Plasma__SubmitMissionScore(soap, (_Plasma__SubmitMissionScore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__RegisterResourceResponse:
		soap_serialize_PointerTo_Plasma__RegisterResourceResponse(soap, (_Plasma__RegisterResourceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__RegisterResource:
		soap_serialize_PointerTo_Plasma__RegisterResource(soap, (_Plasma__RegisterResource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRunResponse:
		soap_serialize_PointerTo_Plasma__NotifyMissionRunResponse(soap, (_Plasma__NotifyMissionRunResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__NotifyMissionRun:
		soap_serialize_PointerTo_Plasma__NotifyMissionRun(soap, (_Plasma__NotifyMissionRun *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetupResponse:
		soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetupResponse(soap, (_Plasma__GetSpringBattleStartSetupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetup:
		soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetup(soap, (_Plasma__GetSpringBattleStartSetup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionDataResponse:
		soap_serialize_PointerTo_Plasma__GetScriptMissionDataResponse(soap, (_Plasma__GetScriptMissionDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetScriptMissionData:
		soap_serialize_PointerTo_Plasma__GetScriptMissionData(soap, (_Plasma__GetScriptMissionData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetResourceListResponse:
		soap_serialize_PointerTo_Plasma__GetResourceListResponse(soap, (_Plasma__GetResourceListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetResourceList:
		soap_serialize_PointerTo_Plasma__GetResourceList(soap, (_Plasma__GetResourceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetResourceDataResponse:
		soap_serialize_PointerTo_Plasma__GetResourceDataResponse(soap, (_Plasma__GetResourceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetResourceData:
		soap_serialize_PointerTo_Plasma__GetResourceData(soap, (_Plasma__GetResourceData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMapResponse:
		soap_serialize_PointerTo_Plasma__GetRecommendedMapResponse(soap, (_Plasma__GetRecommendedMapResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetRecommendedMap:
		soap_serialize_PointerTo_Plasma__GetRecommendedMap(soap, (_Plasma__GetRecommendedMap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10Response:
		soap_serialize_PointerTo_Plasma__GetEloTop10Response(soap, (_Plasma__GetEloTop10Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloTop10:
		soap_serialize_PointerTo_Plasma__GetEloTop10(soap, (_Plasma__GetEloTop10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloByNameResponse:
		soap_serialize_PointerTo_Plasma__GetEloByNameResponse(soap, (_Plasma__GetEloByNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloByName:
		soap_serialize_PointerTo_Plasma__GetEloByName(soap, (_Plasma__GetEloByName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountIDResponse:
		soap_serialize_PointerTo_Plasma__GetEloByAccountIDResponse(soap, (_Plasma__GetEloByAccountIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__GetEloByAccountID:
		soap_serialize_PointerTo_Plasma__GetEloByAccountID(soap, (_Plasma__GetEloByAccountID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__DownloadFileResponse:
		soap_serialize_PointerTo_Plasma__DownloadFileResponse(soap, (_Plasma__DownloadFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__DownloadFile:
		soap_serialize_PointerTo_Plasma__DownloadFile(soap, (_Plasma__DownloadFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeamsResponse:
		soap_serialize_PointerTo_Plasma__BalanceTeamsResponse(soap, (_Plasma__BalanceTeamsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__BalanceTeams:
		soap_serialize_PointerTo_Plasma__BalanceTeams(soap, (_Plasma__BalanceTeams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoinedResponse:
		soap_serialize_PointerTo_Plasma__AutohostPlayerJoinedResponse(soap, (_Plasma__AutohostPlayerJoinedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoined:
		soap_serialize_PointerTo_Plasma__AutohostPlayerJoined(soap, (_Plasma__AutohostPlayerJoined *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattlePlayerResult:
		soap_serialize_PointerToPlasma__ArrayOfBattlePlayerResult(soap, (Plasma__ArrayOfBattlePlayerResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__BattleResult:
		soap_serialize_PointerToPlasma__BattleResult(soap, (Plasma__BattleResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__SpringBattleStartSetup:
		soap_serialize_PointerToPlasma__SpringBattleStartSetup(soap, (Plasma__SpringBattleStartSetup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfBattleStartSetupPlayer:
		soap_serialize_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, (Plasma__ArrayOfBattleStartSetupPlayer *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ScriptMissionData:
		soap_serialize_PointerToPlasma__ScriptMissionData(soap, (Plasma__ScriptMissionData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfResourceData:
		soap_serialize_PointerToPlasma__ArrayOfResourceData(soap, (Plasma__ArrayOfResourceData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__RecommendedMapResult:
		soap_serialize_PointerToPlasma__RecommendedMapResult(soap, (Plasma__RecommendedMapResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__EloInfo:
		soap_serialize_PointerToPlasma__EloInfo(soap, (Plasma__EloInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__BalanceTeamsResult:
		soap_serialize_PointerToPlasma__BalanceTeamsResult(soap, (Plasma__BalanceTeamsResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__PlayerStats:
		soap_serialize_PointerToPlasma__PlayerStats(soap, (Plasma__PlayerStats *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__PlayerAward:
		soap_serialize_PointerToPlasma__PlayerAward(soap, (Plasma__PlayerAward *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerStats:
		soap_serialize_PointerToPlasma__ArrayOfPlayerStats(soap, (Plasma__ArrayOfPlayerStats *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfPlayerAward:
		soap_serialize_PointerToPlasma__ArrayOfPlayerAward(soap, (Plasma__ArrayOfPlayerAward *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__BattlePlayerResult:
		soap_serialize_PointerToPlasma__BattlePlayerResult(soap, (Plasma__BattlePlayerResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__UserCustomParameters:
		soap_serialize_PointerToPlasma__UserCustomParameters(soap, (Plasma__UserCustomParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ScriptKeyValuePair:
		soap_serialize_PointerToPlasma__ScriptKeyValuePair(soap, (Plasma__ScriptKeyValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfUserCustomParameters:
		soap_serialize_PointerToPlasma__ArrayOfUserCustomParameters(soap, (Plasma__ArrayOfUserCustomParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfScriptKeyValuePair:
		soap_serialize_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, (Plasma__ArrayOfScriptKeyValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__BattleStartSetupPlayer:
		soap_serialize_PointerToPlasma__BattleStartSetupPlayer(soap, (Plasma__BattleStartSetupPlayer *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ResourceData:
		soap_serialize_PointerToPlasma__ResourceData(soap, (Plasma__ResourceData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__SpringHashEntry:
		soap_serialize_PointerToPlasma__SpringHashEntry(soap, (Plasma__SpringHashEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfSpringHashEntry:
		soap_serialize_PointerToPlasma__ArrayOfSpringHashEntry(soap, (Plasma__ArrayOfSpringHashEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfString:
		soap_serialize_PointerToPlasma__ArrayOfString(soap, (Plasma__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__BotTeam:
		soap_serialize_PointerToPlasma__BotTeam(soap, (Plasma__BotTeam *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfBotTeam:
		soap_serialize_PointerToPlasma__ArrayOfBotTeam(soap, (Plasma__ArrayOfBotTeam *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__ArrayOfAccountTeam:
		soap_serialize_PointerToPlasma__ArrayOfAccountTeam(soap, (Plasma__ArrayOfAccountTeam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlasma__AccountTeam:
		soap_serialize_PointerToPlasma__AccountTeam(soap, (Plasma__AccountTeam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfAccountTeam:
		return (void*)soap_instantiate_Plasma__ArrayOfAccountTeam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__AccountTeam:
		return (void*)soap_instantiate_Plasma__AccountTeam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__BalanceTeamsResult:
		return (void*)soap_instantiate_Plasma__BalanceTeamsResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfBotTeam:
		return (void*)soap_instantiate_Plasma__ArrayOfBotTeam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__BotTeam:
		return (void*)soap_instantiate_Plasma__BotTeam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfString:
		return (void*)soap_instantiate_Plasma__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__EloInfo:
		return (void*)soap_instantiate_Plasma__EloInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__RecommendedMapResult:
		return (void*)soap_instantiate_Plasma__RecommendedMapResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ResourceData:
		return (void*)soap_instantiate_Plasma__ResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfSpringHashEntry:
		return (void*)soap_instantiate_Plasma__ArrayOfSpringHashEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__SpringHashEntry:
		return (void*)soap_instantiate_Plasma__SpringHashEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfResourceData:
		return (void*)soap_instantiate_Plasma__ArrayOfResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ScriptMissionData:
		return (void*)soap_instantiate_Plasma__ScriptMissionData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer:
		return (void*)soap_instantiate_Plasma__ArrayOfBattleStartSetupPlayer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__BattleStartSetupPlayer:
		return (void*)soap_instantiate_Plasma__BattleStartSetupPlayer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__SpringBattleStartSetup:
		return (void*)soap_instantiate_Plasma__SpringBattleStartSetup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair:
		return (void*)soap_instantiate_Plasma__ArrayOfScriptKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ScriptKeyValuePair:
		return (void*)soap_instantiate_Plasma__ScriptKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfUserCustomParameters:
		return (void*)soap_instantiate_Plasma__ArrayOfUserCustomParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__UserCustomParameters:
		return (void*)soap_instantiate_Plasma__UserCustomParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__BattleResult:
		return (void*)soap_instantiate_Plasma__BattleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult:
		return (void*)soap_instantiate_Plasma__ArrayOfBattlePlayerResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__BattlePlayerResult:
		return (void*)soap_instantiate_Plasma__BattlePlayerResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfPlayerAward:
		return (void*)soap_instantiate_Plasma__ArrayOfPlayerAward(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__PlayerAward:
		return (void*)soap_instantiate_Plasma__PlayerAward(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__ArrayOfPlayerStats:
		return (void*)soap_instantiate_Plasma__ArrayOfPlayerStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Plasma__PlayerStats:
		return (void*)soap_instantiate_Plasma__PlayerStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__AutohostPlayerJoined:
		return (void*)soap_instantiate__Plasma__AutohostPlayerJoined(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse:
		return (void*)soap_instantiate__Plasma__AutohostPlayerJoinedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__BalanceTeams:
		return (void*)soap_instantiate__Plasma__BalanceTeams(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__BalanceTeamsResponse:
		return (void*)soap_instantiate__Plasma__BalanceTeamsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__DownloadFile:
		return (void*)soap_instantiate__Plasma__DownloadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__DownloadFileResponse:
		return (void*)soap_instantiate__Plasma__DownloadFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloByAccountID:
		return (void*)soap_instantiate__Plasma__GetEloByAccountID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloByAccountIDResponse:
		return (void*)soap_instantiate__Plasma__GetEloByAccountIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloByName:
		return (void*)soap_instantiate__Plasma__GetEloByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloByNameResponse:
		return (void*)soap_instantiate__Plasma__GetEloByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloTop10:
		return (void*)soap_instantiate__Plasma__GetEloTop10(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetEloTop10Response:
		return (void*)soap_instantiate__Plasma__GetEloTop10Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetRecommendedMap:
		return (void*)soap_instantiate__Plasma__GetRecommendedMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetRecommendedMapResponse:
		return (void*)soap_instantiate__Plasma__GetRecommendedMapResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetResourceData:
		return (void*)soap_instantiate__Plasma__GetResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetResourceDataResponse:
		return (void*)soap_instantiate__Plasma__GetResourceDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetResourceList:
		return (void*)soap_instantiate__Plasma__GetResourceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetResourceListResponse:
		return (void*)soap_instantiate__Plasma__GetResourceListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetScriptMissionData:
		return (void*)soap_instantiate__Plasma__GetScriptMissionData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetScriptMissionDataResponse:
		return (void*)soap_instantiate__Plasma__GetScriptMissionDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetup:
		return (void*)soap_instantiate__Plasma__GetSpringBattleStartSetup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse:
		return (void*)soap_instantiate__Plasma__GetSpringBattleStartSetupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__NotifyMissionRun:
		return (void*)soap_instantiate__Plasma__NotifyMissionRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__NotifyMissionRunResponse:
		return (void*)soap_instantiate__Plasma__NotifyMissionRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__RegisterResource:
		return (void*)soap_instantiate__Plasma__RegisterResource(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__RegisterResourceResponse:
		return (void*)soap_instantiate__Plasma__RegisterResourceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitMissionScore:
		return (void*)soap_instantiate__Plasma__SubmitMissionScore(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitMissionScoreResponse:
		return (void*)soap_instantiate__Plasma__SubmitMissionScoreResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitSpringBattleResult:
		return (void*)soap_instantiate__Plasma__SubmitSpringBattleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse:
		return (void*)soap_instantiate__Plasma__SubmitSpringBattleResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitStackTrace:
		return (void*)soap_instantiate__Plasma__SubmitStackTrace(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__SubmitStackTraceResponse:
		return (void*)soap_instantiate__Plasma__SubmitStackTraceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__VerifyAccountData:
		return (void*)soap_instantiate__Plasma__VerifyAccountData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Plasma__VerifyAccountDataResponse:
		return (void*)soap_instantiate__Plasma__VerifyAccountDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__AutohostPlayerJoined:
		return (void*)soap_instantiate___Plasma2__AutohostPlayerJoined(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__BalanceTeams:
		return (void*)soap_instantiate___Plasma2__BalanceTeams(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__DownloadFile:
		return (void*)soap_instantiate___Plasma2__DownloadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetEloByAccountID:
		return (void*)soap_instantiate___Plasma2__GetEloByAccountID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetEloByName:
		return (void*)soap_instantiate___Plasma2__GetEloByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetEloTop10:
		return (void*)soap_instantiate___Plasma2__GetEloTop10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetRecommendedMap:
		return (void*)soap_instantiate___Plasma2__GetRecommendedMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetResourceData:
		return (void*)soap_instantiate___Plasma2__GetResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetResourceList:
		return (void*)soap_instantiate___Plasma2__GetResourceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetScriptMissionData:
		return (void*)soap_instantiate___Plasma2__GetScriptMissionData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__GetSpringBattleStartSetup:
		return (void*)soap_instantiate___Plasma2__GetSpringBattleStartSetup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__NotifyMissionRun:
		return (void*)soap_instantiate___Plasma2__NotifyMissionRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__RegisterResource:
		return (void*)soap_instantiate___Plasma2__RegisterResource(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__SubmitMissionScore:
		return (void*)soap_instantiate___Plasma2__SubmitMissionScore(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__SubmitSpringBattleResult:
		return (void*)soap_instantiate___Plasma2__SubmitSpringBattleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__SubmitStackTrace:
		return (void*)soap_instantiate___Plasma2__SubmitStackTrace(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma2__VerifyAccountData:
		return (void*)soap_instantiate___Plasma2__VerifyAccountData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__AutohostPlayerJoined:
		return (void*)soap_instantiate___Plasma3__AutohostPlayerJoined(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__BalanceTeams:
		return (void*)soap_instantiate___Plasma3__BalanceTeams(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__DownloadFile:
		return (void*)soap_instantiate___Plasma3__DownloadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetEloByAccountID:
		return (void*)soap_instantiate___Plasma3__GetEloByAccountID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetEloByName:
		return (void*)soap_instantiate___Plasma3__GetEloByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetEloTop10:
		return (void*)soap_instantiate___Plasma3__GetEloTop10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetRecommendedMap:
		return (void*)soap_instantiate___Plasma3__GetRecommendedMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetResourceData:
		return (void*)soap_instantiate___Plasma3__GetResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetResourceList:
		return (void*)soap_instantiate___Plasma3__GetResourceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetScriptMissionData:
		return (void*)soap_instantiate___Plasma3__GetScriptMissionData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__GetSpringBattleStartSetup:
		return (void*)soap_instantiate___Plasma3__GetSpringBattleStartSetup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__NotifyMissionRun:
		return (void*)soap_instantiate___Plasma3__NotifyMissionRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__RegisterResource:
		return (void*)soap_instantiate___Plasma3__RegisterResource(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__SubmitMissionScore:
		return (void*)soap_instantiate___Plasma3__SubmitMissionScore(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__SubmitSpringBattleResult:
		return (void*)soap_instantiate___Plasma3__SubmitSpringBattleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__SubmitStackTrace:
		return (void*)soap_instantiate___Plasma3__SubmitStackTrace(soap, -1, type, arrayType, n);
	case SOAP_TYPE___Plasma3__VerifyAccountData:
		return (void*)soap_instantiate___Plasma3__VerifyAccountData(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerStats:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerAward:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__UserCustomParameters:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ResourceData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__SpringHashEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BotTeam:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__AccountTeam:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfAccountTeam:
		if (p->size < 0)
			delete (Plasma__ArrayOfAccountTeam*)p->ptr;
		else
			delete[] (Plasma__ArrayOfAccountTeam*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__AccountTeam:
		if (p->size < 0)
			delete (Plasma__AccountTeam*)p->ptr;
		else
			delete[] (Plasma__AccountTeam*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__BalanceTeamsResult:
		if (p->size < 0)
			delete (Plasma__BalanceTeamsResult*)p->ptr;
		else
			delete[] (Plasma__BalanceTeamsResult*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfBotTeam:
		if (p->size < 0)
			delete (Plasma__ArrayOfBotTeam*)p->ptr;
		else
			delete[] (Plasma__ArrayOfBotTeam*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__BotTeam:
		if (p->size < 0)
			delete (Plasma__BotTeam*)p->ptr;
		else
			delete[] (Plasma__BotTeam*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfString:
		if (p->size < 0)
			delete (Plasma__ArrayOfString*)p->ptr;
		else
			delete[] (Plasma__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__EloInfo:
		if (p->size < 0)
			delete (Plasma__EloInfo*)p->ptr;
		else
			delete[] (Plasma__EloInfo*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__RecommendedMapResult:
		if (p->size < 0)
			delete (Plasma__RecommendedMapResult*)p->ptr;
		else
			delete[] (Plasma__RecommendedMapResult*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ResourceData:
		if (p->size < 0)
			delete (Plasma__ResourceData*)p->ptr;
		else
			delete[] (Plasma__ResourceData*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfSpringHashEntry:
		if (p->size < 0)
			delete (Plasma__ArrayOfSpringHashEntry*)p->ptr;
		else
			delete[] (Plasma__ArrayOfSpringHashEntry*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__SpringHashEntry:
		if (p->size < 0)
			delete (Plasma__SpringHashEntry*)p->ptr;
		else
			delete[] (Plasma__SpringHashEntry*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfResourceData:
		if (p->size < 0)
			delete (Plasma__ArrayOfResourceData*)p->ptr;
		else
			delete[] (Plasma__ArrayOfResourceData*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ScriptMissionData:
		if (p->size < 0)
			delete (Plasma__ScriptMissionData*)p->ptr;
		else
			delete[] (Plasma__ScriptMissionData*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer:
		if (p->size < 0)
			delete (Plasma__ArrayOfBattleStartSetupPlayer*)p->ptr;
		else
			delete[] (Plasma__ArrayOfBattleStartSetupPlayer*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__BattleStartSetupPlayer:
		if (p->size < 0)
			delete (Plasma__BattleStartSetupPlayer*)p->ptr;
		else
			delete[] (Plasma__BattleStartSetupPlayer*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__SpringBattleStartSetup:
		if (p->size < 0)
			delete (Plasma__SpringBattleStartSetup*)p->ptr;
		else
			delete[] (Plasma__SpringBattleStartSetup*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair:
		if (p->size < 0)
			delete (Plasma__ArrayOfScriptKeyValuePair*)p->ptr;
		else
			delete[] (Plasma__ArrayOfScriptKeyValuePair*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ScriptKeyValuePair:
		if (p->size < 0)
			delete (Plasma__ScriptKeyValuePair*)p->ptr;
		else
			delete[] (Plasma__ScriptKeyValuePair*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfUserCustomParameters:
		if (p->size < 0)
			delete (Plasma__ArrayOfUserCustomParameters*)p->ptr;
		else
			delete[] (Plasma__ArrayOfUserCustomParameters*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__UserCustomParameters:
		if (p->size < 0)
			delete (Plasma__UserCustomParameters*)p->ptr;
		else
			delete[] (Plasma__UserCustomParameters*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__BattleResult:
		if (p->size < 0)
			delete (Plasma__BattleResult*)p->ptr;
		else
			delete[] (Plasma__BattleResult*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult:
		if (p->size < 0)
			delete (Plasma__ArrayOfBattlePlayerResult*)p->ptr;
		else
			delete[] (Plasma__ArrayOfBattlePlayerResult*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__BattlePlayerResult:
		if (p->size < 0)
			delete (Plasma__BattlePlayerResult*)p->ptr;
		else
			delete[] (Plasma__BattlePlayerResult*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfPlayerAward:
		if (p->size < 0)
			delete (Plasma__ArrayOfPlayerAward*)p->ptr;
		else
			delete[] (Plasma__ArrayOfPlayerAward*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__PlayerAward:
		if (p->size < 0)
			delete (Plasma__PlayerAward*)p->ptr;
		else
			delete[] (Plasma__PlayerAward*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__ArrayOfPlayerStats:
		if (p->size < 0)
			delete (Plasma__ArrayOfPlayerStats*)p->ptr;
		else
			delete[] (Plasma__ArrayOfPlayerStats*)p->ptr;
		break;
	case SOAP_TYPE_Plasma__PlayerStats:
		if (p->size < 0)
			delete (Plasma__PlayerStats*)p->ptr;
		else
			delete[] (Plasma__PlayerStats*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__AutohostPlayerJoined:
		if (p->size < 0)
			delete (_Plasma__AutohostPlayerJoined*)p->ptr;
		else
			delete[] (_Plasma__AutohostPlayerJoined*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse:
		if (p->size < 0)
			delete (_Plasma__AutohostPlayerJoinedResponse*)p->ptr;
		else
			delete[] (_Plasma__AutohostPlayerJoinedResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__BalanceTeams:
		if (p->size < 0)
			delete (_Plasma__BalanceTeams*)p->ptr;
		else
			delete[] (_Plasma__BalanceTeams*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__BalanceTeamsResponse:
		if (p->size < 0)
			delete (_Plasma__BalanceTeamsResponse*)p->ptr;
		else
			delete[] (_Plasma__BalanceTeamsResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__DownloadFile:
		if (p->size < 0)
			delete (_Plasma__DownloadFile*)p->ptr;
		else
			delete[] (_Plasma__DownloadFile*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__DownloadFileResponse:
		if (p->size < 0)
			delete (_Plasma__DownloadFileResponse*)p->ptr;
		else
			delete[] (_Plasma__DownloadFileResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloByAccountID:
		if (p->size < 0)
			delete (_Plasma__GetEloByAccountID*)p->ptr;
		else
			delete[] (_Plasma__GetEloByAccountID*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloByAccountIDResponse:
		if (p->size < 0)
			delete (_Plasma__GetEloByAccountIDResponse*)p->ptr;
		else
			delete[] (_Plasma__GetEloByAccountIDResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloByName:
		if (p->size < 0)
			delete (_Plasma__GetEloByName*)p->ptr;
		else
			delete[] (_Plasma__GetEloByName*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloByNameResponse:
		if (p->size < 0)
			delete (_Plasma__GetEloByNameResponse*)p->ptr;
		else
			delete[] (_Plasma__GetEloByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloTop10:
		if (p->size < 0)
			delete (_Plasma__GetEloTop10*)p->ptr;
		else
			delete[] (_Plasma__GetEloTop10*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetEloTop10Response:
		if (p->size < 0)
			delete (_Plasma__GetEloTop10Response*)p->ptr;
		else
			delete[] (_Plasma__GetEloTop10Response*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetRecommendedMap:
		if (p->size < 0)
			delete (_Plasma__GetRecommendedMap*)p->ptr;
		else
			delete[] (_Plasma__GetRecommendedMap*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetRecommendedMapResponse:
		if (p->size < 0)
			delete (_Plasma__GetRecommendedMapResponse*)p->ptr;
		else
			delete[] (_Plasma__GetRecommendedMapResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetResourceData:
		if (p->size < 0)
			delete (_Plasma__GetResourceData*)p->ptr;
		else
			delete[] (_Plasma__GetResourceData*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetResourceDataResponse:
		if (p->size < 0)
			delete (_Plasma__GetResourceDataResponse*)p->ptr;
		else
			delete[] (_Plasma__GetResourceDataResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetResourceList:
		if (p->size < 0)
			delete (_Plasma__GetResourceList*)p->ptr;
		else
			delete[] (_Plasma__GetResourceList*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetResourceListResponse:
		if (p->size < 0)
			delete (_Plasma__GetResourceListResponse*)p->ptr;
		else
			delete[] (_Plasma__GetResourceListResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetScriptMissionData:
		if (p->size < 0)
			delete (_Plasma__GetScriptMissionData*)p->ptr;
		else
			delete[] (_Plasma__GetScriptMissionData*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetScriptMissionDataResponse:
		if (p->size < 0)
			delete (_Plasma__GetScriptMissionDataResponse*)p->ptr;
		else
			delete[] (_Plasma__GetScriptMissionDataResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetup:
		if (p->size < 0)
			delete (_Plasma__GetSpringBattleStartSetup*)p->ptr;
		else
			delete[] (_Plasma__GetSpringBattleStartSetup*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse:
		if (p->size < 0)
			delete (_Plasma__GetSpringBattleStartSetupResponse*)p->ptr;
		else
			delete[] (_Plasma__GetSpringBattleStartSetupResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__NotifyMissionRun:
		if (p->size < 0)
			delete (_Plasma__NotifyMissionRun*)p->ptr;
		else
			delete[] (_Plasma__NotifyMissionRun*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__NotifyMissionRunResponse:
		if (p->size < 0)
			delete (_Plasma__NotifyMissionRunResponse*)p->ptr;
		else
			delete[] (_Plasma__NotifyMissionRunResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__RegisterResource:
		if (p->size < 0)
			delete (_Plasma__RegisterResource*)p->ptr;
		else
			delete[] (_Plasma__RegisterResource*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__RegisterResourceResponse:
		if (p->size < 0)
			delete (_Plasma__RegisterResourceResponse*)p->ptr;
		else
			delete[] (_Plasma__RegisterResourceResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitMissionScore:
		if (p->size < 0)
			delete (_Plasma__SubmitMissionScore*)p->ptr;
		else
			delete[] (_Plasma__SubmitMissionScore*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitMissionScoreResponse:
		if (p->size < 0)
			delete (_Plasma__SubmitMissionScoreResponse*)p->ptr;
		else
			delete[] (_Plasma__SubmitMissionScoreResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitSpringBattleResult:
		if (p->size < 0)
			delete (_Plasma__SubmitSpringBattleResult*)p->ptr;
		else
			delete[] (_Plasma__SubmitSpringBattleResult*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse:
		if (p->size < 0)
			delete (_Plasma__SubmitSpringBattleResultResponse*)p->ptr;
		else
			delete[] (_Plasma__SubmitSpringBattleResultResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitStackTrace:
		if (p->size < 0)
			delete (_Plasma__SubmitStackTrace*)p->ptr;
		else
			delete[] (_Plasma__SubmitStackTrace*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__SubmitStackTraceResponse:
		if (p->size < 0)
			delete (_Plasma__SubmitStackTraceResponse*)p->ptr;
		else
			delete[] (_Plasma__SubmitStackTraceResponse*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__VerifyAccountData:
		if (p->size < 0)
			delete (_Plasma__VerifyAccountData*)p->ptr;
		else
			delete[] (_Plasma__VerifyAccountData*)p->ptr;
		break;
	case SOAP_TYPE__Plasma__VerifyAccountDataResponse:
		if (p->size < 0)
			delete (_Plasma__VerifyAccountDataResponse*)p->ptr;
		else
			delete[] (_Plasma__VerifyAccountDataResponse*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__AutohostPlayerJoined:
		if (p->size < 0)
			delete (struct __Plasma2__AutohostPlayerJoined*)p->ptr;
		else
			delete[] (struct __Plasma2__AutohostPlayerJoined*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__BalanceTeams:
		if (p->size < 0)
			delete (struct __Plasma2__BalanceTeams*)p->ptr;
		else
			delete[] (struct __Plasma2__BalanceTeams*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__DownloadFile:
		if (p->size < 0)
			delete (struct __Plasma2__DownloadFile*)p->ptr;
		else
			delete[] (struct __Plasma2__DownloadFile*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetEloByAccountID:
		if (p->size < 0)
			delete (struct __Plasma2__GetEloByAccountID*)p->ptr;
		else
			delete[] (struct __Plasma2__GetEloByAccountID*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetEloByName:
		if (p->size < 0)
			delete (struct __Plasma2__GetEloByName*)p->ptr;
		else
			delete[] (struct __Plasma2__GetEloByName*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetEloTop10:
		if (p->size < 0)
			delete (struct __Plasma2__GetEloTop10*)p->ptr;
		else
			delete[] (struct __Plasma2__GetEloTop10*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetRecommendedMap:
		if (p->size < 0)
			delete (struct __Plasma2__GetRecommendedMap*)p->ptr;
		else
			delete[] (struct __Plasma2__GetRecommendedMap*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetResourceData:
		if (p->size < 0)
			delete (struct __Plasma2__GetResourceData*)p->ptr;
		else
			delete[] (struct __Plasma2__GetResourceData*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetResourceList:
		if (p->size < 0)
			delete (struct __Plasma2__GetResourceList*)p->ptr;
		else
			delete[] (struct __Plasma2__GetResourceList*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetScriptMissionData:
		if (p->size < 0)
			delete (struct __Plasma2__GetScriptMissionData*)p->ptr;
		else
			delete[] (struct __Plasma2__GetScriptMissionData*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__GetSpringBattleStartSetup:
		if (p->size < 0)
			delete (struct __Plasma2__GetSpringBattleStartSetup*)p->ptr;
		else
			delete[] (struct __Plasma2__GetSpringBattleStartSetup*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__NotifyMissionRun:
		if (p->size < 0)
			delete (struct __Plasma2__NotifyMissionRun*)p->ptr;
		else
			delete[] (struct __Plasma2__NotifyMissionRun*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__RegisterResource:
		if (p->size < 0)
			delete (struct __Plasma2__RegisterResource*)p->ptr;
		else
			delete[] (struct __Plasma2__RegisterResource*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__SubmitMissionScore:
		if (p->size < 0)
			delete (struct __Plasma2__SubmitMissionScore*)p->ptr;
		else
			delete[] (struct __Plasma2__SubmitMissionScore*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__SubmitSpringBattleResult:
		if (p->size < 0)
			delete (struct __Plasma2__SubmitSpringBattleResult*)p->ptr;
		else
			delete[] (struct __Plasma2__SubmitSpringBattleResult*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__SubmitStackTrace:
		if (p->size < 0)
			delete (struct __Plasma2__SubmitStackTrace*)p->ptr;
		else
			delete[] (struct __Plasma2__SubmitStackTrace*)p->ptr;
		break;
	case SOAP_TYPE___Plasma2__VerifyAccountData:
		if (p->size < 0)
			delete (struct __Plasma2__VerifyAccountData*)p->ptr;
		else
			delete[] (struct __Plasma2__VerifyAccountData*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__AutohostPlayerJoined:
		if (p->size < 0)
			delete (struct __Plasma3__AutohostPlayerJoined*)p->ptr;
		else
			delete[] (struct __Plasma3__AutohostPlayerJoined*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__BalanceTeams:
		if (p->size < 0)
			delete (struct __Plasma3__BalanceTeams*)p->ptr;
		else
			delete[] (struct __Plasma3__BalanceTeams*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__DownloadFile:
		if (p->size < 0)
			delete (struct __Plasma3__DownloadFile*)p->ptr;
		else
			delete[] (struct __Plasma3__DownloadFile*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetEloByAccountID:
		if (p->size < 0)
			delete (struct __Plasma3__GetEloByAccountID*)p->ptr;
		else
			delete[] (struct __Plasma3__GetEloByAccountID*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetEloByName:
		if (p->size < 0)
			delete (struct __Plasma3__GetEloByName*)p->ptr;
		else
			delete[] (struct __Plasma3__GetEloByName*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetEloTop10:
		if (p->size < 0)
			delete (struct __Plasma3__GetEloTop10*)p->ptr;
		else
			delete[] (struct __Plasma3__GetEloTop10*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetRecommendedMap:
		if (p->size < 0)
			delete (struct __Plasma3__GetRecommendedMap*)p->ptr;
		else
			delete[] (struct __Plasma3__GetRecommendedMap*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetResourceData:
		if (p->size < 0)
			delete (struct __Plasma3__GetResourceData*)p->ptr;
		else
			delete[] (struct __Plasma3__GetResourceData*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetResourceList:
		if (p->size < 0)
			delete (struct __Plasma3__GetResourceList*)p->ptr;
		else
			delete[] (struct __Plasma3__GetResourceList*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetScriptMissionData:
		if (p->size < 0)
			delete (struct __Plasma3__GetScriptMissionData*)p->ptr;
		else
			delete[] (struct __Plasma3__GetScriptMissionData*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__GetSpringBattleStartSetup:
		if (p->size < 0)
			delete (struct __Plasma3__GetSpringBattleStartSetup*)p->ptr;
		else
			delete[] (struct __Plasma3__GetSpringBattleStartSetup*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__NotifyMissionRun:
		if (p->size < 0)
			delete (struct __Plasma3__NotifyMissionRun*)p->ptr;
		else
			delete[] (struct __Plasma3__NotifyMissionRun*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__RegisterResource:
		if (p->size < 0)
			delete (struct __Plasma3__RegisterResource*)p->ptr;
		else
			delete[] (struct __Plasma3__RegisterResource*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__SubmitMissionScore:
		if (p->size < 0)
			delete (struct __Plasma3__SubmitMissionScore*)p->ptr;
		else
			delete[] (struct __Plasma3__SubmitMissionScore*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__SubmitSpringBattleResult:
		if (p->size < 0)
			delete (struct __Plasma3__SubmitSpringBattleResult*)p->ptr;
		else
			delete[] (struct __Plasma3__SubmitSpringBattleResult*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__SubmitStackTrace:
		if (p->size < 0)
			delete (struct __Plasma3__SubmitStackTrace*)p->ptr;
		else
			delete[] (struct __Plasma3__SubmitStackTrace*)p->ptr;
		break;
	case SOAP_TYPE___Plasma3__VerifyAccountData:
		if (p->size < 0)
			delete (struct __Plasma3__VerifyAccountData*)p->ptr;
		else
			delete[] (struct __Plasma3__VerifyAccountData*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerStats:
		if (p->size < 0)
			delete (std::vector<Plasma__PlayerStats * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__PlayerStats * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerAward:
		if (p->size < 0)
			delete (std::vector<Plasma__PlayerAward * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__PlayerAward * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult:
		if (p->size < 0)
			delete (std::vector<Plasma__BattlePlayerResult * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__BattlePlayerResult * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__UserCustomParameters:
		if (p->size < 0)
			delete (std::vector<Plasma__UserCustomParameters * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__UserCustomParameters * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair:
		if (p->size < 0)
			delete (std::vector<Plasma__ScriptKeyValuePair * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__ScriptKeyValuePair * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer:
		if (p->size < 0)
			delete (std::vector<Plasma__BattleStartSetupPlayer * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__BattleStartSetupPlayer * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ResourceData:
		if (p->size < 0)
			delete (std::vector<Plasma__ResourceData * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__ResourceData * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__SpringHashEntry:
		if (p->size < 0)
			delete (std::vector<Plasma__SpringHashEntry * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__SpringHashEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BotTeam:
		if (p->size < 0)
			delete (std::vector<Plasma__BotTeam * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__BotTeam * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__AccountTeam:
		if (p->size < 0)
			delete (std::vector<Plasma__AccountTeam * >*)p->ptr;
		else
			delete[] (std::vector<Plasma__AccountTeam * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerStats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__PlayerStats * >*)p)[len] = *(Plasma__PlayerStats **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerAward:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__PlayerAward * >*)p)[len] = *(Plasma__PlayerAward **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__BattlePlayerResult * >*)p)[len] = *(Plasma__BattlePlayerResult **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__UserCustomParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__UserCustomParameters * >*)p)[len] = *(Plasma__UserCustomParameters **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__ScriptKeyValuePair * >*)p)[len] = *(Plasma__ScriptKeyValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__BattleStartSetupPlayer * >*)p)[len] = *(Plasma__BattleStartSetupPlayer **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ResourceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__ResourceData * >*)p)[len] = *(Plasma__ResourceData **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__SpringHashEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__SpringHashEntry * >*)p)[len] = *(Plasma__SpringHashEntry **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BotTeam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__BotTeam * >*)p)[len] = *(Plasma__BotTeam **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__AccountTeam:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<Plasma__AccountTeam * >*)p)[len] = *(Plasma__AccountTeam **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Plasma__ProgramType(struct soap *soap, enum Plasma__ProgramType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Plasma__ProgramType
	*a = SOAP_DEFAULT_Plasma__ProgramType;
#else
	*a = (enum Plasma__ProgramType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Plasma__ProgramType(struct soap *soap, const enum Plasma__ProgramType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Plasma__ProgramType);
	if (soap_out_Plasma__ProgramType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_Plasma__ProgramType[] =
{	{ (long)Plasma__ProgramType__MissionEditor, "MissionEditor" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Plasma__ProgramType2s(struct soap *soap, enum Plasma__ProgramType n)
{	const char *s = soap_code_str(soap_codes_Plasma__ProgramType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ProgramType(struct soap *soap, const char *tag, int id, const enum Plasma__ProgramType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ProgramType), type) || soap_send(soap, soap_Plasma__ProgramType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum Plasma__ProgramType * SOAP_FMAC4 soap_get_Plasma__ProgramType(struct soap *soap, enum Plasma__ProgramType *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ProgramType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Plasma__ProgramType(struct soap *soap, const char *s, enum Plasma__ProgramType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_Plasma__ProgramType, s);
	if (map)
		*a = (enum Plasma__ProgramType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum Plasma__ProgramType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Plasma__ProgramType * SOAP_FMAC4 soap_in_Plasma__ProgramType(struct soap *soap, const char *tag, enum Plasma__ProgramType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Plasma__ProgramType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ProgramType, sizeof(enum Plasma__ProgramType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Plasma__ProgramType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Plasma__ProgramType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ProgramType, 0, sizeof(enum Plasma__ProgramType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Plasma__ReturnValue(struct soap *soap, enum Plasma__ReturnValue *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Plasma__ReturnValue
	*a = SOAP_DEFAULT_Plasma__ReturnValue;
#else
	*a = (enum Plasma__ReturnValue)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Plasma__ReturnValue(struct soap *soap, const enum Plasma__ReturnValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Plasma__ReturnValue);
	if (soap_out_Plasma__ReturnValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_Plasma__ReturnValue[] =
{	{ (long)Plasma__ReturnValue__Ok, "Ok" },
	{ (long)Plasma__ReturnValue__InvalidLogin, "InvalidLogin" },
	{ (long)Plasma__ReturnValue__ResourceNotFound, "ResourceNotFound" },
	{ (long)Plasma__ReturnValue__InternalNameAlreadyExistsWithDifferentSpringHash, "InternalNameAlreadyExistsWithDifferentSpringHash" },
	{ (long)Plasma__ReturnValue__Md5AlreadyExists, "Md5AlreadyExists" },
	{ (long)Plasma__ReturnValue__Md5AlreadyExistsWithDifferentName, "Md5AlreadyExistsWithDifferentName" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Plasma__ReturnValue2s(struct soap *soap, enum Plasma__ReturnValue n)
{	const char *s = soap_code_str(soap_codes_Plasma__ReturnValue, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ReturnValue(struct soap *soap, const char *tag, int id, const enum Plasma__ReturnValue *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ReturnValue), type) || soap_send(soap, soap_Plasma__ReturnValue2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum Plasma__ReturnValue * SOAP_FMAC4 soap_get_Plasma__ReturnValue(struct soap *soap, enum Plasma__ReturnValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ReturnValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Plasma__ReturnValue(struct soap *soap, const char *s, enum Plasma__ReturnValue *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_Plasma__ReturnValue, s);
	if (map)
		*a = (enum Plasma__ReturnValue)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum Plasma__ReturnValue)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Plasma__ReturnValue * SOAP_FMAC4 soap_in_Plasma__ReturnValue(struct soap *soap, const char *tag, enum Plasma__ReturnValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Plasma__ReturnValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ReturnValue, sizeof(enum Plasma__ReturnValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Plasma__ReturnValue(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Plasma__ReturnValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ReturnValue, 0, sizeof(enum Plasma__ReturnValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Plasma__AutohostMode(struct soap *soap, enum Plasma__AutohostMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Plasma__AutohostMode
	*a = SOAP_DEFAULT_Plasma__AutohostMode;
#else
	*a = (enum Plasma__AutohostMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Plasma__AutohostMode(struct soap *soap, const enum Plasma__AutohostMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Plasma__AutohostMode);
	if (soap_out_Plasma__AutohostMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_Plasma__AutohostMode[] =
{	{ (long)Plasma__AutohostMode__Planetwars, "Planetwars" },
	{ (long)Plasma__AutohostMode__Game1v1, "Game1v1" },
	{ (long)Plasma__AutohostMode__GameTeams, "GameTeams" },
	{ (long)Plasma__AutohostMode__GameFFA, "GameFFA" },
	{ (long)Plasma__AutohostMode__GameChickens, "GameChickens" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Plasma__AutohostMode2s(struct soap *soap, enum Plasma__AutohostMode n)
{	const char *s = soap_code_str(soap_codes_Plasma__AutohostMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__AutohostMode(struct soap *soap, const char *tag, int id, const enum Plasma__AutohostMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__AutohostMode), type) || soap_send(soap, soap_Plasma__AutohostMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum Plasma__AutohostMode * SOAP_FMAC4 soap_get_Plasma__AutohostMode(struct soap *soap, enum Plasma__AutohostMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__AutohostMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Plasma__AutohostMode(struct soap *soap, const char *s, enum Plasma__AutohostMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_Plasma__AutohostMode, s);
	if (map)
		*a = (enum Plasma__AutohostMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum Plasma__AutohostMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Plasma__AutohostMode * SOAP_FMAC4 soap_in_Plasma__AutohostMode(struct soap *soap, const char *tag, enum Plasma__AutohostMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Plasma__AutohostMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__AutohostMode, sizeof(enum Plasma__AutohostMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Plasma__AutohostMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Plasma__AutohostMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__AutohostMode, 0, sizeof(enum Plasma__AutohostMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Plasma__ResourceType(struct soap *soap, enum Plasma__ResourceType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Plasma__ResourceType
	*a = SOAP_DEFAULT_Plasma__ResourceType;
#else
	*a = (enum Plasma__ResourceType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Plasma__ResourceType(struct soap *soap, const enum Plasma__ResourceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Plasma__ResourceType);
	if (soap_out_Plasma__ResourceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_Plasma__ResourceType[] =
{	{ (long)Plasma__ResourceType__Map, "Map" },
	{ (long)Plasma__ResourceType__Mod, "Mod" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Plasma__ResourceType2s(struct soap *soap, enum Plasma__ResourceType n)
{	const char *s = soap_code_str(soap_codes_Plasma__ResourceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ResourceType(struct soap *soap, const char *tag, int id, const enum Plasma__ResourceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ResourceType), type) || soap_send(soap, soap_Plasma__ResourceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum Plasma__ResourceType * SOAP_FMAC4 soap_get_Plasma__ResourceType(struct soap *soap, enum Plasma__ResourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Plasma__ResourceType(struct soap *soap, const char *s, enum Plasma__ResourceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_Plasma__ResourceType, s);
	if (map)
		*a = (enum Plasma__ResourceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum Plasma__ResourceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Plasma__ResourceType * SOAP_FMAC4 soap_in_Plasma__ResourceType(struct soap *soap, const char *tag, enum Plasma__ResourceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Plasma__ResourceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ResourceType, sizeof(enum Plasma__ResourceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Plasma__ResourceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Plasma__ResourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ResourceType, 0, sizeof(enum Plasma__ResourceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _Plasma__VerifyAccountDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_Plasma__VerifyAccountDataResponse::VerifyAccountDataResult);
	/* transient soap skipped */
}

void _Plasma__VerifyAccountDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__VerifyAccountDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__VerifyAccountDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__VerifyAccountDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__VerifyAccountDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__VerifyAccountDataResponse(struct soap *soap, const char *tag, int id, const _Plasma__VerifyAccountDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__VerifyAccountDataResponse), type))
		return soap->error;
	soap_element_result(soap, "Plasma:VerifyAccountDataResult");
	if (soap_out_bool(soap, "Plasma:VerifyAccountDataResult", -1, &(a->_Plasma__VerifyAccountDataResponse::VerifyAccountDataResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__VerifyAccountDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__VerifyAccountDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountDataResponse * SOAP_FMAC4 soap_get__Plasma__VerifyAccountDataResponse(struct soap *soap, _Plasma__VerifyAccountDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__VerifyAccountDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__VerifyAccountDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__VerifyAccountDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountDataResponse * SOAP_FMAC4 soap_in__Plasma__VerifyAccountDataResponse(struct soap *soap, const char *tag, _Plasma__VerifyAccountDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__VerifyAccountDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__VerifyAccountDataResponse, sizeof(_Plasma__VerifyAccountDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__VerifyAccountDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__VerifyAccountDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_VerifyAccountDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VerifyAccountDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:VerifyAccountDataResult", &(a->_Plasma__VerifyAccountDataResponse::VerifyAccountDataResult), "xsd:boolean"))
				{	soap_flag_VerifyAccountDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:VerifyAccountDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__VerifyAccountDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__VerifyAccountDataResponse, 0, sizeof(_Plasma__VerifyAccountDataResponse), 0, soap_copy__Plasma__VerifyAccountDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VerifyAccountDataResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__VerifyAccountDataResponse * SOAP_FMAC6 soap_new__Plasma__VerifyAccountDataResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__VerifyAccountDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__VerifyAccountDataResponse(struct soap *soap, _Plasma__VerifyAccountDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__VerifyAccountDataResponse * SOAP_FMAC4 soap_instantiate__Plasma__VerifyAccountDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__VerifyAccountDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__VerifyAccountDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__VerifyAccountDataResponse;
		if (size)
			*size = sizeof(_Plasma__VerifyAccountDataResponse);
		((_Plasma__VerifyAccountDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__VerifyAccountDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__VerifyAccountDataResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__VerifyAccountDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__VerifyAccountDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__VerifyAccountDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__VerifyAccountDataResponse %p -> %p\n", q, p));
	*(_Plasma__VerifyAccountDataResponse*)p = *(_Plasma__VerifyAccountDataResponse*)q;
}

void _Plasma__VerifyAccountData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__VerifyAccountData::login = NULL;
	this->_Plasma__VerifyAccountData::password = NULL;
	/* transient soap skipped */
}

void _Plasma__VerifyAccountData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__VerifyAccountData::login);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__VerifyAccountData::password);
	/* transient soap skipped */
}

int _Plasma__VerifyAccountData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__VerifyAccountData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__VerifyAccountData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__VerifyAccountData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__VerifyAccountData(struct soap *soap, const char *tag, int id, const _Plasma__VerifyAccountData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__VerifyAccountData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:login", -1, &(a->_Plasma__VerifyAccountData::login), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:password", -1, &(a->_Plasma__VerifyAccountData::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__VerifyAccountData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__VerifyAccountData(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountData * SOAP_FMAC4 soap_get__Plasma__VerifyAccountData(struct soap *soap, _Plasma__VerifyAccountData *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__VerifyAccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__VerifyAccountData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__VerifyAccountData(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountData * SOAP_FMAC4 soap_in__Plasma__VerifyAccountData(struct soap *soap, const char *tag, _Plasma__VerifyAccountData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__VerifyAccountData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__VerifyAccountData, sizeof(_Plasma__VerifyAccountData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__VerifyAccountData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__VerifyAccountData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_login1 = 1, soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:login", &(a->_Plasma__VerifyAccountData::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:password", &(a->_Plasma__VerifyAccountData::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__VerifyAccountData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__VerifyAccountData, 0, sizeof(_Plasma__VerifyAccountData), 0, soap_copy__Plasma__VerifyAccountData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__VerifyAccountData * SOAP_FMAC6 soap_new__Plasma__VerifyAccountData(struct soap *soap, int n)
{	return soap_instantiate__Plasma__VerifyAccountData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__VerifyAccountData(struct soap *soap, _Plasma__VerifyAccountData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__VerifyAccountData * SOAP_FMAC4 soap_instantiate__Plasma__VerifyAccountData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__VerifyAccountData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__VerifyAccountData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__VerifyAccountData;
		if (size)
			*size = sizeof(_Plasma__VerifyAccountData);
		((_Plasma__VerifyAccountData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__VerifyAccountData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__VerifyAccountData);
		for (int i = 0; i < n; i++)
			((_Plasma__VerifyAccountData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__VerifyAccountData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__VerifyAccountData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__VerifyAccountData %p -> %p\n", q, p));
	*(_Plasma__VerifyAccountData*)p = *(_Plasma__VerifyAccountData*)q;
}

void _Plasma__SubmitStackTraceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Plasma__SubmitStackTraceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__SubmitStackTraceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitStackTraceResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitStackTraceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitStackTraceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitStackTraceResponse(struct soap *soap, const char *tag, int id, const _Plasma__SubmitStackTraceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitStackTraceResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitStackTraceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitStackTraceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTraceResponse * SOAP_FMAC4 soap_get__Plasma__SubmitStackTraceResponse(struct soap *soap, _Plasma__SubmitStackTraceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitStackTraceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitStackTraceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitStackTraceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTraceResponse * SOAP_FMAC4 soap_in__Plasma__SubmitStackTraceResponse(struct soap *soap, const char *tag, _Plasma__SubmitStackTraceResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitStackTraceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitStackTraceResponse, sizeof(_Plasma__SubmitStackTraceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitStackTraceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitStackTraceResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitStackTraceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitStackTraceResponse, 0, sizeof(_Plasma__SubmitStackTraceResponse), 0, soap_copy__Plasma__SubmitStackTraceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitStackTraceResponse * SOAP_FMAC6 soap_new__Plasma__SubmitStackTraceResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitStackTraceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitStackTraceResponse(struct soap *soap, _Plasma__SubmitStackTraceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitStackTraceResponse * SOAP_FMAC4 soap_instantiate__Plasma__SubmitStackTraceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitStackTraceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitStackTraceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitStackTraceResponse;
		if (size)
			*size = sizeof(_Plasma__SubmitStackTraceResponse);
		((_Plasma__SubmitStackTraceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitStackTraceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitStackTraceResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitStackTraceResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitStackTraceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitStackTraceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitStackTraceResponse %p -> %p\n", q, p));
	*(_Plasma__SubmitStackTraceResponse*)p = *(_Plasma__SubmitStackTraceResponse*)q;
}

void _Plasma__SubmitStackTrace::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_Plasma__ProgramType(soap, &this->_Plasma__SubmitStackTrace::programType);
	this->_Plasma__SubmitStackTrace::playerName = NULL;
	this->_Plasma__SubmitStackTrace::exception = NULL;
	this->_Plasma__SubmitStackTrace::extraData = NULL;
	this->_Plasma__SubmitStackTrace::programVersion = NULL;
	/* transient soap skipped */
}

void _Plasma__SubmitStackTrace::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitStackTrace::playerName);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitStackTrace::exception);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitStackTrace::extraData);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitStackTrace::programVersion);
	/* transient soap skipped */
}

int _Plasma__SubmitStackTrace::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitStackTrace);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitStackTrace::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitStackTrace(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitStackTrace(struct soap *soap, const char *tag, int id, const _Plasma__SubmitStackTrace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitStackTrace), type))
		return soap->error;
	if (soap_out_Plasma__ProgramType(soap, "Plasma:programType", -1, &(a->_Plasma__SubmitStackTrace::programType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:playerName", -1, &(a->_Plasma__SubmitStackTrace::playerName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:exception", -1, &(a->_Plasma__SubmitStackTrace::exception), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:extraData", -1, &(a->_Plasma__SubmitStackTrace::extraData), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:programVersion", -1, &(a->_Plasma__SubmitStackTrace::programVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitStackTrace::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitStackTrace(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTrace * SOAP_FMAC4 soap_get__Plasma__SubmitStackTrace(struct soap *soap, _Plasma__SubmitStackTrace *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitStackTrace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitStackTrace::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitStackTrace(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTrace * SOAP_FMAC4 soap_in__Plasma__SubmitStackTrace(struct soap *soap, const char *tag, _Plasma__SubmitStackTrace *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitStackTrace *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitStackTrace, sizeof(_Plasma__SubmitStackTrace), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitStackTrace)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitStackTrace *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_programType1 = 1, soap_flag_playerName1 = 1, soap_flag_exception1 = 1, soap_flag_extraData1 = 1, soap_flag_programVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__ProgramType(soap, "Plasma:programType", &(a->_Plasma__SubmitStackTrace::programType), "Plasma:ProgramType"))
				{	soap_flag_programType1--;
					continue;
				}
			if (soap_flag_playerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:playerName", &(a->_Plasma__SubmitStackTrace::playerName), "xsd:string"))
				{	soap_flag_playerName1--;
					continue;
				}
			if (soap_flag_exception1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:exception", &(a->_Plasma__SubmitStackTrace::exception), "xsd:string"))
				{	soap_flag_exception1--;
					continue;
				}
			if (soap_flag_extraData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:extraData", &(a->_Plasma__SubmitStackTrace::extraData), "xsd:string"))
				{	soap_flag_extraData1--;
					continue;
				}
			if (soap_flag_programVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:programVersion", &(a->_Plasma__SubmitStackTrace::programVersion), "xsd:string"))
				{	soap_flag_programVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitStackTrace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitStackTrace, 0, sizeof(_Plasma__SubmitStackTrace), 0, soap_copy__Plasma__SubmitStackTrace);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_programType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitStackTrace * SOAP_FMAC6 soap_new__Plasma__SubmitStackTrace(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitStackTrace(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitStackTrace(struct soap *soap, _Plasma__SubmitStackTrace *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitStackTrace * SOAP_FMAC4 soap_instantiate__Plasma__SubmitStackTrace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitStackTrace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitStackTrace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitStackTrace;
		if (size)
			*size = sizeof(_Plasma__SubmitStackTrace);
		((_Plasma__SubmitStackTrace*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitStackTrace[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitStackTrace);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitStackTrace*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitStackTrace*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitStackTrace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitStackTrace %p -> %p\n", q, p));
	*(_Plasma__SubmitStackTrace*)p = *(_Plasma__SubmitStackTrace*)q;
}

void _Plasma__SubmitSpringBattleResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__SubmitSpringBattleResultResponse::SubmitSpringBattleResultResult = NULL;
	/* transient soap skipped */
}

void _Plasma__SubmitSpringBattleResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitSpringBattleResultResponse::SubmitSpringBattleResultResult);
	/* transient soap skipped */
}

int _Plasma__SubmitSpringBattleResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitSpringBattleResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitSpringBattleResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, const char *tag, int id, const _Plasma__SubmitSpringBattleResultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse), type))
		return soap->error;
	if (a->SubmitSpringBattleResultResult)
		soap_element_result(soap, "Plasma:SubmitSpringBattleResultResult");
	if (soap_out_PointerTostd__string(soap, "Plasma:SubmitSpringBattleResultResult", -1, &(a->_Plasma__SubmitSpringBattleResultResponse::SubmitSpringBattleResultResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitSpringBattleResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitSpringBattleResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResultResponse * SOAP_FMAC4 soap_get__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, _Plasma__SubmitSpringBattleResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitSpringBattleResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitSpringBattleResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitSpringBattleResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResultResponse * SOAP_FMAC4 soap_in__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, const char *tag, _Plasma__SubmitSpringBattleResultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitSpringBattleResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse, sizeof(_Plasma__SubmitSpringBattleResultResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitSpringBattleResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_SubmitSpringBattleResultResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubmitSpringBattleResultResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:SubmitSpringBattleResultResult", &(a->_Plasma__SubmitSpringBattleResultResponse::SubmitSpringBattleResultResult), "xsd:string"))
				{	soap_flag_SubmitSpringBattleResultResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:SubmitSpringBattleResultResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitSpringBattleResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse, 0, sizeof(_Plasma__SubmitSpringBattleResultResponse), 0, soap_copy__Plasma__SubmitSpringBattleResultResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitSpringBattleResultResponse * SOAP_FMAC6 soap_new__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitSpringBattleResultResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, _Plasma__SubmitSpringBattleResultResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResultResponse * SOAP_FMAC4 soap_instantiate__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitSpringBattleResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitSpringBattleResultResponse;
		if (size)
			*size = sizeof(_Plasma__SubmitSpringBattleResultResponse);
		((_Plasma__SubmitSpringBattleResultResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitSpringBattleResultResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitSpringBattleResultResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitSpringBattleResultResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitSpringBattleResultResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitSpringBattleResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitSpringBattleResultResponse %p -> %p\n", q, p));
	*(_Plasma__SubmitSpringBattleResultResponse*)p = *(_Plasma__SubmitSpringBattleResultResponse*)q;
}

void _Plasma__SubmitSpringBattleResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__SubmitSpringBattleResult::accountName = NULL;
	this->_Plasma__SubmitSpringBattleResult::password = NULL;
	this->_Plasma__SubmitSpringBattleResult::result = NULL;
	this->_Plasma__SubmitSpringBattleResult::players = NULL;
	this->_Plasma__SubmitSpringBattleResult::extraData = NULL;
	/* transient soap skipped */
}

void _Plasma__SubmitSpringBattleResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitSpringBattleResult::accountName);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitSpringBattleResult::password);
	soap_serialize_PointerToPlasma__BattleResult(soap, &this->_Plasma__SubmitSpringBattleResult::result);
	soap_serialize_PointerToPlasma__ArrayOfBattlePlayerResult(soap, &this->_Plasma__SubmitSpringBattleResult::players);
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->_Plasma__SubmitSpringBattleResult::extraData);
	/* transient soap skipped */
}

int _Plasma__SubmitSpringBattleResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitSpringBattleResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitSpringBattleResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitSpringBattleResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitSpringBattleResult(struct soap *soap, const char *tag, int id, const _Plasma__SubmitSpringBattleResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitSpringBattleResult), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:accountName", -1, &(a->_Plasma__SubmitSpringBattleResult::accountName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:password", -1, &(a->_Plasma__SubmitSpringBattleResult::password), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__BattleResult(soap, "Plasma:result", -1, &(a->_Plasma__SubmitSpringBattleResult::result), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfBattlePlayerResult(soap, "Plasma:players", -1, &(a->_Plasma__SubmitSpringBattleResult::players), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:extraData", -1, &(a->_Plasma__SubmitSpringBattleResult::extraData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitSpringBattleResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitSpringBattleResult(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResult * SOAP_FMAC4 soap_get__Plasma__SubmitSpringBattleResult(struct soap *soap, _Plasma__SubmitSpringBattleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitSpringBattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitSpringBattleResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitSpringBattleResult(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResult * SOAP_FMAC4 soap_in__Plasma__SubmitSpringBattleResult(struct soap *soap, const char *tag, _Plasma__SubmitSpringBattleResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitSpringBattleResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitSpringBattleResult, sizeof(_Plasma__SubmitSpringBattleResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitSpringBattleResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitSpringBattleResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountName1 = 1, soap_flag_password1 = 1, soap_flag_result1 = 1, soap_flag_players1 = 1, soap_flag_extraData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:accountName", &(a->_Plasma__SubmitSpringBattleResult::accountName), "xsd:string"))
				{	soap_flag_accountName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:password", &(a->_Plasma__SubmitSpringBattleResult::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__BattleResult(soap, "Plasma:result", &(a->_Plasma__SubmitSpringBattleResult::result), "Plasma:BattleResult"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_players1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfBattlePlayerResult(soap, "Plasma:players", &(a->_Plasma__SubmitSpringBattleResult::players), "Plasma:ArrayOfBattlePlayerResult"))
				{	soap_flag_players1--;
					continue;
				}
			if (soap_flag_extraData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:extraData", &(a->_Plasma__SubmitSpringBattleResult::extraData), "Plasma:ArrayOfString"))
				{	soap_flag_extraData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitSpringBattleResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitSpringBattleResult, 0, sizeof(_Plasma__SubmitSpringBattleResult), 0, soap_copy__Plasma__SubmitSpringBattleResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitSpringBattleResult * SOAP_FMAC6 soap_new__Plasma__SubmitSpringBattleResult(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitSpringBattleResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitSpringBattleResult(struct soap *soap, _Plasma__SubmitSpringBattleResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResult * SOAP_FMAC4 soap_instantiate__Plasma__SubmitSpringBattleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitSpringBattleResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitSpringBattleResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitSpringBattleResult;
		if (size)
			*size = sizeof(_Plasma__SubmitSpringBattleResult);
		((_Plasma__SubmitSpringBattleResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitSpringBattleResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitSpringBattleResult);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitSpringBattleResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitSpringBattleResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitSpringBattleResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitSpringBattleResult %p -> %p\n", q, p));
	*(_Plasma__SubmitSpringBattleResult*)p = *(_Plasma__SubmitSpringBattleResult*)q;
}

void _Plasma__SubmitMissionScoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Plasma__SubmitMissionScoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__SubmitMissionScoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitMissionScoreResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitMissionScoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitMissionScoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitMissionScoreResponse(struct soap *soap, const char *tag, int id, const _Plasma__SubmitMissionScoreResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitMissionScoreResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitMissionScoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitMissionScoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScoreResponse * SOAP_FMAC4 soap_get__Plasma__SubmitMissionScoreResponse(struct soap *soap, _Plasma__SubmitMissionScoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitMissionScoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitMissionScoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitMissionScoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScoreResponse * SOAP_FMAC4 soap_in__Plasma__SubmitMissionScoreResponse(struct soap *soap, const char *tag, _Plasma__SubmitMissionScoreResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitMissionScoreResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitMissionScoreResponse, sizeof(_Plasma__SubmitMissionScoreResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitMissionScoreResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitMissionScoreResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitMissionScoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitMissionScoreResponse, 0, sizeof(_Plasma__SubmitMissionScoreResponse), 0, soap_copy__Plasma__SubmitMissionScoreResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitMissionScoreResponse * SOAP_FMAC6 soap_new__Plasma__SubmitMissionScoreResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitMissionScoreResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitMissionScoreResponse(struct soap *soap, _Plasma__SubmitMissionScoreResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitMissionScoreResponse * SOAP_FMAC4 soap_instantiate__Plasma__SubmitMissionScoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitMissionScoreResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitMissionScoreResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitMissionScoreResponse;
		if (size)
			*size = sizeof(_Plasma__SubmitMissionScoreResponse);
		((_Plasma__SubmitMissionScoreResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitMissionScoreResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitMissionScoreResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitMissionScoreResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitMissionScoreResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitMissionScoreResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitMissionScoreResponse %p -> %p\n", q, p));
	*(_Plasma__SubmitMissionScoreResponse*)p = *(_Plasma__SubmitMissionScoreResponse*)q;
}

void _Plasma__SubmitMissionScore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__SubmitMissionScore::login = NULL;
	this->_Plasma__SubmitMissionScore::passwordHash = NULL;
	this->_Plasma__SubmitMissionScore::missionName = NULL;
	soap_default_int(soap, &this->_Plasma__SubmitMissionScore::score);
	soap_default_int(soap, &this->_Plasma__SubmitMissionScore::gameSeconds);
	/* transient soap skipped */
}

void _Plasma__SubmitMissionScore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitMissionScore::login);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitMissionScore::passwordHash);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__SubmitMissionScore::missionName);
	soap_embedded(soap, &this->_Plasma__SubmitMissionScore::score, SOAP_TYPE_int);
	soap_embedded(soap, &this->_Plasma__SubmitMissionScore::gameSeconds, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _Plasma__SubmitMissionScore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__SubmitMissionScore);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__SubmitMissionScore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__SubmitMissionScore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__SubmitMissionScore(struct soap *soap, const char *tag, int id, const _Plasma__SubmitMissionScore *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__SubmitMissionScore), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:login", -1, &(a->_Plasma__SubmitMissionScore::login), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:passwordHash", -1, &(a->_Plasma__SubmitMissionScore::passwordHash), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:missionName", -1, &(a->_Plasma__SubmitMissionScore::missionName), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:score", -1, &(a->_Plasma__SubmitMissionScore::score), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:gameSeconds", -1, &(a->_Plasma__SubmitMissionScore::gameSeconds), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__SubmitMissionScore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__SubmitMissionScore(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScore * SOAP_FMAC4 soap_get__Plasma__SubmitMissionScore(struct soap *soap, _Plasma__SubmitMissionScore *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__SubmitMissionScore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__SubmitMissionScore::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__SubmitMissionScore(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScore * SOAP_FMAC4 soap_in__Plasma__SubmitMissionScore(struct soap *soap, const char *tag, _Plasma__SubmitMissionScore *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__SubmitMissionScore *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__SubmitMissionScore, sizeof(_Plasma__SubmitMissionScore), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__SubmitMissionScore)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__SubmitMissionScore *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_login1 = 1, soap_flag_passwordHash1 = 1, soap_flag_missionName1 = 1, soap_flag_score1 = 1, soap_flag_gameSeconds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:login", &(a->_Plasma__SubmitMissionScore::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag_passwordHash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:passwordHash", &(a->_Plasma__SubmitMissionScore::passwordHash), "xsd:string"))
				{	soap_flag_passwordHash1--;
					continue;
				}
			if (soap_flag_missionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:missionName", &(a->_Plasma__SubmitMissionScore::missionName), "xsd:string"))
				{	soap_flag_missionName1--;
					continue;
				}
			if (soap_flag_score1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:score", &(a->_Plasma__SubmitMissionScore::score), "xsd:int"))
				{	soap_flag_score1--;
					continue;
				}
			if (soap_flag_gameSeconds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:gameSeconds", &(a->_Plasma__SubmitMissionScore::gameSeconds), "xsd:int"))
				{	soap_flag_gameSeconds1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__SubmitMissionScore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__SubmitMissionScore, 0, sizeof(_Plasma__SubmitMissionScore), 0, soap_copy__Plasma__SubmitMissionScore);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_score1 > 0 || soap_flag_gameSeconds1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__SubmitMissionScore * SOAP_FMAC6 soap_new__Plasma__SubmitMissionScore(struct soap *soap, int n)
{	return soap_instantiate__Plasma__SubmitMissionScore(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__SubmitMissionScore(struct soap *soap, _Plasma__SubmitMissionScore *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__SubmitMissionScore * SOAP_FMAC4 soap_instantiate__Plasma__SubmitMissionScore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__SubmitMissionScore(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__SubmitMissionScore, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__SubmitMissionScore;
		if (size)
			*size = sizeof(_Plasma__SubmitMissionScore);
		((_Plasma__SubmitMissionScore*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__SubmitMissionScore[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__SubmitMissionScore);
		for (int i = 0; i < n; i++)
			((_Plasma__SubmitMissionScore*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__SubmitMissionScore*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__SubmitMissionScore(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__SubmitMissionScore %p -> %p\n", q, p));
	*(_Plasma__SubmitMissionScore*)p = *(_Plasma__SubmitMissionScore*)q;
}

void _Plasma__RegisterResourceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_Plasma__ReturnValue(soap, &this->_Plasma__RegisterResourceResponse::RegisterResourceResult);
	/* transient soap skipped */
}

void _Plasma__RegisterResourceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__RegisterResourceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__RegisterResourceResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__RegisterResourceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__RegisterResourceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__RegisterResourceResponse(struct soap *soap, const char *tag, int id, const _Plasma__RegisterResourceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__RegisterResourceResponse), type))
		return soap->error;
	soap_element_result(soap, "Plasma:RegisterResourceResult");
	if (soap_out_Plasma__ReturnValue(soap, "Plasma:RegisterResourceResult", -1, &(a->_Plasma__RegisterResourceResponse::RegisterResourceResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__RegisterResourceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__RegisterResourceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__RegisterResourceResponse * SOAP_FMAC4 soap_get__Plasma__RegisterResourceResponse(struct soap *soap, _Plasma__RegisterResourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__RegisterResourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__RegisterResourceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__RegisterResourceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__RegisterResourceResponse * SOAP_FMAC4 soap_in__Plasma__RegisterResourceResponse(struct soap *soap, const char *tag, _Plasma__RegisterResourceResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__RegisterResourceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__RegisterResourceResponse, sizeof(_Plasma__RegisterResourceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__RegisterResourceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__RegisterResourceResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_RegisterResourceResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RegisterResourceResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__ReturnValue(soap, "Plasma:RegisterResourceResult", &(a->_Plasma__RegisterResourceResponse::RegisterResourceResult), "Plasma:ReturnValue"))
				{	soap_flag_RegisterResourceResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:RegisterResourceResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__RegisterResourceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__RegisterResourceResponse, 0, sizeof(_Plasma__RegisterResourceResponse), 0, soap_copy__Plasma__RegisterResourceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RegisterResourceResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__RegisterResourceResponse * SOAP_FMAC6 soap_new__Plasma__RegisterResourceResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__RegisterResourceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__RegisterResourceResponse(struct soap *soap, _Plasma__RegisterResourceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__RegisterResourceResponse * SOAP_FMAC4 soap_instantiate__Plasma__RegisterResourceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__RegisterResourceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__RegisterResourceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__RegisterResourceResponse;
		if (size)
			*size = sizeof(_Plasma__RegisterResourceResponse);
		((_Plasma__RegisterResourceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__RegisterResourceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__RegisterResourceResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__RegisterResourceResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__RegisterResourceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__RegisterResourceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__RegisterResourceResponse %p -> %p\n", q, p));
	*(_Plasma__RegisterResourceResponse*)p = *(_Plasma__RegisterResourceResponse*)q;
}

void _Plasma__RegisterResource::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Plasma__RegisterResource::apiVersion);
	this->_Plasma__RegisterResource::springVersion = NULL;
	this->_Plasma__RegisterResource::md5 = NULL;
	soap_default_int(soap, &this->_Plasma__RegisterResource::length);
	soap_default_Plasma__ResourceType(soap, &this->_Plasma__RegisterResource::resourceType);
	this->_Plasma__RegisterResource::archiveName = NULL;
	this->_Plasma__RegisterResource::internalName = NULL;
	soap_default_int(soap, &this->_Plasma__RegisterResource::springHash);
	this->_Plasma__RegisterResource::serializedData = NULL;
	this->_Plasma__RegisterResource::dependencies = NULL;
	this->_Plasma__RegisterResource::minimap = NULL;
	this->_Plasma__RegisterResource::metalMap = NULL;
	this->_Plasma__RegisterResource::heightMap = NULL;
	this->_Plasma__RegisterResource::torrentData = NULL;
	/* transient soap skipped */
}

void _Plasma__RegisterResource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_Plasma__RegisterResource::apiVersion, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__RegisterResource::springVersion);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__RegisterResource::md5);
	soap_embedded(soap, &this->_Plasma__RegisterResource::length, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__RegisterResource::archiveName);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__RegisterResource::internalName);
	soap_embedded(soap, &this->_Plasma__RegisterResource::springHash, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__RegisterResource::serializedData);
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->_Plasma__RegisterResource::dependencies);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__RegisterResource::minimap);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__RegisterResource::metalMap);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__RegisterResource::heightMap);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__RegisterResource::torrentData);
	/* transient soap skipped */
}

int _Plasma__RegisterResource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__RegisterResource);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__RegisterResource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__RegisterResource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__RegisterResource(struct soap *soap, const char *tag, int id, const _Plasma__RegisterResource *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__RegisterResource), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:apiVersion", -1, &(a->_Plasma__RegisterResource::apiVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:springVersion", -1, &(a->_Plasma__RegisterResource::springVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:md5", -1, &(a->_Plasma__RegisterResource::md5), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:length", -1, &(a->_Plasma__RegisterResource::length), ""))
		return soap->error;
	if (soap_out_Plasma__ResourceType(soap, "Plasma:resourceType", -1, &(a->_Plasma__RegisterResource::resourceType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:archiveName", -1, &(a->_Plasma__RegisterResource::archiveName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:internalName", -1, &(a->_Plasma__RegisterResource::internalName), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:springHash", -1, &(a->_Plasma__RegisterResource::springHash), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:serializedData", -1, &(a->_Plasma__RegisterResource::serializedData), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:dependencies", -1, &(a->_Plasma__RegisterResource::dependencies), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:minimap", -1, &(a->_Plasma__RegisterResource::minimap), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:metalMap", -1, &(a->_Plasma__RegisterResource::metalMap), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:heightMap", -1, &(a->_Plasma__RegisterResource::heightMap), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:torrentData", -1, &(a->_Plasma__RegisterResource::torrentData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__RegisterResource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__RegisterResource(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__RegisterResource * SOAP_FMAC4 soap_get__Plasma__RegisterResource(struct soap *soap, _Plasma__RegisterResource *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__RegisterResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__RegisterResource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__RegisterResource(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__RegisterResource * SOAP_FMAC4 soap_in__Plasma__RegisterResource(struct soap *soap, const char *tag, _Plasma__RegisterResource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__RegisterResource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__RegisterResource, sizeof(_Plasma__RegisterResource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__RegisterResource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__RegisterResource *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_apiVersion1 = 1, soap_flag_springVersion1 = 1, soap_flag_md51 = 1, soap_flag_length1 = 1, soap_flag_resourceType1 = 1, soap_flag_archiveName1 = 1, soap_flag_internalName1 = 1, soap_flag_springHash1 = 1, soap_flag_serializedData1 = 1, soap_flag_dependencies1 = 1, soap_flag_minimap1 = 1, soap_flag_metalMap1 = 1, soap_flag_heightMap1 = 1, soap_flag_torrentData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_apiVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:apiVersion", &(a->_Plasma__RegisterResource::apiVersion), "xsd:int"))
				{	soap_flag_apiVersion1--;
					continue;
				}
			if (soap_flag_springVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:springVersion", &(a->_Plasma__RegisterResource::springVersion), "xsd:string"))
				{	soap_flag_springVersion1--;
					continue;
				}
			if (soap_flag_md51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:md5", &(a->_Plasma__RegisterResource::md5), "xsd:string"))
				{	soap_flag_md51--;
					continue;
				}
			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:length", &(a->_Plasma__RegisterResource::length), "xsd:int"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_resourceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__ResourceType(soap, "Plasma:resourceType", &(a->_Plasma__RegisterResource::resourceType), "Plasma:ResourceType"))
				{	soap_flag_resourceType1--;
					continue;
				}
			if (soap_flag_archiveName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:archiveName", &(a->_Plasma__RegisterResource::archiveName), "xsd:string"))
				{	soap_flag_archiveName1--;
					continue;
				}
			if (soap_flag_internalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:internalName", &(a->_Plasma__RegisterResource::internalName), "xsd:string"))
				{	soap_flag_internalName1--;
					continue;
				}
			if (soap_flag_springHash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:springHash", &(a->_Plasma__RegisterResource::springHash), "xsd:int"))
				{	soap_flag_springHash1--;
					continue;
				}
			if (soap_flag_serializedData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:serializedData", &(a->_Plasma__RegisterResource::serializedData), "xsd:base64Binary"))
				{	soap_flag_serializedData1--;
					continue;
				}
			if (soap_flag_dependencies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:dependencies", &(a->_Plasma__RegisterResource::dependencies), "Plasma:ArrayOfString"))
				{	soap_flag_dependencies1--;
					continue;
				}
			if (soap_flag_minimap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:minimap", &(a->_Plasma__RegisterResource::minimap), "xsd:base64Binary"))
				{	soap_flag_minimap1--;
					continue;
				}
			if (soap_flag_metalMap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:metalMap", &(a->_Plasma__RegisterResource::metalMap), "xsd:base64Binary"))
				{	soap_flag_metalMap1--;
					continue;
				}
			if (soap_flag_heightMap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:heightMap", &(a->_Plasma__RegisterResource::heightMap), "xsd:base64Binary"))
				{	soap_flag_heightMap1--;
					continue;
				}
			if (soap_flag_torrentData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:torrentData", &(a->_Plasma__RegisterResource::torrentData), "xsd:base64Binary"))
				{	soap_flag_torrentData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__RegisterResource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__RegisterResource, 0, sizeof(_Plasma__RegisterResource), 0, soap_copy__Plasma__RegisterResource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiVersion1 > 0 || soap_flag_length1 > 0 || soap_flag_resourceType1 > 0 || soap_flag_springHash1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__RegisterResource * SOAP_FMAC6 soap_new__Plasma__RegisterResource(struct soap *soap, int n)
{	return soap_instantiate__Plasma__RegisterResource(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__RegisterResource(struct soap *soap, _Plasma__RegisterResource *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__RegisterResource * SOAP_FMAC4 soap_instantiate__Plasma__RegisterResource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__RegisterResource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__RegisterResource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__RegisterResource;
		if (size)
			*size = sizeof(_Plasma__RegisterResource);
		((_Plasma__RegisterResource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__RegisterResource[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__RegisterResource);
		for (int i = 0; i < n; i++)
			((_Plasma__RegisterResource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__RegisterResource*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__RegisterResource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__RegisterResource %p -> %p\n", q, p));
	*(_Plasma__RegisterResource*)p = *(_Plasma__RegisterResource*)q;
}

void _Plasma__NotifyMissionRunResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Plasma__NotifyMissionRunResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__NotifyMissionRunResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__NotifyMissionRunResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__NotifyMissionRunResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__NotifyMissionRunResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__NotifyMissionRunResponse(struct soap *soap, const char *tag, int id, const _Plasma__NotifyMissionRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__NotifyMissionRunResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__NotifyMissionRunResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__NotifyMissionRunResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRunResponse * SOAP_FMAC4 soap_get__Plasma__NotifyMissionRunResponse(struct soap *soap, _Plasma__NotifyMissionRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__NotifyMissionRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__NotifyMissionRunResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__NotifyMissionRunResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRunResponse * SOAP_FMAC4 soap_in__Plasma__NotifyMissionRunResponse(struct soap *soap, const char *tag, _Plasma__NotifyMissionRunResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__NotifyMissionRunResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__NotifyMissionRunResponse, sizeof(_Plasma__NotifyMissionRunResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__NotifyMissionRunResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__NotifyMissionRunResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__NotifyMissionRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__NotifyMissionRunResponse, 0, sizeof(_Plasma__NotifyMissionRunResponse), 0, soap_copy__Plasma__NotifyMissionRunResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__NotifyMissionRunResponse * SOAP_FMAC6 soap_new__Plasma__NotifyMissionRunResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__NotifyMissionRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__NotifyMissionRunResponse(struct soap *soap, _Plasma__NotifyMissionRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__NotifyMissionRunResponse * SOAP_FMAC4 soap_instantiate__Plasma__NotifyMissionRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__NotifyMissionRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__NotifyMissionRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__NotifyMissionRunResponse;
		if (size)
			*size = sizeof(_Plasma__NotifyMissionRunResponse);
		((_Plasma__NotifyMissionRunResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__NotifyMissionRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__NotifyMissionRunResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__NotifyMissionRunResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__NotifyMissionRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__NotifyMissionRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__NotifyMissionRunResponse %p -> %p\n", q, p));
	*(_Plasma__NotifyMissionRunResponse*)p = *(_Plasma__NotifyMissionRunResponse*)q;
}

void _Plasma__NotifyMissionRun::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__NotifyMissionRun::login = NULL;
	this->_Plasma__NotifyMissionRun::missionName = NULL;
	/* transient soap skipped */
}

void _Plasma__NotifyMissionRun::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__NotifyMissionRun::login);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__NotifyMissionRun::missionName);
	/* transient soap skipped */
}

int _Plasma__NotifyMissionRun::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__NotifyMissionRun);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__NotifyMissionRun::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__NotifyMissionRun(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__NotifyMissionRun(struct soap *soap, const char *tag, int id, const _Plasma__NotifyMissionRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__NotifyMissionRun), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:login", -1, &(a->_Plasma__NotifyMissionRun::login), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:missionName", -1, &(a->_Plasma__NotifyMissionRun::missionName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__NotifyMissionRun::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__NotifyMissionRun(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRun * SOAP_FMAC4 soap_get__Plasma__NotifyMissionRun(struct soap *soap, _Plasma__NotifyMissionRun *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__NotifyMissionRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__NotifyMissionRun::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__NotifyMissionRun(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRun * SOAP_FMAC4 soap_in__Plasma__NotifyMissionRun(struct soap *soap, const char *tag, _Plasma__NotifyMissionRun *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__NotifyMissionRun *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__NotifyMissionRun, sizeof(_Plasma__NotifyMissionRun), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__NotifyMissionRun)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__NotifyMissionRun *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_login1 = 1, soap_flag_missionName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:login", &(a->_Plasma__NotifyMissionRun::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag_missionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:missionName", &(a->_Plasma__NotifyMissionRun::missionName), "xsd:string"))
				{	soap_flag_missionName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__NotifyMissionRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__NotifyMissionRun, 0, sizeof(_Plasma__NotifyMissionRun), 0, soap_copy__Plasma__NotifyMissionRun);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__NotifyMissionRun * SOAP_FMAC6 soap_new__Plasma__NotifyMissionRun(struct soap *soap, int n)
{	return soap_instantiate__Plasma__NotifyMissionRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__NotifyMissionRun(struct soap *soap, _Plasma__NotifyMissionRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__NotifyMissionRun * SOAP_FMAC4 soap_instantiate__Plasma__NotifyMissionRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__NotifyMissionRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__NotifyMissionRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__NotifyMissionRun;
		if (size)
			*size = sizeof(_Plasma__NotifyMissionRun);
		((_Plasma__NotifyMissionRun*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__NotifyMissionRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__NotifyMissionRun);
		for (int i = 0; i < n; i++)
			((_Plasma__NotifyMissionRun*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__NotifyMissionRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__NotifyMissionRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__NotifyMissionRun %p -> %p\n", q, p));
	*(_Plasma__NotifyMissionRun*)p = *(_Plasma__NotifyMissionRun*)q;
}

void _Plasma__GetSpringBattleStartSetupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetSpringBattleStartSetupResponse::GetSpringBattleStartSetupResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetSpringBattleStartSetupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__SpringBattleStartSetup(soap, &this->_Plasma__GetSpringBattleStartSetupResponse::GetSpringBattleStartSetupResult);
	/* transient soap skipped */
}

int _Plasma__GetSpringBattleStartSetupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetSpringBattleStartSetupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetSpringBattleStartSetupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetSpringBattleStartSetupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse), type))
		return soap->error;
	if (a->GetSpringBattleStartSetupResult)
		soap_element_result(soap, "Plasma:GetSpringBattleStartSetupResult");
	if (soap_out_PointerToPlasma__SpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetupResult", -1, &(a->_Plasma__GetSpringBattleStartSetupResponse::GetSpringBattleStartSetupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetSpringBattleStartSetupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetSpringBattleStartSetupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetupResponse * SOAP_FMAC4 soap_get__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, _Plasma__GetSpringBattleStartSetupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetSpringBattleStartSetupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetSpringBattleStartSetupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetSpringBattleStartSetupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetupResponse * SOAP_FMAC4 soap_in__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, const char *tag, _Plasma__GetSpringBattleStartSetupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetSpringBattleStartSetupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse, sizeof(_Plasma__GetSpringBattleStartSetupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetSpringBattleStartSetupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetSpringBattleStartSetupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSpringBattleStartSetupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__SpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetupResult", &(a->_Plasma__GetSpringBattleStartSetupResponse::GetSpringBattleStartSetupResult), "Plasma:SpringBattleStartSetup"))
				{	soap_flag_GetSpringBattleStartSetupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetSpringBattleStartSetupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetSpringBattleStartSetupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse, 0, sizeof(_Plasma__GetSpringBattleStartSetupResponse), 0, soap_copy__Plasma__GetSpringBattleStartSetupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetSpringBattleStartSetupResponse * SOAP_FMAC6 soap_new__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetSpringBattleStartSetupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, _Plasma__GetSpringBattleStartSetupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetupResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetSpringBattleStartSetupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetSpringBattleStartSetupResponse;
		if (size)
			*size = sizeof(_Plasma__GetSpringBattleStartSetupResponse);
		((_Plasma__GetSpringBattleStartSetupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetSpringBattleStartSetupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetSpringBattleStartSetupResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetSpringBattleStartSetupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetSpringBattleStartSetupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetSpringBattleStartSetupResponse %p -> %p\n", q, p));
	*(_Plasma__GetSpringBattleStartSetupResponse*)p = *(_Plasma__GetSpringBattleStartSetupResponse*)q;
}

void _Plasma__GetSpringBattleStartSetup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetSpringBattleStartSetup::hostName = NULL;
	this->_Plasma__GetSpringBattleStartSetup::map = NULL;
	this->_Plasma__GetSpringBattleStartSetup::mod = NULL;
	this->_Plasma__GetSpringBattleStartSetup::players = NULL;
	soap_default_Plasma__AutohostMode(soap, &this->_Plasma__GetSpringBattleStartSetup::mode);
	/* transient soap skipped */
}

void _Plasma__GetSpringBattleStartSetup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetSpringBattleStartSetup::hostName);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetSpringBattleStartSetup::map);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetSpringBattleStartSetup::mod);
	soap_serialize_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, &this->_Plasma__GetSpringBattleStartSetup::players);
	/* transient soap skipped */
}

int _Plasma__GetSpringBattleStartSetup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetSpringBattleStartSetup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetSpringBattleStartSetup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetSpringBattleStartSetup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetSpringBattleStartSetup(struct soap *soap, const char *tag, int id, const _Plasma__GetSpringBattleStartSetup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetSpringBattleStartSetup), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:hostName", -1, &(a->_Plasma__GetSpringBattleStartSetup::hostName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:map", -1, &(a->_Plasma__GetSpringBattleStartSetup::map), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:mod", -1, &(a->_Plasma__GetSpringBattleStartSetup::mod), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, "Plasma:players", -1, &(a->_Plasma__GetSpringBattleStartSetup::players), ""))
		return soap->error;
	if (soap_out_Plasma__AutohostMode(soap, "Plasma:mode", -1, &(a->_Plasma__GetSpringBattleStartSetup::mode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetSpringBattleStartSetup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetSpringBattleStartSetup(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetup * SOAP_FMAC4 soap_get__Plasma__GetSpringBattleStartSetup(struct soap *soap, _Plasma__GetSpringBattleStartSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetSpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetSpringBattleStartSetup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetSpringBattleStartSetup(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetup * SOAP_FMAC4 soap_in__Plasma__GetSpringBattleStartSetup(struct soap *soap, const char *tag, _Plasma__GetSpringBattleStartSetup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetSpringBattleStartSetup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetSpringBattleStartSetup, sizeof(_Plasma__GetSpringBattleStartSetup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetSpringBattleStartSetup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetSpringBattleStartSetup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hostName1 = 1, soap_flag_map1 = 1, soap_flag_mod1 = 1, soap_flag_players1 = 1, soap_flag_mode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hostName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:hostName", &(a->_Plasma__GetSpringBattleStartSetup::hostName), "xsd:string"))
				{	soap_flag_hostName1--;
					continue;
				}
			if (soap_flag_map1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:map", &(a->_Plasma__GetSpringBattleStartSetup::map), "xsd:string"))
				{	soap_flag_map1--;
					continue;
				}
			if (soap_flag_mod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:mod", &(a->_Plasma__GetSpringBattleStartSetup::mod), "xsd:string"))
				{	soap_flag_mod1--;
					continue;
				}
			if (soap_flag_players1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, "Plasma:players", &(a->_Plasma__GetSpringBattleStartSetup::players), "Plasma:ArrayOfBattleStartSetupPlayer"))
				{	soap_flag_players1--;
					continue;
				}
			if (soap_flag_mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__AutohostMode(soap, "Plasma:mode", &(a->_Plasma__GetSpringBattleStartSetup::mode), "Plasma:AutohostMode"))
				{	soap_flag_mode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetSpringBattleStartSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetSpringBattleStartSetup, 0, sizeof(_Plasma__GetSpringBattleStartSetup), 0, soap_copy__Plasma__GetSpringBattleStartSetup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetSpringBattleStartSetup * SOAP_FMAC6 soap_new__Plasma__GetSpringBattleStartSetup(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetSpringBattleStartSetup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetSpringBattleStartSetup(struct soap *soap, _Plasma__GetSpringBattleStartSetup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetup * SOAP_FMAC4 soap_instantiate__Plasma__GetSpringBattleStartSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetSpringBattleStartSetup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetSpringBattleStartSetup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetSpringBattleStartSetup;
		if (size)
			*size = sizeof(_Plasma__GetSpringBattleStartSetup);
		((_Plasma__GetSpringBattleStartSetup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetSpringBattleStartSetup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetSpringBattleStartSetup);
		for (int i = 0; i < n; i++)
			((_Plasma__GetSpringBattleStartSetup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetSpringBattleStartSetup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetSpringBattleStartSetup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetSpringBattleStartSetup %p -> %p\n", q, p));
	*(_Plasma__GetSpringBattleStartSetup*)p = *(_Plasma__GetSpringBattleStartSetup*)q;
}

void _Plasma__GetScriptMissionDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetScriptMissionDataResponse::GetScriptMissionDataResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetScriptMissionDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ScriptMissionData(soap, &this->_Plasma__GetScriptMissionDataResponse::GetScriptMissionDataResult);
	/* transient soap skipped */
}

int _Plasma__GetScriptMissionDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetScriptMissionDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetScriptMissionDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetScriptMissionDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetScriptMissionDataResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetScriptMissionDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetScriptMissionDataResponse), type))
		return soap->error;
	if (a->GetScriptMissionDataResult)
		soap_element_result(soap, "Plasma:GetScriptMissionDataResult");
	if (soap_out_PointerToPlasma__ScriptMissionData(soap, "Plasma:GetScriptMissionDataResult", -1, &(a->_Plasma__GetScriptMissionDataResponse::GetScriptMissionDataResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetScriptMissionDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetScriptMissionDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionDataResponse * SOAP_FMAC4 soap_get__Plasma__GetScriptMissionDataResponse(struct soap *soap, _Plasma__GetScriptMissionDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetScriptMissionDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetScriptMissionDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetScriptMissionDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionDataResponse * SOAP_FMAC4 soap_in__Plasma__GetScriptMissionDataResponse(struct soap *soap, const char *tag, _Plasma__GetScriptMissionDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetScriptMissionDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetScriptMissionDataResponse, sizeof(_Plasma__GetScriptMissionDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetScriptMissionDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetScriptMissionDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetScriptMissionDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetScriptMissionDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ScriptMissionData(soap, "Plasma:GetScriptMissionDataResult", &(a->_Plasma__GetScriptMissionDataResponse::GetScriptMissionDataResult), "Plasma:ScriptMissionData"))
				{	soap_flag_GetScriptMissionDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetScriptMissionDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetScriptMissionDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetScriptMissionDataResponse, 0, sizeof(_Plasma__GetScriptMissionDataResponse), 0, soap_copy__Plasma__GetScriptMissionDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetScriptMissionDataResponse * SOAP_FMAC6 soap_new__Plasma__GetScriptMissionDataResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetScriptMissionDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetScriptMissionDataResponse(struct soap *soap, _Plasma__GetScriptMissionDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetScriptMissionDataResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetScriptMissionDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetScriptMissionDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetScriptMissionDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetScriptMissionDataResponse;
		if (size)
			*size = sizeof(_Plasma__GetScriptMissionDataResponse);
		((_Plasma__GetScriptMissionDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetScriptMissionDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetScriptMissionDataResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetScriptMissionDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetScriptMissionDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetScriptMissionDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetScriptMissionDataResponse %p -> %p\n", q, p));
	*(_Plasma__GetScriptMissionDataResponse*)p = *(_Plasma__GetScriptMissionDataResponse*)q;
}

void _Plasma__GetScriptMissionData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetScriptMissionData::name = NULL;
	/* transient soap skipped */
}

void _Plasma__GetScriptMissionData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetScriptMissionData::name);
	/* transient soap skipped */
}

int _Plasma__GetScriptMissionData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetScriptMissionData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetScriptMissionData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetScriptMissionData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetScriptMissionData(struct soap *soap, const char *tag, int id, const _Plasma__GetScriptMissionData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetScriptMissionData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:name", -1, &(a->_Plasma__GetScriptMissionData::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetScriptMissionData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetScriptMissionData(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionData * SOAP_FMAC4 soap_get__Plasma__GetScriptMissionData(struct soap *soap, _Plasma__GetScriptMissionData *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetScriptMissionData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetScriptMissionData(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionData * SOAP_FMAC4 soap_in__Plasma__GetScriptMissionData(struct soap *soap, const char *tag, _Plasma__GetScriptMissionData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetScriptMissionData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetScriptMissionData, sizeof(_Plasma__GetScriptMissionData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetScriptMissionData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetScriptMissionData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:name", &(a->_Plasma__GetScriptMissionData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetScriptMissionData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetScriptMissionData, 0, sizeof(_Plasma__GetScriptMissionData), 0, soap_copy__Plasma__GetScriptMissionData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetScriptMissionData * SOAP_FMAC6 soap_new__Plasma__GetScriptMissionData(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetScriptMissionData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetScriptMissionData(struct soap *soap, _Plasma__GetScriptMissionData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetScriptMissionData * SOAP_FMAC4 soap_instantiate__Plasma__GetScriptMissionData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetScriptMissionData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetScriptMissionData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetScriptMissionData;
		if (size)
			*size = sizeof(_Plasma__GetScriptMissionData);
		((_Plasma__GetScriptMissionData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetScriptMissionData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetScriptMissionData);
		for (int i = 0; i < n; i++)
			((_Plasma__GetScriptMissionData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetScriptMissionData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetScriptMissionData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetScriptMissionData %p -> %p\n", q, p));
	*(_Plasma__GetScriptMissionData*)p = *(_Plasma__GetScriptMissionData*)q;
}

void _Plasma__GetResourceListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetResourceListResponse::GetResourceListResult = NULL;
	soap_default_time(soap, &this->_Plasma__GetResourceListResponse::currentTime);
	/* transient soap skipped */
}

void _Plasma__GetResourceListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfResourceData(soap, &this->_Plasma__GetResourceListResponse::GetResourceListResult);
	soap_embedded(soap, &this->_Plasma__GetResourceListResponse::currentTime, SOAP_TYPE_time);
	/* transient soap skipped */
}

int _Plasma__GetResourceListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetResourceListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetResourceListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetResourceListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetResourceListResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetResourceListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetResourceListResponse), type))
		return soap->error;
	if (a->GetResourceListResult)
		soap_element_result(soap, "Plasma:GetResourceListResult");
	if (soap_out_PointerToPlasma__ArrayOfResourceData(soap, "Plasma:GetResourceListResult", -1, &(a->_Plasma__GetResourceListResponse::GetResourceListResult), ""))
		return soap->error;
	if (soap_out_time(soap, "Plasma:currentTime", -1, &(a->_Plasma__GetResourceListResponse::currentTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetResourceListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetResourceListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetResourceListResponse * SOAP_FMAC4 soap_get__Plasma__GetResourceListResponse(struct soap *soap, _Plasma__GetResourceListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetResourceListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetResourceListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetResourceListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetResourceListResponse * SOAP_FMAC4 soap_in__Plasma__GetResourceListResponse(struct soap *soap, const char *tag, _Plasma__GetResourceListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetResourceListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetResourceListResponse, sizeof(_Plasma__GetResourceListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetResourceListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetResourceListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetResourceListResult1 = 1, soap_flag_currentTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetResourceListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfResourceData(soap, "Plasma:GetResourceListResult", &(a->_Plasma__GetResourceListResponse::GetResourceListResult), "Plasma:ArrayOfResourceData"))
				{	soap_flag_GetResourceListResult1--;
					continue;
				}
			if (soap_flag_currentTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Plasma:currentTime", &(a->_Plasma__GetResourceListResponse::currentTime), "xsd:dateTime"))
				{	soap_flag_currentTime1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetResourceListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetResourceListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetResourceListResponse, 0, sizeof(_Plasma__GetResourceListResponse), 0, soap_copy__Plasma__GetResourceListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetResourceListResponse * SOAP_FMAC6 soap_new__Plasma__GetResourceListResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetResourceListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetResourceListResponse(struct soap *soap, _Plasma__GetResourceListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetResourceListResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetResourceListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetResourceListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetResourceListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetResourceListResponse;
		if (size)
			*size = sizeof(_Plasma__GetResourceListResponse);
		((_Plasma__GetResourceListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetResourceListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetResourceListResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetResourceListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetResourceListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetResourceListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetResourceListResponse %p -> %p\n", q, p));
	*(_Plasma__GetResourceListResponse*)p = *(_Plasma__GetResourceListResponse*)q;
}

void _Plasma__GetResourceList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetResourceList::lastChange = NULL;
	/* transient soap skipped */
}

void _Plasma__GetResourceList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_Plasma__GetResourceList::lastChange);
	/* transient soap skipped */
}

int _Plasma__GetResourceList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetResourceList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetResourceList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetResourceList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetResourceList(struct soap *soap, const char *tag, int id, const _Plasma__GetResourceList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetResourceList), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "Plasma:lastChange", -1, &(a->_Plasma__GetResourceList::lastChange), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetResourceList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetResourceList(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetResourceList * SOAP_FMAC4 soap_get__Plasma__GetResourceList(struct soap *soap, _Plasma__GetResourceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetResourceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetResourceList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetResourceList(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetResourceList * SOAP_FMAC4 soap_in__Plasma__GetResourceList(struct soap *soap, const char *tag, _Plasma__GetResourceList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetResourceList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetResourceList, sizeof(_Plasma__GetResourceList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetResourceList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetResourceList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_lastChange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lastChange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "Plasma:lastChange", &(a->_Plasma__GetResourceList::lastChange), "xsd:dateTime"))
				{	soap_flag_lastChange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetResourceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetResourceList, 0, sizeof(_Plasma__GetResourceList), 0, soap_copy__Plasma__GetResourceList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lastChange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetResourceList * SOAP_FMAC6 soap_new__Plasma__GetResourceList(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetResourceList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetResourceList(struct soap *soap, _Plasma__GetResourceList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetResourceList * SOAP_FMAC4 soap_instantiate__Plasma__GetResourceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetResourceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetResourceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetResourceList;
		if (size)
			*size = sizeof(_Plasma__GetResourceList);
		((_Plasma__GetResourceList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetResourceList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetResourceList);
		for (int i = 0; i < n; i++)
			((_Plasma__GetResourceList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetResourceList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetResourceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetResourceList %p -> %p\n", q, p));
	*(_Plasma__GetResourceList*)p = *(_Plasma__GetResourceList*)q;
}

void _Plasma__GetResourceDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetResourceDataResponse::GetResourceDataResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetResourceDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ResourceData(soap, &this->_Plasma__GetResourceDataResponse::GetResourceDataResult);
	/* transient soap skipped */
}

int _Plasma__GetResourceDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetResourceDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetResourceDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetResourceDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetResourceDataResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetResourceDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetResourceDataResponse), type))
		return soap->error;
	if (a->GetResourceDataResult)
		soap_element_result(soap, "Plasma:GetResourceDataResult");
	if (soap_out_PointerToPlasma__ResourceData(soap, "Plasma:GetResourceDataResult", -1, &(a->_Plasma__GetResourceDataResponse::GetResourceDataResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetResourceDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetResourceDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetResourceDataResponse * SOAP_FMAC4 soap_get__Plasma__GetResourceDataResponse(struct soap *soap, _Plasma__GetResourceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetResourceDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetResourceDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetResourceDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetResourceDataResponse * SOAP_FMAC4 soap_in__Plasma__GetResourceDataResponse(struct soap *soap, const char *tag, _Plasma__GetResourceDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetResourceDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetResourceDataResponse, sizeof(_Plasma__GetResourceDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetResourceDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetResourceDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetResourceDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetResourceDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ResourceData(soap, "Plasma:GetResourceDataResult", &(a->_Plasma__GetResourceDataResponse::GetResourceDataResult), "Plasma:ResourceData"))
				{	soap_flag_GetResourceDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetResourceDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetResourceDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetResourceDataResponse, 0, sizeof(_Plasma__GetResourceDataResponse), 0, soap_copy__Plasma__GetResourceDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetResourceDataResponse * SOAP_FMAC6 soap_new__Plasma__GetResourceDataResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetResourceDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetResourceDataResponse(struct soap *soap, _Plasma__GetResourceDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetResourceDataResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetResourceDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetResourceDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetResourceDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetResourceDataResponse;
		if (size)
			*size = sizeof(_Plasma__GetResourceDataResponse);
		((_Plasma__GetResourceDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetResourceDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetResourceDataResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetResourceDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetResourceDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetResourceDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetResourceDataResponse %p -> %p\n", q, p));
	*(_Plasma__GetResourceDataResponse*)p = *(_Plasma__GetResourceDataResponse*)q;
}

void _Plasma__GetResourceData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetResourceData::md5 = NULL;
	this->_Plasma__GetResourceData::internalName = NULL;
	/* transient soap skipped */
}

void _Plasma__GetResourceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetResourceData::md5);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetResourceData::internalName);
	/* transient soap skipped */
}

int _Plasma__GetResourceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetResourceData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetResourceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetResourceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetResourceData(struct soap *soap, const char *tag, int id, const _Plasma__GetResourceData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetResourceData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:md5", -1, &(a->_Plasma__GetResourceData::md5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:internalName", -1, &(a->_Plasma__GetResourceData::internalName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetResourceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetResourceData(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetResourceData * SOAP_FMAC4 soap_get__Plasma__GetResourceData(struct soap *soap, _Plasma__GetResourceData *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetResourceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetResourceData(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetResourceData * SOAP_FMAC4 soap_in__Plasma__GetResourceData(struct soap *soap, const char *tag, _Plasma__GetResourceData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetResourceData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetResourceData, sizeof(_Plasma__GetResourceData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetResourceData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetResourceData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_md51 = 1, soap_flag_internalName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_md51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:md5", &(a->_Plasma__GetResourceData::md5), "xsd:string"))
				{	soap_flag_md51--;
					continue;
				}
			if (soap_flag_internalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:internalName", &(a->_Plasma__GetResourceData::internalName), "xsd:string"))
				{	soap_flag_internalName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetResourceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetResourceData, 0, sizeof(_Plasma__GetResourceData), 0, soap_copy__Plasma__GetResourceData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetResourceData * SOAP_FMAC6 soap_new__Plasma__GetResourceData(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetResourceData(struct soap *soap, _Plasma__GetResourceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetResourceData * SOAP_FMAC4 soap_instantiate__Plasma__GetResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetResourceData;
		if (size)
			*size = sizeof(_Plasma__GetResourceData);
		((_Plasma__GetResourceData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetResourceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetResourceData);
		for (int i = 0; i < n; i++)
			((_Plasma__GetResourceData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetResourceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetResourceData %p -> %p\n", q, p));
	*(_Plasma__GetResourceData*)p = *(_Plasma__GetResourceData*)q;
}

void _Plasma__GetRecommendedMapResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetRecommendedMapResponse::GetRecommendedMapResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetRecommendedMapResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__RecommendedMapResult(soap, &this->_Plasma__GetRecommendedMapResponse::GetRecommendedMapResult);
	/* transient soap skipped */
}

int _Plasma__GetRecommendedMapResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetRecommendedMapResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetRecommendedMapResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetRecommendedMapResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetRecommendedMapResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetRecommendedMapResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetRecommendedMapResponse), type))
		return soap->error;
	if (a->GetRecommendedMapResult)
		soap_element_result(soap, "Plasma:GetRecommendedMapResult");
	if (soap_out_PointerToPlasma__RecommendedMapResult(soap, "Plasma:GetRecommendedMapResult", -1, &(a->_Plasma__GetRecommendedMapResponse::GetRecommendedMapResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetRecommendedMapResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetRecommendedMapResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMapResponse * SOAP_FMAC4 soap_get__Plasma__GetRecommendedMapResponse(struct soap *soap, _Plasma__GetRecommendedMapResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetRecommendedMapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetRecommendedMapResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetRecommendedMapResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMapResponse * SOAP_FMAC4 soap_in__Plasma__GetRecommendedMapResponse(struct soap *soap, const char *tag, _Plasma__GetRecommendedMapResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetRecommendedMapResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetRecommendedMapResponse, sizeof(_Plasma__GetRecommendedMapResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetRecommendedMapResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetRecommendedMapResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetRecommendedMapResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRecommendedMapResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__RecommendedMapResult(soap, "Plasma:GetRecommendedMapResult", &(a->_Plasma__GetRecommendedMapResponse::GetRecommendedMapResult), "Plasma:RecommendedMapResult"))
				{	soap_flag_GetRecommendedMapResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetRecommendedMapResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetRecommendedMapResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetRecommendedMapResponse, 0, sizeof(_Plasma__GetRecommendedMapResponse), 0, soap_copy__Plasma__GetRecommendedMapResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetRecommendedMapResponse * SOAP_FMAC6 soap_new__Plasma__GetRecommendedMapResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetRecommendedMapResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetRecommendedMapResponse(struct soap *soap, _Plasma__GetRecommendedMapResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetRecommendedMapResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetRecommendedMapResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetRecommendedMapResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetRecommendedMapResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetRecommendedMapResponse;
		if (size)
			*size = sizeof(_Plasma__GetRecommendedMapResponse);
		((_Plasma__GetRecommendedMapResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetRecommendedMapResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetRecommendedMapResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetRecommendedMapResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetRecommendedMapResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetRecommendedMapResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetRecommendedMapResponse %p -> %p\n", q, p));
	*(_Plasma__GetRecommendedMapResponse*)p = *(_Plasma__GetRecommendedMapResponse*)q;
}

void _Plasma__GetRecommendedMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetRecommendedMap::autohostName = NULL;
	this->_Plasma__GetRecommendedMap::accounts = NULL;
	/* transient soap skipped */
}

void _Plasma__GetRecommendedMap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetRecommendedMap::autohostName);
	soap_serialize_PointerToPlasma__ArrayOfAccountTeam(soap, &this->_Plasma__GetRecommendedMap::accounts);
	/* transient soap skipped */
}

int _Plasma__GetRecommendedMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetRecommendedMap);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetRecommendedMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetRecommendedMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetRecommendedMap(struct soap *soap, const char *tag, int id, const _Plasma__GetRecommendedMap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetRecommendedMap), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:autohostName", -1, &(a->_Plasma__GetRecommendedMap::autohostName), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:accounts", -1, &(a->_Plasma__GetRecommendedMap::accounts), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetRecommendedMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetRecommendedMap(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMap * SOAP_FMAC4 soap_get__Plasma__GetRecommendedMap(struct soap *soap, _Plasma__GetRecommendedMap *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetRecommendedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetRecommendedMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetRecommendedMap(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMap * SOAP_FMAC4 soap_in__Plasma__GetRecommendedMap(struct soap *soap, const char *tag, _Plasma__GetRecommendedMap *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetRecommendedMap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetRecommendedMap, sizeof(_Plasma__GetRecommendedMap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetRecommendedMap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetRecommendedMap *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_autohostName1 = 1, soap_flag_accounts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_autohostName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:autohostName", &(a->_Plasma__GetRecommendedMap::autohostName), "xsd:string"))
				{	soap_flag_autohostName1--;
					continue;
				}
			if (soap_flag_accounts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:accounts", &(a->_Plasma__GetRecommendedMap::accounts), "Plasma:ArrayOfAccountTeam"))
				{	soap_flag_accounts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetRecommendedMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetRecommendedMap, 0, sizeof(_Plasma__GetRecommendedMap), 0, soap_copy__Plasma__GetRecommendedMap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetRecommendedMap * SOAP_FMAC6 soap_new__Plasma__GetRecommendedMap(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetRecommendedMap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetRecommendedMap(struct soap *soap, _Plasma__GetRecommendedMap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetRecommendedMap * SOAP_FMAC4 soap_instantiate__Plasma__GetRecommendedMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetRecommendedMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetRecommendedMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetRecommendedMap;
		if (size)
			*size = sizeof(_Plasma__GetRecommendedMap);
		((_Plasma__GetRecommendedMap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetRecommendedMap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetRecommendedMap);
		for (int i = 0; i < n; i++)
			((_Plasma__GetRecommendedMap*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetRecommendedMap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetRecommendedMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetRecommendedMap %p -> %p\n", q, p));
	*(_Plasma__GetRecommendedMap*)p = *(_Plasma__GetRecommendedMap*)q;
}

void _Plasma__GetEloTop10Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetEloTop10Response::GetEloTop10Result = NULL;
	/* transient soap skipped */
}

void _Plasma__GetEloTop10Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->_Plasma__GetEloTop10Response::GetEloTop10Result);
	/* transient soap skipped */
}

int _Plasma__GetEloTop10Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloTop10Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloTop10Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloTop10Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloTop10Response(struct soap *soap, const char *tag, int id, const _Plasma__GetEloTop10Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloTop10Response), type))
		return soap->error;
	if (a->GetEloTop10Result)
		soap_element_result(soap, "Plasma:GetEloTop10Result");
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:GetEloTop10Result", -1, &(a->_Plasma__GetEloTop10Response::GetEloTop10Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloTop10Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloTop10Response(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10Response * SOAP_FMAC4 soap_get__Plasma__GetEloTop10Response(struct soap *soap, _Plasma__GetEloTop10Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloTop10Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloTop10Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloTop10Response(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10Response * SOAP_FMAC4 soap_in__Plasma__GetEloTop10Response(struct soap *soap, const char *tag, _Plasma__GetEloTop10Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloTop10Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloTop10Response, sizeof(_Plasma__GetEloTop10Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloTop10Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloTop10Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetEloTop10Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEloTop10Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:GetEloTop10Result", &(a->_Plasma__GetEloTop10Response::GetEloTop10Result), "Plasma:ArrayOfString"))
				{	soap_flag_GetEloTop10Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetEloTop10Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloTop10Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloTop10Response, 0, sizeof(_Plasma__GetEloTop10Response), 0, soap_copy__Plasma__GetEloTop10Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloTop10Response * SOAP_FMAC6 soap_new__Plasma__GetEloTop10Response(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloTop10Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloTop10Response(struct soap *soap, _Plasma__GetEloTop10Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloTop10Response * SOAP_FMAC4 soap_instantiate__Plasma__GetEloTop10Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloTop10Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloTop10Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloTop10Response;
		if (size)
			*size = sizeof(_Plasma__GetEloTop10Response);
		((_Plasma__GetEloTop10Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloTop10Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloTop10Response);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloTop10Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloTop10Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloTop10Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloTop10Response %p -> %p\n", q, p));
	*(_Plasma__GetEloTop10Response*)p = *(_Plasma__GetEloTop10Response*)q;
}

void _Plasma__GetEloTop10::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Plasma__GetEloTop10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Plasma__GetEloTop10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloTop10);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloTop10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloTop10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloTop10(struct soap *soap, const char *tag, int id, const _Plasma__GetEloTop10 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloTop10), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloTop10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloTop10(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10 * SOAP_FMAC4 soap_get__Plasma__GetEloTop10(struct soap *soap, _Plasma__GetEloTop10 *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloTop10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloTop10::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloTop10(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10 * SOAP_FMAC4 soap_in__Plasma__GetEloTop10(struct soap *soap, const char *tag, _Plasma__GetEloTop10 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloTop10 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloTop10, sizeof(_Plasma__GetEloTop10), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloTop10)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloTop10 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloTop10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloTop10, 0, sizeof(_Plasma__GetEloTop10), 0, soap_copy__Plasma__GetEloTop10);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloTop10 * SOAP_FMAC6 soap_new__Plasma__GetEloTop10(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloTop10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloTop10(struct soap *soap, _Plasma__GetEloTop10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloTop10 * SOAP_FMAC4 soap_instantiate__Plasma__GetEloTop10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloTop10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloTop10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloTop10;
		if (size)
			*size = sizeof(_Plasma__GetEloTop10);
		((_Plasma__GetEloTop10*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloTop10[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloTop10);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloTop10*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloTop10*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloTop10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloTop10 %p -> %p\n", q, p));
	*(_Plasma__GetEloTop10*)p = *(_Plasma__GetEloTop10*)q;
}

void _Plasma__GetEloByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetEloByNameResponse::GetEloByNameResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetEloByNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__EloInfo(soap, &this->_Plasma__GetEloByNameResponse::GetEloByNameResult);
	/* transient soap skipped */
}

int _Plasma__GetEloByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloByNameResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloByNameResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetEloByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloByNameResponse), type))
		return soap->error;
	if (a->GetEloByNameResult)
		soap_element_result(soap, "Plasma:GetEloByNameResult");
	if (soap_out_PointerToPlasma__EloInfo(soap, "Plasma:GetEloByNameResult", -1, &(a->_Plasma__GetEloByNameResponse::GetEloByNameResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloByNameResponse * SOAP_FMAC4 soap_get__Plasma__GetEloByNameResponse(struct soap *soap, _Plasma__GetEloByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloByNameResponse * SOAP_FMAC4 soap_in__Plasma__GetEloByNameResponse(struct soap *soap, const char *tag, _Plasma__GetEloByNameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloByNameResponse, sizeof(_Plasma__GetEloByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloByNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetEloByNameResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEloByNameResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__EloInfo(soap, "Plasma:GetEloByNameResult", &(a->_Plasma__GetEloByNameResponse::GetEloByNameResult), "Plasma:EloInfo"))
				{	soap_flag_GetEloByNameResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetEloByNameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloByNameResponse, 0, sizeof(_Plasma__GetEloByNameResponse), 0, soap_copy__Plasma__GetEloByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloByNameResponse * SOAP_FMAC6 soap_new__Plasma__GetEloByNameResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloByNameResponse(struct soap *soap, _Plasma__GetEloByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloByNameResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetEloByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloByNameResponse;
		if (size)
			*size = sizeof(_Plasma__GetEloByNameResponse);
		((_Plasma__GetEloByNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloByNameResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloByNameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloByNameResponse %p -> %p\n", q, p));
	*(_Plasma__GetEloByNameResponse*)p = *(_Plasma__GetEloByNameResponse*)q;
}

void _Plasma__GetEloByName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetEloByName::name = NULL;
	/* transient soap skipped */
}

void _Plasma__GetEloByName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__GetEloByName::name);
	/* transient soap skipped */
}

int _Plasma__GetEloByName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloByName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloByName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloByName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloByName(struct soap *soap, const char *tag, int id, const _Plasma__GetEloByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloByName), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:name", -1, &(a->_Plasma__GetEloByName::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloByName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloByName(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloByName * SOAP_FMAC4 soap_get__Plasma__GetEloByName(struct soap *soap, _Plasma__GetEloByName *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloByName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloByName(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloByName * SOAP_FMAC4 soap_in__Plasma__GetEloByName(struct soap *soap, const char *tag, _Plasma__GetEloByName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloByName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloByName, sizeof(_Plasma__GetEloByName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloByName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloByName *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:name", &(a->_Plasma__GetEloByName::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloByName, 0, sizeof(_Plasma__GetEloByName), 0, soap_copy__Plasma__GetEloByName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloByName * SOAP_FMAC6 soap_new__Plasma__GetEloByName(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloByName(struct soap *soap, _Plasma__GetEloByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloByName * SOAP_FMAC4 soap_instantiate__Plasma__GetEloByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloByName;
		if (size)
			*size = sizeof(_Plasma__GetEloByName);
		((_Plasma__GetEloByName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloByName);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloByName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloByName %p -> %p\n", q, p));
	*(_Plasma__GetEloByName*)p = *(_Plasma__GetEloByName*)q;
}

void _Plasma__GetEloByAccountIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__GetEloByAccountIDResponse::GetEloByAccountIDResult = NULL;
	/* transient soap skipped */
}

void _Plasma__GetEloByAccountIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__EloInfo(soap, &this->_Plasma__GetEloByAccountIDResponse::GetEloByAccountIDResult);
	/* transient soap skipped */
}

int _Plasma__GetEloByAccountIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloByAccountIDResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloByAccountIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloByAccountIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloByAccountIDResponse(struct soap *soap, const char *tag, int id, const _Plasma__GetEloByAccountIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloByAccountIDResponse), type))
		return soap->error;
	if (a->GetEloByAccountIDResult)
		soap_element_result(soap, "Plasma:GetEloByAccountIDResult");
	if (soap_out_PointerToPlasma__EloInfo(soap, "Plasma:GetEloByAccountIDResult", -1, &(a->_Plasma__GetEloByAccountIDResponse::GetEloByAccountIDResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloByAccountIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloByAccountIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountIDResponse * SOAP_FMAC4 soap_get__Plasma__GetEloByAccountIDResponse(struct soap *soap, _Plasma__GetEloByAccountIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloByAccountIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloByAccountIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloByAccountIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountIDResponse * SOAP_FMAC4 soap_in__Plasma__GetEloByAccountIDResponse(struct soap *soap, const char *tag, _Plasma__GetEloByAccountIDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloByAccountIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloByAccountIDResponse, sizeof(_Plasma__GetEloByAccountIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloByAccountIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloByAccountIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetEloByAccountIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEloByAccountIDResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__EloInfo(soap, "Plasma:GetEloByAccountIDResult", &(a->_Plasma__GetEloByAccountIDResponse::GetEloByAccountIDResult), "Plasma:EloInfo"))
				{	soap_flag_GetEloByAccountIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:GetEloByAccountIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloByAccountIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloByAccountIDResponse, 0, sizeof(_Plasma__GetEloByAccountIDResponse), 0, soap_copy__Plasma__GetEloByAccountIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloByAccountIDResponse * SOAP_FMAC6 soap_new__Plasma__GetEloByAccountIDResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloByAccountIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloByAccountIDResponse(struct soap *soap, _Plasma__GetEloByAccountIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloByAccountIDResponse * SOAP_FMAC4 soap_instantiate__Plasma__GetEloByAccountIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloByAccountIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloByAccountIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloByAccountIDResponse;
		if (size)
			*size = sizeof(_Plasma__GetEloByAccountIDResponse);
		((_Plasma__GetEloByAccountIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloByAccountIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloByAccountIDResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloByAccountIDResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloByAccountIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloByAccountIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloByAccountIDResponse %p -> %p\n", q, p));
	*(_Plasma__GetEloByAccountIDResponse*)p = *(_Plasma__GetEloByAccountIDResponse*)q;
}

void _Plasma__GetEloByAccountID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Plasma__GetEloByAccountID::accountID);
	/* transient soap skipped */
}

void _Plasma__GetEloByAccountID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_Plasma__GetEloByAccountID::accountID, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _Plasma__GetEloByAccountID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__GetEloByAccountID);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__GetEloByAccountID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__GetEloByAccountID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__GetEloByAccountID(struct soap *soap, const char *tag, int id, const _Plasma__GetEloByAccountID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__GetEloByAccountID), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:accountID", -1, &(a->_Plasma__GetEloByAccountID::accountID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__GetEloByAccountID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__GetEloByAccountID(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountID * SOAP_FMAC4 soap_get__Plasma__GetEloByAccountID(struct soap *soap, _Plasma__GetEloByAccountID *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__GetEloByAccountID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__GetEloByAccountID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__GetEloByAccountID(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountID * SOAP_FMAC4 soap_in__Plasma__GetEloByAccountID(struct soap *soap, const char *tag, _Plasma__GetEloByAccountID *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__GetEloByAccountID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__GetEloByAccountID, sizeof(_Plasma__GetEloByAccountID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__GetEloByAccountID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__GetEloByAccountID *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:accountID", &(a->_Plasma__GetEloByAccountID::accountID), "xsd:int"))
				{	soap_flag_accountID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__GetEloByAccountID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__GetEloByAccountID, 0, sizeof(_Plasma__GetEloByAccountID), 0, soap_copy__Plasma__GetEloByAccountID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accountID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__GetEloByAccountID * SOAP_FMAC6 soap_new__Plasma__GetEloByAccountID(struct soap *soap, int n)
{	return soap_instantiate__Plasma__GetEloByAccountID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__GetEloByAccountID(struct soap *soap, _Plasma__GetEloByAccountID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__GetEloByAccountID * SOAP_FMAC4 soap_instantiate__Plasma__GetEloByAccountID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__GetEloByAccountID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__GetEloByAccountID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__GetEloByAccountID;
		if (size)
			*size = sizeof(_Plasma__GetEloByAccountID);
		((_Plasma__GetEloByAccountID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__GetEloByAccountID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__GetEloByAccountID);
		for (int i = 0; i < n; i++)
			((_Plasma__GetEloByAccountID*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__GetEloByAccountID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__GetEloByAccountID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__GetEloByAccountID %p -> %p\n", q, p));
	*(_Plasma__GetEloByAccountID*)p = *(_Plasma__GetEloByAccountID*)q;
}

void _Plasma__DownloadFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_Plasma__DownloadFileResponse::DownloadFileResult);
	this->_Plasma__DownloadFileResponse::links = NULL;
	this->_Plasma__DownloadFileResponse::torrent = NULL;
	this->_Plasma__DownloadFileResponse::dependencies = NULL;
	soap_default_Plasma__ResourceType(soap, &this->_Plasma__DownloadFileResponse::resourceType);
	this->_Plasma__DownloadFileResponse::torrentFileName = NULL;
	/* transient soap skipped */
}

void _Plasma__DownloadFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->_Plasma__DownloadFileResponse::links);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_Plasma__DownloadFileResponse::torrent);
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->_Plasma__DownloadFileResponse::dependencies);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__DownloadFileResponse::torrentFileName);
	/* transient soap skipped */
}

int _Plasma__DownloadFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__DownloadFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__DownloadFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__DownloadFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__DownloadFileResponse(struct soap *soap, const char *tag, int id, const _Plasma__DownloadFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__DownloadFileResponse), type))
		return soap->error;
	soap_element_result(soap, "Plasma:DownloadFileResult");
	if (soap_out_bool(soap, "Plasma:DownloadFileResult", -1, &(a->_Plasma__DownloadFileResponse::DownloadFileResult), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:links", -1, &(a->_Plasma__DownloadFileResponse::links), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "Plasma:torrent", -1, &(a->_Plasma__DownloadFileResponse::torrent), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:dependencies", -1, &(a->_Plasma__DownloadFileResponse::dependencies), ""))
		return soap->error;
	if (soap_out_Plasma__ResourceType(soap, "Plasma:resourceType", -1, &(a->_Plasma__DownloadFileResponse::resourceType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:torrentFileName", -1, &(a->_Plasma__DownloadFileResponse::torrentFileName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__DownloadFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__DownloadFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__DownloadFileResponse * SOAP_FMAC4 soap_get__Plasma__DownloadFileResponse(struct soap *soap, _Plasma__DownloadFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__DownloadFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__DownloadFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__DownloadFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__DownloadFileResponse * SOAP_FMAC4 soap_in__Plasma__DownloadFileResponse(struct soap *soap, const char *tag, _Plasma__DownloadFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__DownloadFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__DownloadFileResponse, sizeof(_Plasma__DownloadFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__DownloadFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__DownloadFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DownloadFileResult1 = 1, soap_flag_links1 = 1, soap_flag_torrent1 = 1, soap_flag_dependencies1 = 1, soap_flag_resourceType1 = 1, soap_flag_torrentFileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownloadFileResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:DownloadFileResult", &(a->_Plasma__DownloadFileResponse::DownloadFileResult), "xsd:boolean"))
				{	soap_flag_DownloadFileResult1--;
					continue;
				}
			if (soap_flag_links1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:links", &(a->_Plasma__DownloadFileResponse::links), "Plasma:ArrayOfString"))
				{	soap_flag_links1--;
					continue;
				}
			if (soap_flag_torrent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "Plasma:torrent", &(a->_Plasma__DownloadFileResponse::torrent), "xsd:base64Binary"))
				{	soap_flag_torrent1--;
					continue;
				}
			if (soap_flag_dependencies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:dependencies", &(a->_Plasma__DownloadFileResponse::dependencies), "Plasma:ArrayOfString"))
				{	soap_flag_dependencies1--;
					continue;
				}
			if (soap_flag_resourceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__ResourceType(soap, "Plasma:resourceType", &(a->_Plasma__DownloadFileResponse::resourceType), "Plasma:ResourceType"))
				{	soap_flag_resourceType1--;
					continue;
				}
			if (soap_flag_torrentFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:torrentFileName", &(a->_Plasma__DownloadFileResponse::torrentFileName), "xsd:string"))
				{	soap_flag_torrentFileName1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:DownloadFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__DownloadFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__DownloadFileResponse, 0, sizeof(_Plasma__DownloadFileResponse), 0, soap_copy__Plasma__DownloadFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DownloadFileResult1 > 0 || soap_flag_resourceType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__DownloadFileResponse * SOAP_FMAC6 soap_new__Plasma__DownloadFileResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__DownloadFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__DownloadFileResponse(struct soap *soap, _Plasma__DownloadFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__DownloadFileResponse * SOAP_FMAC4 soap_instantiate__Plasma__DownloadFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__DownloadFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__DownloadFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__DownloadFileResponse;
		if (size)
			*size = sizeof(_Plasma__DownloadFileResponse);
		((_Plasma__DownloadFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__DownloadFileResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__DownloadFileResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__DownloadFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__DownloadFileResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__DownloadFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__DownloadFileResponse %p -> %p\n", q, p));
	*(_Plasma__DownloadFileResponse*)p = *(_Plasma__DownloadFileResponse*)q;
}

void _Plasma__DownloadFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__DownloadFile::internalName = NULL;
	/* transient soap skipped */
}

void _Plasma__DownloadFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__DownloadFile::internalName);
	/* transient soap skipped */
}

int _Plasma__DownloadFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__DownloadFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__DownloadFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__DownloadFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__DownloadFile(struct soap *soap, const char *tag, int id, const _Plasma__DownloadFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__DownloadFile), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:internalName", -1, &(a->_Plasma__DownloadFile::internalName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__DownloadFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__DownloadFile(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__DownloadFile * SOAP_FMAC4 soap_get__Plasma__DownloadFile(struct soap *soap, _Plasma__DownloadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__DownloadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__DownloadFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__DownloadFile(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__DownloadFile * SOAP_FMAC4 soap_in__Plasma__DownloadFile(struct soap *soap, const char *tag, _Plasma__DownloadFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__DownloadFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__DownloadFile, sizeof(_Plasma__DownloadFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__DownloadFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__DownloadFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_internalName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_internalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:internalName", &(a->_Plasma__DownloadFile::internalName), "xsd:string"))
				{	soap_flag_internalName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__DownloadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__DownloadFile, 0, sizeof(_Plasma__DownloadFile), 0, soap_copy__Plasma__DownloadFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__DownloadFile * SOAP_FMAC6 soap_new__Plasma__DownloadFile(struct soap *soap, int n)
{	return soap_instantiate__Plasma__DownloadFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__DownloadFile(struct soap *soap, _Plasma__DownloadFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__DownloadFile * SOAP_FMAC4 soap_instantiate__Plasma__DownloadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__DownloadFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__DownloadFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__DownloadFile;
		if (size)
			*size = sizeof(_Plasma__DownloadFile);
		((_Plasma__DownloadFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__DownloadFile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__DownloadFile);
		for (int i = 0; i < n; i++)
			((_Plasma__DownloadFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__DownloadFile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__DownloadFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__DownloadFile %p -> %p\n", q, p));
	*(_Plasma__DownloadFile*)p = *(_Plasma__DownloadFile*)q;
}

void _Plasma__BalanceTeamsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__BalanceTeamsResponse::BalanceTeamsResult = NULL;
	/* transient soap skipped */
}

void _Plasma__BalanceTeamsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__BalanceTeamsResult(soap, &this->_Plasma__BalanceTeamsResponse::BalanceTeamsResult);
	/* transient soap skipped */
}

int _Plasma__BalanceTeamsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__BalanceTeamsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__BalanceTeamsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__BalanceTeamsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__BalanceTeamsResponse(struct soap *soap, const char *tag, int id, const _Plasma__BalanceTeamsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__BalanceTeamsResponse), type))
		return soap->error;
	if (a->BalanceTeamsResult)
		soap_element_result(soap, "Plasma:BalanceTeamsResult");
	if (soap_out_PointerToPlasma__BalanceTeamsResult(soap, "Plasma:BalanceTeamsResult", -1, &(a->_Plasma__BalanceTeamsResponse::BalanceTeamsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__BalanceTeamsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__BalanceTeamsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__BalanceTeamsResponse * SOAP_FMAC4 soap_get__Plasma__BalanceTeamsResponse(struct soap *soap, _Plasma__BalanceTeamsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__BalanceTeamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__BalanceTeamsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__BalanceTeamsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__BalanceTeamsResponse * SOAP_FMAC4 soap_in__Plasma__BalanceTeamsResponse(struct soap *soap, const char *tag, _Plasma__BalanceTeamsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__BalanceTeamsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__BalanceTeamsResponse, sizeof(_Plasma__BalanceTeamsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__BalanceTeamsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__BalanceTeamsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_BalanceTeamsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BalanceTeamsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__BalanceTeamsResult(soap, "Plasma:BalanceTeamsResult", &(a->_Plasma__BalanceTeamsResponse::BalanceTeamsResult), "Plasma:BalanceTeamsResult"))
				{	soap_flag_BalanceTeamsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:BalanceTeamsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__BalanceTeamsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__BalanceTeamsResponse, 0, sizeof(_Plasma__BalanceTeamsResponse), 0, soap_copy__Plasma__BalanceTeamsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__BalanceTeamsResponse * SOAP_FMAC6 soap_new__Plasma__BalanceTeamsResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__BalanceTeamsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__BalanceTeamsResponse(struct soap *soap, _Plasma__BalanceTeamsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__BalanceTeamsResponse * SOAP_FMAC4 soap_instantiate__Plasma__BalanceTeamsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__BalanceTeamsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__BalanceTeamsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__BalanceTeamsResponse;
		if (size)
			*size = sizeof(_Plasma__BalanceTeamsResponse);
		((_Plasma__BalanceTeamsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__BalanceTeamsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__BalanceTeamsResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__BalanceTeamsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__BalanceTeamsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__BalanceTeamsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__BalanceTeamsResponse %p -> %p\n", q, p));
	*(_Plasma__BalanceTeamsResponse*)p = *(_Plasma__BalanceTeamsResponse*)q;
}

void _Plasma__BalanceTeams::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__BalanceTeams::autoHost = NULL;
	this->_Plasma__BalanceTeams::map = NULL;
	this->_Plasma__BalanceTeams::currentTeams = NULL;
	/* transient soap skipped */
}

void _Plasma__BalanceTeams::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__BalanceTeams::autoHost);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__BalanceTeams::map);
	soap_serialize_PointerToPlasma__ArrayOfAccountTeam(soap, &this->_Plasma__BalanceTeams::currentTeams);
	/* transient soap skipped */
}

int _Plasma__BalanceTeams::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__BalanceTeams);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__BalanceTeams::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__BalanceTeams(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__BalanceTeams(struct soap *soap, const char *tag, int id, const _Plasma__BalanceTeams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__BalanceTeams), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:autoHost", -1, &(a->_Plasma__BalanceTeams::autoHost), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:map", -1, &(a->_Plasma__BalanceTeams::map), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:currentTeams", -1, &(a->_Plasma__BalanceTeams::currentTeams), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__BalanceTeams::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__BalanceTeams(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__BalanceTeams * SOAP_FMAC4 soap_get__Plasma__BalanceTeams(struct soap *soap, _Plasma__BalanceTeams *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__BalanceTeams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__BalanceTeams::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__BalanceTeams(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__BalanceTeams * SOAP_FMAC4 soap_in__Plasma__BalanceTeams(struct soap *soap, const char *tag, _Plasma__BalanceTeams *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__BalanceTeams *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__BalanceTeams, sizeof(_Plasma__BalanceTeams), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__BalanceTeams)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__BalanceTeams *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_autoHost1 = 1, soap_flag_map1 = 1, soap_flag_currentTeams1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_autoHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:autoHost", &(a->_Plasma__BalanceTeams::autoHost), "xsd:string"))
				{	soap_flag_autoHost1--;
					continue;
				}
			if (soap_flag_map1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:map", &(a->_Plasma__BalanceTeams::map), "xsd:string"))
				{	soap_flag_map1--;
					continue;
				}
			if (soap_flag_currentTeams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:currentTeams", &(a->_Plasma__BalanceTeams::currentTeams), "Plasma:ArrayOfAccountTeam"))
				{	soap_flag_currentTeams1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__BalanceTeams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__BalanceTeams, 0, sizeof(_Plasma__BalanceTeams), 0, soap_copy__Plasma__BalanceTeams);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__BalanceTeams * SOAP_FMAC6 soap_new__Plasma__BalanceTeams(struct soap *soap, int n)
{	return soap_instantiate__Plasma__BalanceTeams(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__BalanceTeams(struct soap *soap, _Plasma__BalanceTeams *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__BalanceTeams * SOAP_FMAC4 soap_instantiate__Plasma__BalanceTeams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__BalanceTeams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__BalanceTeams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__BalanceTeams;
		if (size)
			*size = sizeof(_Plasma__BalanceTeams);
		((_Plasma__BalanceTeams*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__BalanceTeams[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__BalanceTeams);
		for (int i = 0; i < n; i++)
			((_Plasma__BalanceTeams*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__BalanceTeams*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__BalanceTeams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__BalanceTeams %p -> %p\n", q, p));
	*(_Plasma__BalanceTeams*)p = *(_Plasma__BalanceTeams*)q;
}

void _Plasma__AutohostPlayerJoinedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__AutohostPlayerJoinedResponse::AutohostPlayerJoinedResult = NULL;
	/* transient soap skipped */
}

void _Plasma__AutohostPlayerJoinedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__AutohostPlayerJoinedResponse::AutohostPlayerJoinedResult);
	/* transient soap skipped */
}

int _Plasma__AutohostPlayerJoinedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__AutohostPlayerJoinedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__AutohostPlayerJoinedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, const char *tag, int id, const _Plasma__AutohostPlayerJoinedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse), type))
		return soap->error;
	if (a->AutohostPlayerJoinedResult)
		soap_element_result(soap, "Plasma:AutohostPlayerJoinedResult");
	if (soap_out_PointerTostd__string(soap, "Plasma:AutohostPlayerJoinedResult", -1, &(a->_Plasma__AutohostPlayerJoinedResponse::AutohostPlayerJoinedResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__AutohostPlayerJoinedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__AutohostPlayerJoinedResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoinedResponse * SOAP_FMAC4 soap_get__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, _Plasma__AutohostPlayerJoinedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__AutohostPlayerJoinedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__AutohostPlayerJoinedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__AutohostPlayerJoinedResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoinedResponse * SOAP_FMAC4 soap_in__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, const char *tag, _Plasma__AutohostPlayerJoinedResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__AutohostPlayerJoinedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse, sizeof(_Plasma__AutohostPlayerJoinedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__AutohostPlayerJoinedResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AutohostPlayerJoinedResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutohostPlayerJoinedResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:AutohostPlayerJoinedResult", &(a->_Plasma__AutohostPlayerJoinedResponse::AutohostPlayerJoinedResult), "xsd:string"))
				{	soap_flag_AutohostPlayerJoinedResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "Plasma:AutohostPlayerJoinedResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__AutohostPlayerJoinedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse, 0, sizeof(_Plasma__AutohostPlayerJoinedResponse), 0, soap_copy__Plasma__AutohostPlayerJoinedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__AutohostPlayerJoinedResponse * SOAP_FMAC6 soap_new__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, int n)
{	return soap_instantiate__Plasma__AutohostPlayerJoinedResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, _Plasma__AutohostPlayerJoinedResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoinedResponse * SOAP_FMAC4 soap_instantiate__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__AutohostPlayerJoinedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__AutohostPlayerJoinedResponse;
		if (size)
			*size = sizeof(_Plasma__AutohostPlayerJoinedResponse);
		((_Plasma__AutohostPlayerJoinedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__AutohostPlayerJoinedResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__AutohostPlayerJoinedResponse);
		for (int i = 0; i < n; i++)
			((_Plasma__AutohostPlayerJoinedResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__AutohostPlayerJoinedResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__AutohostPlayerJoinedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__AutohostPlayerJoinedResponse %p -> %p\n", q, p));
	*(_Plasma__AutohostPlayerJoinedResponse*)p = *(_Plasma__AutohostPlayerJoinedResponse*)q;
}

void _Plasma__AutohostPlayerJoined::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Plasma__AutohostPlayerJoined::autohostName = NULL;
	this->_Plasma__AutohostPlayerJoined::mapName = NULL;
	soap_default_int(soap, &this->_Plasma__AutohostPlayerJoined::accountID);
	/* transient soap skipped */
}

void _Plasma__AutohostPlayerJoined::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__AutohostPlayerJoined::autohostName);
	soap_serialize_PointerTostd__string(soap, &this->_Plasma__AutohostPlayerJoined::mapName);
	soap_embedded(soap, &this->_Plasma__AutohostPlayerJoined::accountID, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _Plasma__AutohostPlayerJoined::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__Plasma__AutohostPlayerJoined);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Plasma__AutohostPlayerJoined::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Plasma__AutohostPlayerJoined(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Plasma__AutohostPlayerJoined(struct soap *soap, const char *tag, int id, const _Plasma__AutohostPlayerJoined *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__Plasma__AutohostPlayerJoined), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:autohostName", -1, &(a->_Plasma__AutohostPlayerJoined::autohostName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:mapName", -1, &(a->_Plasma__AutohostPlayerJoined::mapName), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:accountID", -1, &(a->_Plasma__AutohostPlayerJoined::accountID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Plasma__AutohostPlayerJoined::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Plasma__AutohostPlayerJoined(soap, this, tag, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoined * SOAP_FMAC4 soap_get__Plasma__AutohostPlayerJoined(struct soap *soap, _Plasma__AutohostPlayerJoined *p, const char *tag, const char *type)
{
	if ((p = soap_in__Plasma__AutohostPlayerJoined(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_Plasma__AutohostPlayerJoined::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Plasma__AutohostPlayerJoined(soap, tag, this, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoined * SOAP_FMAC4 soap_in__Plasma__AutohostPlayerJoined(struct soap *soap, const char *tag, _Plasma__AutohostPlayerJoined *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Plasma__AutohostPlayerJoined *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Plasma__AutohostPlayerJoined, sizeof(_Plasma__AutohostPlayerJoined), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__Plasma__AutohostPlayerJoined)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Plasma__AutohostPlayerJoined *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_autohostName1 = 1, soap_flag_mapName1 = 1, soap_flag_accountID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_autohostName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:autohostName", &(a->_Plasma__AutohostPlayerJoined::autohostName), "xsd:string"))
				{	soap_flag_autohostName1--;
					continue;
				}
			if (soap_flag_mapName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:mapName", &(a->_Plasma__AutohostPlayerJoined::mapName), "xsd:string"))
				{	soap_flag_mapName1--;
					continue;
				}
			if (soap_flag_accountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:accountID", &(a->_Plasma__AutohostPlayerJoined::accountID), "xsd:int"))
				{	soap_flag_accountID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Plasma__AutohostPlayerJoined *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__Plasma__AutohostPlayerJoined, 0, sizeof(_Plasma__AutohostPlayerJoined), 0, soap_copy__Plasma__AutohostPlayerJoined);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accountID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _Plasma__AutohostPlayerJoined * SOAP_FMAC6 soap_new__Plasma__AutohostPlayerJoined(struct soap *soap, int n)
{	return soap_instantiate__Plasma__AutohostPlayerJoined(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Plasma__AutohostPlayerJoined(struct soap *soap, _Plasma__AutohostPlayerJoined *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoined * SOAP_FMAC4 soap_instantiate__Plasma__AutohostPlayerJoined(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Plasma__AutohostPlayerJoined(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Plasma__AutohostPlayerJoined, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Plasma__AutohostPlayerJoined;
		if (size)
			*size = sizeof(_Plasma__AutohostPlayerJoined);
		((_Plasma__AutohostPlayerJoined*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _Plasma__AutohostPlayerJoined[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Plasma__AutohostPlayerJoined);
		for (int i = 0; i < n; i++)
			((_Plasma__AutohostPlayerJoined*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Plasma__AutohostPlayerJoined*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Plasma__AutohostPlayerJoined(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Plasma__AutohostPlayerJoined %p -> %p\n", q, p));
	*(_Plasma__AutohostPlayerJoined*)p = *(_Plasma__AutohostPlayerJoined*)q;
}

void Plasma__PlayerStats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__PlayerStats::Key = NULL;
	soap_default_double(soap, &this->Plasma__PlayerStats::Value);
	/* transient soap skipped */
}

void Plasma__PlayerStats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->Plasma__PlayerStats::Key);
	/* transient soap skipped */
}

int Plasma__PlayerStats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__PlayerStats);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__PlayerStats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__PlayerStats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__PlayerStats(struct soap *soap, const char *tag, int id, const Plasma__PlayerStats *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__PlayerStats), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Key", -1, &(a->Plasma__PlayerStats::Key), ""))
		return soap->error;
	if (soap_out_double(soap, "Plasma:Value", -1, &(a->Plasma__PlayerStats::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__PlayerStats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__PlayerStats(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__PlayerStats * SOAP_FMAC4 soap_get_Plasma__PlayerStats(struct soap *soap, Plasma__PlayerStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__PlayerStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__PlayerStats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__PlayerStats(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__PlayerStats * SOAP_FMAC4 soap_in_Plasma__PlayerStats(struct soap *soap, const char *tag, Plasma__PlayerStats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__PlayerStats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__PlayerStats, sizeof(Plasma__PlayerStats), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__PlayerStats)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__PlayerStats *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Key1 = 1, soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Key", &(a->Plasma__PlayerStats::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Plasma:Value", &(a->Plasma__PlayerStats::Value), "xsd:double"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__PlayerStats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__PlayerStats, 0, sizeof(Plasma__PlayerStats), 0, soap_copy_Plasma__PlayerStats);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__PlayerStats * SOAP_FMAC6 soap_new_Plasma__PlayerStats(struct soap *soap, int n)
{	return soap_instantiate_Plasma__PlayerStats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__PlayerStats(struct soap *soap, Plasma__PlayerStats *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__PlayerStats * SOAP_FMAC4 soap_instantiate_Plasma__PlayerStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__PlayerStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__PlayerStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__PlayerStats;
		if (size)
			*size = sizeof(Plasma__PlayerStats);
		((Plasma__PlayerStats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__PlayerStats[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__PlayerStats);
		for (int i = 0; i < n; i++)
			((Plasma__PlayerStats*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__PlayerStats*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__PlayerStats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__PlayerStats %p -> %p\n", q, p));
	*(Plasma__PlayerStats*)p = *(Plasma__PlayerStats*)q;
}

void Plasma__ArrayOfPlayerStats::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, &this->Plasma__ArrayOfPlayerStats::PlayerStats);
	/* transient soap skipped */
}

void Plasma__ArrayOfPlayerStats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, &this->Plasma__ArrayOfPlayerStats::PlayerStats);
	/* transient soap skipped */
}

int Plasma__ArrayOfPlayerStats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfPlayerStats);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfPlayerStats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfPlayerStats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfPlayerStats(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfPlayerStats *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfPlayerStats), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, "Plasma:PlayerStats", -1, &(a->Plasma__ArrayOfPlayerStats::PlayerStats), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfPlayerStats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfPlayerStats(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerStats * SOAP_FMAC4 soap_get_Plasma__ArrayOfPlayerStats(struct soap *soap, Plasma__ArrayOfPlayerStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfPlayerStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfPlayerStats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfPlayerStats(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerStats * SOAP_FMAC4 soap_in_Plasma__ArrayOfPlayerStats(struct soap *soap, const char *tag, Plasma__ArrayOfPlayerStats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfPlayerStats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfPlayerStats, sizeof(Plasma__ArrayOfPlayerStats), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfPlayerStats)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfPlayerStats *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, "Plasma:PlayerStats", &(a->Plasma__ArrayOfPlayerStats::PlayerStats), "Plasma:PlayerStats"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfPlayerStats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfPlayerStats, 0, sizeof(Plasma__ArrayOfPlayerStats), 0, soap_copy_Plasma__ArrayOfPlayerStats);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfPlayerStats * SOAP_FMAC6 soap_new_Plasma__ArrayOfPlayerStats(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfPlayerStats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfPlayerStats(struct soap *soap, Plasma__ArrayOfPlayerStats *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerStats * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfPlayerStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfPlayerStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfPlayerStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfPlayerStats;
		if (size)
			*size = sizeof(Plasma__ArrayOfPlayerStats);
		((Plasma__ArrayOfPlayerStats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfPlayerStats[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfPlayerStats);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfPlayerStats*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfPlayerStats*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfPlayerStats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfPlayerStats %p -> %p\n", q, p));
	*(Plasma__ArrayOfPlayerStats*)p = *(Plasma__ArrayOfPlayerStats*)q;
}

void Plasma__PlayerAward::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__PlayerAward::Award = NULL;
	this->Plasma__PlayerAward::Description = NULL;
	/* transient soap skipped */
}

void Plasma__PlayerAward::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->Plasma__PlayerAward::Award);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__PlayerAward::Description);
	/* transient soap skipped */
}

int Plasma__PlayerAward::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__PlayerAward);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__PlayerAward::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__PlayerAward(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__PlayerAward(struct soap *soap, const char *tag, int id, const Plasma__PlayerAward *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__PlayerAward), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Award", -1, &(a->Plasma__PlayerAward::Award), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Description", -1, &(a->Plasma__PlayerAward::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__PlayerAward::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__PlayerAward(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__PlayerAward * SOAP_FMAC4 soap_get_Plasma__PlayerAward(struct soap *soap, Plasma__PlayerAward *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__PlayerAward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__PlayerAward::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__PlayerAward(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__PlayerAward * SOAP_FMAC4 soap_in_Plasma__PlayerAward(struct soap *soap, const char *tag, Plasma__PlayerAward *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__PlayerAward *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__PlayerAward, sizeof(Plasma__PlayerAward), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__PlayerAward)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__PlayerAward *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Award1 = 1, soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Award1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Award", &(a->Plasma__PlayerAward::Award), "xsd:string"))
				{	soap_flag_Award1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Description", &(a->Plasma__PlayerAward::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__PlayerAward *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__PlayerAward, 0, sizeof(Plasma__PlayerAward), 0, soap_copy_Plasma__PlayerAward);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__PlayerAward * SOAP_FMAC6 soap_new_Plasma__PlayerAward(struct soap *soap, int n)
{	return soap_instantiate_Plasma__PlayerAward(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__PlayerAward(struct soap *soap, Plasma__PlayerAward *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__PlayerAward * SOAP_FMAC4 soap_instantiate_Plasma__PlayerAward(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__PlayerAward(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__PlayerAward, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__PlayerAward;
		if (size)
			*size = sizeof(Plasma__PlayerAward);
		((Plasma__PlayerAward*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__PlayerAward[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__PlayerAward);
		for (int i = 0; i < n; i++)
			((Plasma__PlayerAward*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__PlayerAward*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__PlayerAward(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__PlayerAward %p -> %p\n", q, p));
	*(Plasma__PlayerAward*)p = *(Plasma__PlayerAward*)q;
}

void Plasma__ArrayOfPlayerAward::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, &this->Plasma__ArrayOfPlayerAward::PlayerAward);
	/* transient soap skipped */
}

void Plasma__ArrayOfPlayerAward::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, &this->Plasma__ArrayOfPlayerAward::PlayerAward);
	/* transient soap skipped */
}

int Plasma__ArrayOfPlayerAward::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfPlayerAward);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfPlayerAward::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfPlayerAward(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfPlayerAward(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfPlayerAward *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfPlayerAward), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, "Plasma:PlayerAward", -1, &(a->Plasma__ArrayOfPlayerAward::PlayerAward), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfPlayerAward::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfPlayerAward(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerAward * SOAP_FMAC4 soap_get_Plasma__ArrayOfPlayerAward(struct soap *soap, Plasma__ArrayOfPlayerAward *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfPlayerAward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfPlayerAward::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfPlayerAward(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerAward * SOAP_FMAC4 soap_in_Plasma__ArrayOfPlayerAward(struct soap *soap, const char *tag, Plasma__ArrayOfPlayerAward *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfPlayerAward *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfPlayerAward, sizeof(Plasma__ArrayOfPlayerAward), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfPlayerAward)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfPlayerAward *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, "Plasma:PlayerAward", &(a->Plasma__ArrayOfPlayerAward::PlayerAward), "Plasma:PlayerAward"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfPlayerAward *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfPlayerAward, 0, sizeof(Plasma__ArrayOfPlayerAward), 0, soap_copy_Plasma__ArrayOfPlayerAward);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfPlayerAward * SOAP_FMAC6 soap_new_Plasma__ArrayOfPlayerAward(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfPlayerAward(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfPlayerAward(struct soap *soap, Plasma__ArrayOfPlayerAward *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerAward * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfPlayerAward(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfPlayerAward(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfPlayerAward, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfPlayerAward;
		if (size)
			*size = sizeof(Plasma__ArrayOfPlayerAward);
		((Plasma__ArrayOfPlayerAward*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfPlayerAward[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfPlayerAward);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfPlayerAward*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfPlayerAward*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfPlayerAward(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfPlayerAward %p -> %p\n", q, p));
	*(Plasma__ArrayOfPlayerAward*)p = *(Plasma__ArrayOfPlayerAward*)q;
}

void Plasma__BattlePlayerResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__BattlePlayerResult::AccountID);
	soap_default_int(soap, &this->Plasma__BattlePlayerResult::AllyNumber);
	this->Plasma__BattlePlayerResult::Awards = NULL;
	this->Plasma__BattlePlayerResult::CommanderType = NULL;
	soap_default_bool(soap, &this->Plasma__BattlePlayerResult::IsIngameReady);
	soap_default_bool(soap, &this->Plasma__BattlePlayerResult::IsSpectator);
	soap_default_bool(soap, &this->Plasma__BattlePlayerResult::IsVictoryTeam);
	this->Plasma__BattlePlayerResult::LoseTime = NULL;
	soap_default_int(soap, &this->Plasma__BattlePlayerResult::Rank);
	this->Plasma__BattlePlayerResult::Stats = NULL;
	/* transient soap skipped */
}

void Plasma__BattlePlayerResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__BattlePlayerResult::AccountID, SOAP_TYPE_int);
	soap_embedded(soap, &this->Plasma__BattlePlayerResult::AllyNumber, SOAP_TYPE_int);
	soap_serialize_PointerToPlasma__ArrayOfPlayerAward(soap, &this->Plasma__BattlePlayerResult::Awards);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattlePlayerResult::CommanderType);
	soap_serialize_PointerToint(soap, &this->Plasma__BattlePlayerResult::LoseTime);
	soap_embedded(soap, &this->Plasma__BattlePlayerResult::Rank, SOAP_TYPE_int);
	soap_serialize_PointerToPlasma__ArrayOfPlayerStats(soap, &this->Plasma__BattlePlayerResult::Stats);
	/* transient soap skipped */
}

int Plasma__BattlePlayerResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__BattlePlayerResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__BattlePlayerResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__BattlePlayerResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__BattlePlayerResult(struct soap *soap, const char *tag, int id, const Plasma__BattlePlayerResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__BattlePlayerResult), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AccountID", -1, &(a->Plasma__BattlePlayerResult::AccountID), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AllyNumber", -1, &(a->Plasma__BattlePlayerResult::AllyNumber), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfPlayerAward(soap, "Plasma:Awards", -1, &(a->Plasma__BattlePlayerResult::Awards), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:CommanderType", -1, &(a->Plasma__BattlePlayerResult::CommanderType), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsIngameReady", -1, &(a->Plasma__BattlePlayerResult::IsIngameReady), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsSpectator", -1, &(a->Plasma__BattlePlayerResult::IsSpectator), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsVictoryTeam", -1, &(a->Plasma__BattlePlayerResult::IsVictoryTeam), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "Plasma:LoseTime", -1, &(a->Plasma__BattlePlayerResult::LoseTime), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:Rank", -1, &(a->Plasma__BattlePlayerResult::Rank), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfPlayerStats(soap, "Plasma:Stats", -1, &(a->Plasma__BattlePlayerResult::Stats), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__BattlePlayerResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__BattlePlayerResult(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__BattlePlayerResult * SOAP_FMAC4 soap_get_Plasma__BattlePlayerResult(struct soap *soap, Plasma__BattlePlayerResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__BattlePlayerResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__BattlePlayerResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__BattlePlayerResult(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__BattlePlayerResult * SOAP_FMAC4 soap_in_Plasma__BattlePlayerResult(struct soap *soap, const char *tag, Plasma__BattlePlayerResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__BattlePlayerResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__BattlePlayerResult, sizeof(Plasma__BattlePlayerResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__BattlePlayerResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__BattlePlayerResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AccountID1 = 1, soap_flag_AllyNumber1 = 1, soap_flag_Awards1 = 1, soap_flag_CommanderType1 = 1, soap_flag_IsIngameReady1 = 1, soap_flag_IsSpectator1 = 1, soap_flag_IsVictoryTeam1 = 1, soap_flag_LoseTime1 = 1, soap_flag_Rank1 = 1, soap_flag_Stats1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AccountID", &(a->Plasma__BattlePlayerResult::AccountID), "xsd:int"))
				{	soap_flag_AccountID1--;
					continue;
				}
			if (soap_flag_AllyNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AllyNumber", &(a->Plasma__BattlePlayerResult::AllyNumber), "xsd:int"))
				{	soap_flag_AllyNumber1--;
					continue;
				}
			if (soap_flag_Awards1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfPlayerAward(soap, "Plasma:Awards", &(a->Plasma__BattlePlayerResult::Awards), "Plasma:ArrayOfPlayerAward"))
				{	soap_flag_Awards1--;
					continue;
				}
			if (soap_flag_CommanderType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:CommanderType", &(a->Plasma__BattlePlayerResult::CommanderType), "xsd:string"))
				{	soap_flag_CommanderType1--;
					continue;
				}
			if (soap_flag_IsIngameReady1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsIngameReady", &(a->Plasma__BattlePlayerResult::IsIngameReady), "xsd:boolean"))
				{	soap_flag_IsIngameReady1--;
					continue;
				}
			if (soap_flag_IsSpectator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsSpectator", &(a->Plasma__BattlePlayerResult::IsSpectator), "xsd:boolean"))
				{	soap_flag_IsSpectator1--;
					continue;
				}
			if (soap_flag_IsVictoryTeam1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsVictoryTeam", &(a->Plasma__BattlePlayerResult::IsVictoryTeam), "xsd:boolean"))
				{	soap_flag_IsVictoryTeam1--;
					continue;
				}
			if (soap_flag_LoseTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "Plasma:LoseTime", &(a->Plasma__BattlePlayerResult::LoseTime), "xsd:int"))
				{	soap_flag_LoseTime1--;
					continue;
				}
			if (soap_flag_Rank1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:Rank", &(a->Plasma__BattlePlayerResult::Rank), "xsd:int"))
				{	soap_flag_Rank1--;
					continue;
				}
			if (soap_flag_Stats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfPlayerStats(soap, "Plasma:Stats", &(a->Plasma__BattlePlayerResult::Stats), "Plasma:ArrayOfPlayerStats"))
				{	soap_flag_Stats1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__BattlePlayerResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__BattlePlayerResult, 0, sizeof(Plasma__BattlePlayerResult), 0, soap_copy_Plasma__BattlePlayerResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccountID1 > 0 || soap_flag_AllyNumber1 > 0 || soap_flag_IsIngameReady1 > 0 || soap_flag_IsSpectator1 > 0 || soap_flag_IsVictoryTeam1 > 0 || soap_flag_LoseTime1 > 0 || soap_flag_Rank1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__BattlePlayerResult * SOAP_FMAC6 soap_new_Plasma__BattlePlayerResult(struct soap *soap, int n)
{	return soap_instantiate_Plasma__BattlePlayerResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__BattlePlayerResult(struct soap *soap, Plasma__BattlePlayerResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__BattlePlayerResult * SOAP_FMAC4 soap_instantiate_Plasma__BattlePlayerResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__BattlePlayerResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__BattlePlayerResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__BattlePlayerResult;
		if (size)
			*size = sizeof(Plasma__BattlePlayerResult);
		((Plasma__BattlePlayerResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__BattlePlayerResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__BattlePlayerResult);
		for (int i = 0; i < n; i++)
			((Plasma__BattlePlayerResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__BattlePlayerResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__BattlePlayerResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__BattlePlayerResult %p -> %p\n", q, p));
	*(Plasma__BattlePlayerResult*)p = *(Plasma__BattlePlayerResult*)q;
}

void Plasma__ArrayOfBattlePlayerResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, &this->Plasma__ArrayOfBattlePlayerResult::BattlePlayerResult);
	/* transient soap skipped */
}

void Plasma__ArrayOfBattlePlayerResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, &this->Plasma__ArrayOfBattlePlayerResult::BattlePlayerResult);
	/* transient soap skipped */
}

int Plasma__ArrayOfBattlePlayerResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfBattlePlayerResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfBattlePlayerResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfBattlePlayerResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, "Plasma:BattlePlayerResult", -1, &(a->Plasma__ArrayOfBattlePlayerResult::BattlePlayerResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfBattlePlayerResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfBattlePlayerResult(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattlePlayerResult * SOAP_FMAC4 soap_get_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, Plasma__ArrayOfBattlePlayerResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfBattlePlayerResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfBattlePlayerResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfBattlePlayerResult(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattlePlayerResult * SOAP_FMAC4 soap_in_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, const char *tag, Plasma__ArrayOfBattlePlayerResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfBattlePlayerResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult, sizeof(Plasma__ArrayOfBattlePlayerResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfBattlePlayerResult *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, "Plasma:BattlePlayerResult", &(a->Plasma__ArrayOfBattlePlayerResult::BattlePlayerResult), "Plasma:BattlePlayerResult"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfBattlePlayerResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult, 0, sizeof(Plasma__ArrayOfBattlePlayerResult), 0, soap_copy_Plasma__ArrayOfBattlePlayerResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfBattlePlayerResult * SOAP_FMAC6 soap_new_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfBattlePlayerResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, Plasma__ArrayOfBattlePlayerResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfBattlePlayerResult * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfBattlePlayerResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfBattlePlayerResult;
		if (size)
			*size = sizeof(Plasma__ArrayOfBattlePlayerResult);
		((Plasma__ArrayOfBattlePlayerResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfBattlePlayerResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfBattlePlayerResult);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfBattlePlayerResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfBattlePlayerResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfBattlePlayerResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfBattlePlayerResult %p -> %p\n", q, p));
	*(Plasma__ArrayOfBattlePlayerResult*)p = *(Plasma__ArrayOfBattlePlayerResult*)q;
}

void Plasma__BattleResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__BattleResult::Duration);
	this->Plasma__BattleResult::EngineBattleID = NULL;
	this->Plasma__BattleResult::EngineVersion = NULL;
	this->Plasma__BattleResult::IngameStartTime = NULL;
	soap_default_bool(soap, &this->Plasma__BattleResult::IsBots);
	soap_default_bool(soap, &this->Plasma__BattleResult::IsMission);
	this->Plasma__BattleResult::Map = NULL;
	this->Plasma__BattleResult::Mod = NULL;
	this->Plasma__BattleResult::ReplayName = NULL;
	soap_default_time(soap, &this->Plasma__BattleResult::StartTime);
	this->Plasma__BattleResult::Title = NULL;
	/* transient soap skipped */
}

void Plasma__BattleResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__BattleResult::Duration, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::EngineBattleID);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::EngineVersion);
	soap_serialize_PointerTotime(soap, &this->Plasma__BattleResult::IngameStartTime);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::Map);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::Mod);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::ReplayName);
	soap_embedded(soap, &this->Plasma__BattleResult::StartTime, SOAP_TYPE_time);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BattleResult::Title);
	/* transient soap skipped */
}

int Plasma__BattleResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__BattleResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__BattleResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__BattleResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__BattleResult(struct soap *soap, const char *tag, int id, const Plasma__BattleResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__BattleResult), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:Duration", -1, &(a->Plasma__BattleResult::Duration), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:EngineBattleID", -1, &(a->Plasma__BattleResult::EngineBattleID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:EngineVersion", -1, &(a->Plasma__BattleResult::EngineVersion), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "Plasma:IngameStartTime", -1, &(a->Plasma__BattleResult::IngameStartTime), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsBots", -1, &(a->Plasma__BattleResult::IsBots), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsMission", -1, &(a->Plasma__BattleResult::IsMission), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Map", -1, &(a->Plasma__BattleResult::Map), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Mod", -1, &(a->Plasma__BattleResult::Mod), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:ReplayName", -1, &(a->Plasma__BattleResult::ReplayName), ""))
		return soap->error;
	if (soap_out_time(soap, "Plasma:StartTime", -1, &(a->Plasma__BattleResult::StartTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Title", -1, &(a->Plasma__BattleResult::Title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__BattleResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__BattleResult(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__BattleResult * SOAP_FMAC4 soap_get_Plasma__BattleResult(struct soap *soap, Plasma__BattleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__BattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__BattleResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__BattleResult(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__BattleResult * SOAP_FMAC4 soap_in_Plasma__BattleResult(struct soap *soap, const char *tag, Plasma__BattleResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__BattleResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__BattleResult, sizeof(Plasma__BattleResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__BattleResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__BattleResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Duration1 = 1, soap_flag_EngineBattleID1 = 1, soap_flag_EngineVersion1 = 1, soap_flag_IngameStartTime1 = 1, soap_flag_IsBots1 = 1, soap_flag_IsMission1 = 1, soap_flag_Map1 = 1, soap_flag_Mod1 = 1, soap_flag_ReplayName1 = 1, soap_flag_StartTime1 = 1, soap_flag_Title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:Duration", &(a->Plasma__BattleResult::Duration), "xsd:int"))
				{	soap_flag_Duration1--;
					continue;
				}
			if (soap_flag_EngineBattleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:EngineBattleID", &(a->Plasma__BattleResult::EngineBattleID), "xsd:string"))
				{	soap_flag_EngineBattleID1--;
					continue;
				}
			if (soap_flag_EngineVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:EngineVersion", &(a->Plasma__BattleResult::EngineVersion), "xsd:string"))
				{	soap_flag_EngineVersion1--;
					continue;
				}
			if (soap_flag_IngameStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "Plasma:IngameStartTime", &(a->Plasma__BattleResult::IngameStartTime), "xsd:dateTime"))
				{	soap_flag_IngameStartTime1--;
					continue;
				}
			if (soap_flag_IsBots1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsBots", &(a->Plasma__BattleResult::IsBots), "xsd:boolean"))
				{	soap_flag_IsBots1--;
					continue;
				}
			if (soap_flag_IsMission1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsMission", &(a->Plasma__BattleResult::IsMission), "xsd:boolean"))
				{	soap_flag_IsMission1--;
					continue;
				}
			if (soap_flag_Map1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Map", &(a->Plasma__BattleResult::Map), "xsd:string"))
				{	soap_flag_Map1--;
					continue;
				}
			if (soap_flag_Mod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Mod", &(a->Plasma__BattleResult::Mod), "xsd:string"))
				{	soap_flag_Mod1--;
					continue;
				}
			if (soap_flag_ReplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:ReplayName", &(a->Plasma__BattleResult::ReplayName), "xsd:string"))
				{	soap_flag_ReplayName1--;
					continue;
				}
			if (soap_flag_StartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Plasma:StartTime", &(a->Plasma__BattleResult::StartTime), "xsd:dateTime"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Title", &(a->Plasma__BattleResult::Title), "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__BattleResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__BattleResult, 0, sizeof(Plasma__BattleResult), 0, soap_copy_Plasma__BattleResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Duration1 > 0 || soap_flag_IngameStartTime1 > 0 || soap_flag_IsBots1 > 0 || soap_flag_IsMission1 > 0 || soap_flag_StartTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__BattleResult * SOAP_FMAC6 soap_new_Plasma__BattleResult(struct soap *soap, int n)
{	return soap_instantiate_Plasma__BattleResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__BattleResult(struct soap *soap, Plasma__BattleResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__BattleResult * SOAP_FMAC4 soap_instantiate_Plasma__BattleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__BattleResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__BattleResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__BattleResult;
		if (size)
			*size = sizeof(Plasma__BattleResult);
		((Plasma__BattleResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__BattleResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__BattleResult);
		for (int i = 0; i < n; i++)
			((Plasma__BattleResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__BattleResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__BattleResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__BattleResult %p -> %p\n", q, p));
	*(Plasma__BattleResult*)p = *(Plasma__BattleResult*)q;
}

void Plasma__UserCustomParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__UserCustomParameters::AccountID);
	this->Plasma__UserCustomParameters::Parameters = NULL;
	/* transient soap skipped */
}

void Plasma__UserCustomParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__UserCustomParameters::AccountID, SOAP_TYPE_int);
	soap_serialize_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, &this->Plasma__UserCustomParameters::Parameters);
	/* transient soap skipped */
}

int Plasma__UserCustomParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__UserCustomParameters);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__UserCustomParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__UserCustomParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__UserCustomParameters(struct soap *soap, const char *tag, int id, const Plasma__UserCustomParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__UserCustomParameters), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AccountID", -1, &(a->Plasma__UserCustomParameters::AccountID), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, "Plasma:Parameters", -1, &(a->Plasma__UserCustomParameters::Parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__UserCustomParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__UserCustomParameters(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__UserCustomParameters * SOAP_FMAC4 soap_get_Plasma__UserCustomParameters(struct soap *soap, Plasma__UserCustomParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__UserCustomParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__UserCustomParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__UserCustomParameters(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__UserCustomParameters * SOAP_FMAC4 soap_in_Plasma__UserCustomParameters(struct soap *soap, const char *tag, Plasma__UserCustomParameters *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__UserCustomParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__UserCustomParameters, sizeof(Plasma__UserCustomParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__UserCustomParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__UserCustomParameters *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AccountID1 = 1, soap_flag_Parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AccountID", &(a->Plasma__UserCustomParameters::AccountID), "xsd:int"))
				{	soap_flag_AccountID1--;
					continue;
				}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, "Plasma:Parameters", &(a->Plasma__UserCustomParameters::Parameters), "Plasma:ArrayOfScriptKeyValuePair"))
				{	soap_flag_Parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__UserCustomParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__UserCustomParameters, 0, sizeof(Plasma__UserCustomParameters), 0, soap_copy_Plasma__UserCustomParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccountID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__UserCustomParameters * SOAP_FMAC6 soap_new_Plasma__UserCustomParameters(struct soap *soap, int n)
{	return soap_instantiate_Plasma__UserCustomParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__UserCustomParameters(struct soap *soap, Plasma__UserCustomParameters *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__UserCustomParameters * SOAP_FMAC4 soap_instantiate_Plasma__UserCustomParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__UserCustomParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__UserCustomParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__UserCustomParameters;
		if (size)
			*size = sizeof(Plasma__UserCustomParameters);
		((Plasma__UserCustomParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__UserCustomParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__UserCustomParameters);
		for (int i = 0; i < n; i++)
			((Plasma__UserCustomParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__UserCustomParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__UserCustomParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__UserCustomParameters %p -> %p\n", q, p));
	*(Plasma__UserCustomParameters*)p = *(Plasma__UserCustomParameters*)q;
}

void Plasma__ArrayOfUserCustomParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, &this->Plasma__ArrayOfUserCustomParameters::UserCustomParameters);
	/* transient soap skipped */
}

void Plasma__ArrayOfUserCustomParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, &this->Plasma__ArrayOfUserCustomParameters::UserCustomParameters);
	/* transient soap skipped */
}

int Plasma__ArrayOfUserCustomParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfUserCustomParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfUserCustomParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfUserCustomParameters(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfUserCustomParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, "Plasma:UserCustomParameters", -1, &(a->Plasma__ArrayOfUserCustomParameters::UserCustomParameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfUserCustomParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfUserCustomParameters(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfUserCustomParameters * SOAP_FMAC4 soap_get_Plasma__ArrayOfUserCustomParameters(struct soap *soap, Plasma__ArrayOfUserCustomParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfUserCustomParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfUserCustomParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfUserCustomParameters(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfUserCustomParameters * SOAP_FMAC4 soap_in_Plasma__ArrayOfUserCustomParameters(struct soap *soap, const char *tag, Plasma__ArrayOfUserCustomParameters *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfUserCustomParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters, sizeof(Plasma__ArrayOfUserCustomParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfUserCustomParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfUserCustomParameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, "Plasma:UserCustomParameters", &(a->Plasma__ArrayOfUserCustomParameters::UserCustomParameters), "Plasma:UserCustomParameters"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfUserCustomParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters, 0, sizeof(Plasma__ArrayOfUserCustomParameters), 0, soap_copy_Plasma__ArrayOfUserCustomParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfUserCustomParameters * SOAP_FMAC6 soap_new_Plasma__ArrayOfUserCustomParameters(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfUserCustomParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfUserCustomParameters(struct soap *soap, Plasma__ArrayOfUserCustomParameters *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfUserCustomParameters * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfUserCustomParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfUserCustomParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfUserCustomParameters;
		if (size)
			*size = sizeof(Plasma__ArrayOfUserCustomParameters);
		((Plasma__ArrayOfUserCustomParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfUserCustomParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfUserCustomParameters);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfUserCustomParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfUserCustomParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfUserCustomParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfUserCustomParameters %p -> %p\n", q, p));
	*(Plasma__ArrayOfUserCustomParameters*)p = *(Plasma__ArrayOfUserCustomParameters*)q;
}

void Plasma__ScriptKeyValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__ScriptKeyValuePair::Key = NULL;
	this->Plasma__ScriptKeyValuePair::Value = NULL;
	/* transient soap skipped */
}

void Plasma__ScriptKeyValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptKeyValuePair::Key);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptKeyValuePair::Value);
	/* transient soap skipped */
}

int Plasma__ScriptKeyValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ScriptKeyValuePair);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ScriptKeyValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ScriptKeyValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ScriptKeyValuePair(struct soap *soap, const char *tag, int id, const Plasma__ScriptKeyValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ScriptKeyValuePair), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Key", -1, &(a->Plasma__ScriptKeyValuePair::Key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Value", -1, &(a->Plasma__ScriptKeyValuePair::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ScriptKeyValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ScriptKeyValuePair(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ScriptKeyValuePair * SOAP_FMAC4 soap_get_Plasma__ScriptKeyValuePair(struct soap *soap, Plasma__ScriptKeyValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ScriptKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ScriptKeyValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ScriptKeyValuePair(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ScriptKeyValuePair * SOAP_FMAC4 soap_in_Plasma__ScriptKeyValuePair(struct soap *soap, const char *tag, Plasma__ScriptKeyValuePair *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ScriptKeyValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ScriptKeyValuePair, sizeof(Plasma__ScriptKeyValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ScriptKeyValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ScriptKeyValuePair *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Key1 = 1, soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Key", &(a->Plasma__ScriptKeyValuePair::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Value", &(a->Plasma__ScriptKeyValuePair::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ScriptKeyValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ScriptKeyValuePair, 0, sizeof(Plasma__ScriptKeyValuePair), 0, soap_copy_Plasma__ScriptKeyValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ScriptKeyValuePair * SOAP_FMAC6 soap_new_Plasma__ScriptKeyValuePair(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ScriptKeyValuePair(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ScriptKeyValuePair(struct soap *soap, Plasma__ScriptKeyValuePair *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ScriptKeyValuePair * SOAP_FMAC4 soap_instantiate_Plasma__ScriptKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ScriptKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ScriptKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ScriptKeyValuePair;
		if (size)
			*size = sizeof(Plasma__ScriptKeyValuePair);
		((Plasma__ScriptKeyValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ScriptKeyValuePair[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ScriptKeyValuePair);
		for (int i = 0; i < n; i++)
			((Plasma__ScriptKeyValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ScriptKeyValuePair*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ScriptKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ScriptKeyValuePair %p -> %p\n", q, p));
	*(Plasma__ScriptKeyValuePair*)p = *(Plasma__ScriptKeyValuePair*)q;
}

void Plasma__ArrayOfScriptKeyValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, &this->Plasma__ArrayOfScriptKeyValuePair::ScriptKeyValuePair);
	/* transient soap skipped */
}

void Plasma__ArrayOfScriptKeyValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, &this->Plasma__ArrayOfScriptKeyValuePair::ScriptKeyValuePair);
	/* transient soap skipped */
}

int Plasma__ArrayOfScriptKeyValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfScriptKeyValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfScriptKeyValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfScriptKeyValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, "Plasma:ScriptKeyValuePair", -1, &(a->Plasma__ArrayOfScriptKeyValuePair::ScriptKeyValuePair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfScriptKeyValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfScriptKeyValuePair(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfScriptKeyValuePair * SOAP_FMAC4 soap_get_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, Plasma__ArrayOfScriptKeyValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfScriptKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfScriptKeyValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfScriptKeyValuePair(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfScriptKeyValuePair * SOAP_FMAC4 soap_in_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, const char *tag, Plasma__ArrayOfScriptKeyValuePair *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfScriptKeyValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair, sizeof(Plasma__ArrayOfScriptKeyValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfScriptKeyValuePair *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, "Plasma:ScriptKeyValuePair", &(a->Plasma__ArrayOfScriptKeyValuePair::ScriptKeyValuePair), "Plasma:ScriptKeyValuePair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfScriptKeyValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair, 0, sizeof(Plasma__ArrayOfScriptKeyValuePair), 0, soap_copy_Plasma__ArrayOfScriptKeyValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfScriptKeyValuePair * SOAP_FMAC6 soap_new_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfScriptKeyValuePair(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, Plasma__ArrayOfScriptKeyValuePair *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfScriptKeyValuePair * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfScriptKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfScriptKeyValuePair;
		if (size)
			*size = sizeof(Plasma__ArrayOfScriptKeyValuePair);
		((Plasma__ArrayOfScriptKeyValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfScriptKeyValuePair[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfScriptKeyValuePair);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfScriptKeyValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfScriptKeyValuePair*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfScriptKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfScriptKeyValuePair %p -> %p\n", q, p));
	*(Plasma__ArrayOfScriptKeyValuePair*)p = *(Plasma__ArrayOfScriptKeyValuePair*)q;
}

void Plasma__SpringBattleStartSetup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__SpringBattleStartSetup::ModOptions = NULL;
	this->Plasma__SpringBattleStartSetup::UserParameters = NULL;
	/* transient soap skipped */
}

void Plasma__SpringBattleStartSetup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, &this->Plasma__SpringBattleStartSetup::ModOptions);
	soap_serialize_PointerToPlasma__ArrayOfUserCustomParameters(soap, &this->Plasma__SpringBattleStartSetup::UserParameters);
	/* transient soap skipped */
}

int Plasma__SpringBattleStartSetup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__SpringBattleStartSetup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__SpringBattleStartSetup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__SpringBattleStartSetup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__SpringBattleStartSetup(struct soap *soap, const char *tag, int id, const Plasma__SpringBattleStartSetup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__SpringBattleStartSetup), type))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, "Plasma:ModOptions", -1, &(a->Plasma__SpringBattleStartSetup::ModOptions), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfUserCustomParameters(soap, "Plasma:UserParameters", -1, &(a->Plasma__SpringBattleStartSetup::UserParameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__SpringBattleStartSetup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__SpringBattleStartSetup(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__SpringBattleStartSetup * SOAP_FMAC4 soap_get_Plasma__SpringBattleStartSetup(struct soap *soap, Plasma__SpringBattleStartSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__SpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__SpringBattleStartSetup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__SpringBattleStartSetup(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__SpringBattleStartSetup * SOAP_FMAC4 soap_in_Plasma__SpringBattleStartSetup(struct soap *soap, const char *tag, Plasma__SpringBattleStartSetup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__SpringBattleStartSetup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__SpringBattleStartSetup, sizeof(Plasma__SpringBattleStartSetup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__SpringBattleStartSetup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__SpringBattleStartSetup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ModOptions1 = 1, soap_flag_UserParameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ModOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, "Plasma:ModOptions", &(a->Plasma__SpringBattleStartSetup::ModOptions), "Plasma:ArrayOfScriptKeyValuePair"))
				{	soap_flag_ModOptions1--;
					continue;
				}
			if (soap_flag_UserParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfUserCustomParameters(soap, "Plasma:UserParameters", &(a->Plasma__SpringBattleStartSetup::UserParameters), "Plasma:ArrayOfUserCustomParameters"))
				{	soap_flag_UserParameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__SpringBattleStartSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__SpringBattleStartSetup, 0, sizeof(Plasma__SpringBattleStartSetup), 0, soap_copy_Plasma__SpringBattleStartSetup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__SpringBattleStartSetup * SOAP_FMAC6 soap_new_Plasma__SpringBattleStartSetup(struct soap *soap, int n)
{	return soap_instantiate_Plasma__SpringBattleStartSetup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__SpringBattleStartSetup(struct soap *soap, Plasma__SpringBattleStartSetup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__SpringBattleStartSetup * SOAP_FMAC4 soap_instantiate_Plasma__SpringBattleStartSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__SpringBattleStartSetup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__SpringBattleStartSetup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__SpringBattleStartSetup;
		if (size)
			*size = sizeof(Plasma__SpringBattleStartSetup);
		((Plasma__SpringBattleStartSetup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__SpringBattleStartSetup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__SpringBattleStartSetup);
		for (int i = 0; i < n; i++)
			((Plasma__SpringBattleStartSetup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__SpringBattleStartSetup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__SpringBattleStartSetup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__SpringBattleStartSetup %p -> %p\n", q, p));
	*(Plasma__SpringBattleStartSetup*)p = *(Plasma__SpringBattleStartSetup*)q;
}

void Plasma__BattleStartSetupPlayer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__BattleStartSetupPlayer::AccountID);
	soap_default_int(soap, &this->Plasma__BattleStartSetupPlayer::AllyTeam);
	soap_default_bool(soap, &this->Plasma__BattleStartSetupPlayer::IsSpectator);
	soap_default_int(soap, &this->Plasma__BattleStartSetupPlayer::SpringPlayerID);
	/* transient soap skipped */
}

void Plasma__BattleStartSetupPlayer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__BattleStartSetupPlayer::AccountID, SOAP_TYPE_int);
	soap_embedded(soap, &this->Plasma__BattleStartSetupPlayer::AllyTeam, SOAP_TYPE_int);
	soap_embedded(soap, &this->Plasma__BattleStartSetupPlayer::SpringPlayerID, SOAP_TYPE_int);
	/* transient soap skipped */
}

int Plasma__BattleStartSetupPlayer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__BattleStartSetupPlayer);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__BattleStartSetupPlayer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__BattleStartSetupPlayer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, int id, const Plasma__BattleStartSetupPlayer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__BattleStartSetupPlayer), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AccountID", -1, &(a->Plasma__BattleStartSetupPlayer::AccountID), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AllyTeam", -1, &(a->Plasma__BattleStartSetupPlayer::AllyTeam), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:IsSpectator", -1, &(a->Plasma__BattleStartSetupPlayer::IsSpectator), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:SpringPlayerID", -1, &(a->Plasma__BattleStartSetupPlayer::SpringPlayerID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__BattleStartSetupPlayer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__BattleStartSetupPlayer(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__BattleStartSetupPlayer * SOAP_FMAC4 soap_get_Plasma__BattleStartSetupPlayer(struct soap *soap, Plasma__BattleStartSetupPlayer *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__BattleStartSetupPlayer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__BattleStartSetupPlayer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__BattleStartSetupPlayer(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__BattleStartSetupPlayer * SOAP_FMAC4 soap_in_Plasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, Plasma__BattleStartSetupPlayer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__BattleStartSetupPlayer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__BattleStartSetupPlayer, sizeof(Plasma__BattleStartSetupPlayer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__BattleStartSetupPlayer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__BattleStartSetupPlayer *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AccountID1 = 1, soap_flag_AllyTeam1 = 1, soap_flag_IsSpectator1 = 1, soap_flag_SpringPlayerID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AccountID", &(a->Plasma__BattleStartSetupPlayer::AccountID), "xsd:int"))
				{	soap_flag_AccountID1--;
					continue;
				}
			if (soap_flag_AllyTeam1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AllyTeam", &(a->Plasma__BattleStartSetupPlayer::AllyTeam), "xsd:int"))
				{	soap_flag_AllyTeam1--;
					continue;
				}
			if (soap_flag_IsSpectator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:IsSpectator", &(a->Plasma__BattleStartSetupPlayer::IsSpectator), "xsd:boolean"))
				{	soap_flag_IsSpectator1--;
					continue;
				}
			if (soap_flag_SpringPlayerID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:SpringPlayerID", &(a->Plasma__BattleStartSetupPlayer::SpringPlayerID), "xsd:int"))
				{	soap_flag_SpringPlayerID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__BattleStartSetupPlayer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__BattleStartSetupPlayer, 0, sizeof(Plasma__BattleStartSetupPlayer), 0, soap_copy_Plasma__BattleStartSetupPlayer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccountID1 > 0 || soap_flag_AllyTeam1 > 0 || soap_flag_IsSpectator1 > 0 || soap_flag_SpringPlayerID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__BattleStartSetupPlayer * SOAP_FMAC6 soap_new_Plasma__BattleStartSetupPlayer(struct soap *soap, int n)
{	return soap_instantiate_Plasma__BattleStartSetupPlayer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__BattleStartSetupPlayer(struct soap *soap, Plasma__BattleStartSetupPlayer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__BattleStartSetupPlayer * SOAP_FMAC4 soap_instantiate_Plasma__BattleStartSetupPlayer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__BattleStartSetupPlayer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__BattleStartSetupPlayer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__BattleStartSetupPlayer;
		if (size)
			*size = sizeof(Plasma__BattleStartSetupPlayer);
		((Plasma__BattleStartSetupPlayer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__BattleStartSetupPlayer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__BattleStartSetupPlayer);
		for (int i = 0; i < n; i++)
			((Plasma__BattleStartSetupPlayer*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__BattleStartSetupPlayer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__BattleStartSetupPlayer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__BattleStartSetupPlayer %p -> %p\n", q, p));
	*(Plasma__BattleStartSetupPlayer*)p = *(Plasma__BattleStartSetupPlayer*)q;
}

void Plasma__ArrayOfBattleStartSetupPlayer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, &this->Plasma__ArrayOfBattleStartSetupPlayer::BattleStartSetupPlayer);
	/* transient soap skipped */
}

void Plasma__ArrayOfBattleStartSetupPlayer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, &this->Plasma__ArrayOfBattleStartSetupPlayer::BattleStartSetupPlayer);
	/* transient soap skipped */
}

int Plasma__ArrayOfBattleStartSetupPlayer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfBattleStartSetupPlayer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfBattleStartSetupPlayer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfBattleStartSetupPlayer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, "Plasma:BattleStartSetupPlayer", -1, &(a->Plasma__ArrayOfBattleStartSetupPlayer::BattleStartSetupPlayer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfBattleStartSetupPlayer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfBattleStartSetupPlayer(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattleStartSetupPlayer * SOAP_FMAC4 soap_get_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, Plasma__ArrayOfBattleStartSetupPlayer *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfBattleStartSetupPlayer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfBattleStartSetupPlayer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfBattleStartSetupPlayer(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattleStartSetupPlayer * SOAP_FMAC4 soap_in_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, const char *tag, Plasma__ArrayOfBattleStartSetupPlayer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfBattleStartSetupPlayer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer, sizeof(Plasma__ArrayOfBattleStartSetupPlayer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfBattleStartSetupPlayer *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, "Plasma:BattleStartSetupPlayer", &(a->Plasma__ArrayOfBattleStartSetupPlayer::BattleStartSetupPlayer), "Plasma:BattleStartSetupPlayer"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfBattleStartSetupPlayer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer, 0, sizeof(Plasma__ArrayOfBattleStartSetupPlayer), 0, soap_copy_Plasma__ArrayOfBattleStartSetupPlayer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfBattleStartSetupPlayer * SOAP_FMAC6 soap_new_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfBattleStartSetupPlayer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, Plasma__ArrayOfBattleStartSetupPlayer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfBattleStartSetupPlayer * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfBattleStartSetupPlayer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfBattleStartSetupPlayer;
		if (size)
			*size = sizeof(Plasma__ArrayOfBattleStartSetupPlayer);
		((Plasma__ArrayOfBattleStartSetupPlayer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfBattleStartSetupPlayer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfBattleStartSetupPlayer);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfBattleStartSetupPlayer*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfBattleStartSetupPlayer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfBattleStartSetupPlayer %p -> %p\n", q, p));
	*(Plasma__ArrayOfBattleStartSetupPlayer*)p = *(Plasma__ArrayOfBattleStartSetupPlayer*)q;
}

void Plasma__ScriptMissionData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__ScriptMissionData::ManualDependencies = NULL;
	this->Plasma__ScriptMissionData::MapName = NULL;
	this->Plasma__ScriptMissionData::ModTag = NULL;
	this->Plasma__ScriptMissionData::Name = NULL;
	this->Plasma__ScriptMissionData::StartScript = NULL;
	/* transient soap skipped */
}

void Plasma__ScriptMissionData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->Plasma__ScriptMissionData::ManualDependencies);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptMissionData::MapName);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptMissionData::ModTag);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptMissionData::Name);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ScriptMissionData::StartScript);
	/* transient soap skipped */
}

int Plasma__ScriptMissionData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ScriptMissionData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ScriptMissionData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ScriptMissionData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ScriptMissionData(struct soap *soap, const char *tag, int id, const Plasma__ScriptMissionData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ScriptMissionData), type))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:ManualDependencies", -1, &(a->Plasma__ScriptMissionData::ManualDependencies), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:MapName", -1, &(a->Plasma__ScriptMissionData::MapName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:ModTag", -1, &(a->Plasma__ScriptMissionData::ModTag), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Name", -1, &(a->Plasma__ScriptMissionData::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:StartScript", -1, &(a->Plasma__ScriptMissionData::StartScript), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ScriptMissionData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ScriptMissionData(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ScriptMissionData * SOAP_FMAC4 soap_get_Plasma__ScriptMissionData(struct soap *soap, Plasma__ScriptMissionData *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ScriptMissionData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ScriptMissionData(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ScriptMissionData * SOAP_FMAC4 soap_in_Plasma__ScriptMissionData(struct soap *soap, const char *tag, Plasma__ScriptMissionData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ScriptMissionData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ScriptMissionData, sizeof(Plasma__ScriptMissionData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ScriptMissionData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ScriptMissionData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ManualDependencies1 = 1, soap_flag_MapName1 = 1, soap_flag_ModTag1 = 1, soap_flag_Name1 = 1, soap_flag_StartScript1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ManualDependencies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:ManualDependencies", &(a->Plasma__ScriptMissionData::ManualDependencies), "Plasma:ArrayOfString"))
				{	soap_flag_ManualDependencies1--;
					continue;
				}
			if (soap_flag_MapName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:MapName", &(a->Plasma__ScriptMissionData::MapName), "xsd:string"))
				{	soap_flag_MapName1--;
					continue;
				}
			if (soap_flag_ModTag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:ModTag", &(a->Plasma__ScriptMissionData::ModTag), "xsd:string"))
				{	soap_flag_ModTag1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Name", &(a->Plasma__ScriptMissionData::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_StartScript1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:StartScript", &(a->Plasma__ScriptMissionData::StartScript), "xsd:string"))
				{	soap_flag_StartScript1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ScriptMissionData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ScriptMissionData, 0, sizeof(Plasma__ScriptMissionData), 0, soap_copy_Plasma__ScriptMissionData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ScriptMissionData * SOAP_FMAC6 soap_new_Plasma__ScriptMissionData(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ScriptMissionData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ScriptMissionData(struct soap *soap, Plasma__ScriptMissionData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ScriptMissionData * SOAP_FMAC4 soap_instantiate_Plasma__ScriptMissionData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ScriptMissionData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ScriptMissionData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ScriptMissionData;
		if (size)
			*size = sizeof(Plasma__ScriptMissionData);
		((Plasma__ScriptMissionData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ScriptMissionData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ScriptMissionData);
		for (int i = 0; i < n; i++)
			((Plasma__ScriptMissionData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ScriptMissionData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ScriptMissionData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ScriptMissionData %p -> %p\n", q, p));
	*(Plasma__ScriptMissionData*)p = *(Plasma__ScriptMissionData*)q;
}

void Plasma__ArrayOfResourceData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, &this->Plasma__ArrayOfResourceData::ResourceData);
	/* transient soap skipped */
}

void Plasma__ArrayOfResourceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, &this->Plasma__ArrayOfResourceData::ResourceData);
	/* transient soap skipped */
}

int Plasma__ArrayOfResourceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfResourceData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfResourceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfResourceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfResourceData(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfResourceData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfResourceData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, "Plasma:ResourceData", -1, &(a->Plasma__ArrayOfResourceData::ResourceData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfResourceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfResourceData(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfResourceData * SOAP_FMAC4 soap_get_Plasma__ArrayOfResourceData(struct soap *soap, Plasma__ArrayOfResourceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfResourceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfResourceData(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfResourceData * SOAP_FMAC4 soap_in_Plasma__ArrayOfResourceData(struct soap *soap, const char *tag, Plasma__ArrayOfResourceData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfResourceData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfResourceData, sizeof(Plasma__ArrayOfResourceData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfResourceData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfResourceData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, "Plasma:ResourceData", &(a->Plasma__ArrayOfResourceData::ResourceData), "Plasma:ResourceData"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfResourceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfResourceData, 0, sizeof(Plasma__ArrayOfResourceData), 0, soap_copy_Plasma__ArrayOfResourceData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfResourceData * SOAP_FMAC6 soap_new_Plasma__ArrayOfResourceData(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfResourceData(struct soap *soap, Plasma__ArrayOfResourceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfResourceData * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfResourceData;
		if (size)
			*size = sizeof(Plasma__ArrayOfResourceData);
		((Plasma__ArrayOfResourceData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfResourceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfResourceData);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfResourceData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfResourceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfResourceData %p -> %p\n", q, p));
	*(Plasma__ArrayOfResourceData*)p = *(Plasma__ArrayOfResourceData*)q;
}

void Plasma__SpringHashEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__SpringHashEntry::SpringHash);
	this->Plasma__SpringHashEntry::SpringVersion = NULL;
	/* transient soap skipped */
}

void Plasma__SpringHashEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__SpringHashEntry::SpringHash, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__SpringHashEntry::SpringVersion);
	/* transient soap skipped */
}

int Plasma__SpringHashEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__SpringHashEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__SpringHashEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__SpringHashEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__SpringHashEntry(struct soap *soap, const char *tag, int id, const Plasma__SpringHashEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__SpringHashEntry), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:SpringHash", -1, &(a->Plasma__SpringHashEntry::SpringHash), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:SpringVersion", -1, &(a->Plasma__SpringHashEntry::SpringVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__SpringHashEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__SpringHashEntry(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__SpringHashEntry * SOAP_FMAC4 soap_get_Plasma__SpringHashEntry(struct soap *soap, Plasma__SpringHashEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__SpringHashEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__SpringHashEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__SpringHashEntry(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__SpringHashEntry * SOAP_FMAC4 soap_in_Plasma__SpringHashEntry(struct soap *soap, const char *tag, Plasma__SpringHashEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__SpringHashEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__SpringHashEntry, sizeof(Plasma__SpringHashEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__SpringHashEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__SpringHashEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_SpringHash1 = 1, soap_flag_SpringVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SpringHash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:SpringHash", &(a->Plasma__SpringHashEntry::SpringHash), "xsd:int"))
				{	soap_flag_SpringHash1--;
					continue;
				}
			if (soap_flag_SpringVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:SpringVersion", &(a->Plasma__SpringHashEntry::SpringVersion), "xsd:string"))
				{	soap_flag_SpringVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__SpringHashEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__SpringHashEntry, 0, sizeof(Plasma__SpringHashEntry), 0, soap_copy_Plasma__SpringHashEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SpringHash1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__SpringHashEntry * SOAP_FMAC6 soap_new_Plasma__SpringHashEntry(struct soap *soap, int n)
{	return soap_instantiate_Plasma__SpringHashEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__SpringHashEntry(struct soap *soap, Plasma__SpringHashEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__SpringHashEntry * SOAP_FMAC4 soap_instantiate_Plasma__SpringHashEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__SpringHashEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__SpringHashEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__SpringHashEntry;
		if (size)
			*size = sizeof(Plasma__SpringHashEntry);
		((Plasma__SpringHashEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__SpringHashEntry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__SpringHashEntry);
		for (int i = 0; i < n; i++)
			((Plasma__SpringHashEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__SpringHashEntry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__SpringHashEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__SpringHashEntry %p -> %p\n", q, p));
	*(Plasma__SpringHashEntry*)p = *(Plasma__SpringHashEntry*)q;
}

void Plasma__ArrayOfSpringHashEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, &this->Plasma__ArrayOfSpringHashEntry::SpringHashEntry);
	/* transient soap skipped */
}

void Plasma__ArrayOfSpringHashEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, &this->Plasma__ArrayOfSpringHashEntry::SpringHashEntry);
	/* transient soap skipped */
}

int Plasma__ArrayOfSpringHashEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfSpringHashEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfSpringHashEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfSpringHashEntry(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfSpringHashEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, "Plasma:SpringHashEntry", -1, &(a->Plasma__ArrayOfSpringHashEntry::SpringHashEntry), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfSpringHashEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfSpringHashEntry(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfSpringHashEntry * SOAP_FMAC4 soap_get_Plasma__ArrayOfSpringHashEntry(struct soap *soap, Plasma__ArrayOfSpringHashEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfSpringHashEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfSpringHashEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfSpringHashEntry(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfSpringHashEntry * SOAP_FMAC4 soap_in_Plasma__ArrayOfSpringHashEntry(struct soap *soap, const char *tag, Plasma__ArrayOfSpringHashEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfSpringHashEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry, sizeof(Plasma__ArrayOfSpringHashEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfSpringHashEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfSpringHashEntry *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, "Plasma:SpringHashEntry", &(a->Plasma__ArrayOfSpringHashEntry::SpringHashEntry), "Plasma:SpringHashEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfSpringHashEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry, 0, sizeof(Plasma__ArrayOfSpringHashEntry), 0, soap_copy_Plasma__ArrayOfSpringHashEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfSpringHashEntry * SOAP_FMAC6 soap_new_Plasma__ArrayOfSpringHashEntry(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfSpringHashEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfSpringHashEntry(struct soap *soap, Plasma__ArrayOfSpringHashEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfSpringHashEntry * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfSpringHashEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfSpringHashEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfSpringHashEntry;
		if (size)
			*size = sizeof(Plasma__ArrayOfSpringHashEntry);
		((Plasma__ArrayOfSpringHashEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfSpringHashEntry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfSpringHashEntry);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfSpringHashEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfSpringHashEntry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfSpringHashEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfSpringHashEntry %p -> %p\n", q, p));
	*(Plasma__ArrayOfSpringHashEntry*)p = *(Plasma__ArrayOfSpringHashEntry*)q;
}

void Plasma__ResourceData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__ResourceData::Dependencies = NULL;
	this->Plasma__ResourceData::InternalName = NULL;
	soap_default_Plasma__ResourceType(soap, &this->Plasma__ResourceData::ResourceType);
	this->Plasma__ResourceData::SpringHashes = NULL;
	/* transient soap skipped */
}

void Plasma__ResourceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfString(soap, &this->Plasma__ResourceData::Dependencies);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__ResourceData::InternalName);
	soap_serialize_PointerToPlasma__ArrayOfSpringHashEntry(soap, &this->Plasma__ResourceData::SpringHashes);
	/* transient soap skipped */
}

int Plasma__ResourceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ResourceData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ResourceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ResourceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ResourceData(struct soap *soap, const char *tag, int id, const Plasma__ResourceData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ResourceData), type))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfString(soap, "Plasma:Dependencies", -1, &(a->Plasma__ResourceData::Dependencies), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:InternalName", -1, &(a->Plasma__ResourceData::InternalName), ""))
		return soap->error;
	if (soap_out_Plasma__ResourceType(soap, "Plasma:ResourceType", -1, &(a->Plasma__ResourceData::ResourceType), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfSpringHashEntry(soap, "Plasma:SpringHashes", -1, &(a->Plasma__ResourceData::SpringHashes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ResourceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ResourceData(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ResourceData * SOAP_FMAC4 soap_get_Plasma__ResourceData(struct soap *soap, Plasma__ResourceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ResourceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ResourceData(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ResourceData * SOAP_FMAC4 soap_in_Plasma__ResourceData(struct soap *soap, const char *tag, Plasma__ResourceData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ResourceData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ResourceData, sizeof(Plasma__ResourceData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ResourceData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ResourceData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Dependencies1 = 1, soap_flag_InternalName1 = 1, soap_flag_ResourceType1 = 1, soap_flag_SpringHashes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dependencies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfString(soap, "Plasma:Dependencies", &(a->Plasma__ResourceData::Dependencies), "Plasma:ArrayOfString"))
				{	soap_flag_Dependencies1--;
					continue;
				}
			if (soap_flag_InternalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:InternalName", &(a->Plasma__ResourceData::InternalName), "xsd:string"))
				{	soap_flag_InternalName1--;
					continue;
				}
			if (soap_flag_ResourceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Plasma__ResourceType(soap, "Plasma:ResourceType", &(a->Plasma__ResourceData::ResourceType), "Plasma:ResourceType"))
				{	soap_flag_ResourceType1--;
					continue;
				}
			if (soap_flag_SpringHashes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfSpringHashEntry(soap, "Plasma:SpringHashes", &(a->Plasma__ResourceData::SpringHashes), "Plasma:ArrayOfSpringHashEntry"))
				{	soap_flag_SpringHashes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ResourceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ResourceData, 0, sizeof(Plasma__ResourceData), 0, soap_copy_Plasma__ResourceData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResourceType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ResourceData * SOAP_FMAC6 soap_new_Plasma__ResourceData(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ResourceData(struct soap *soap, Plasma__ResourceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ResourceData * SOAP_FMAC4 soap_instantiate_Plasma__ResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ResourceData;
		if (size)
			*size = sizeof(Plasma__ResourceData);
		((Plasma__ResourceData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ResourceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ResourceData);
		for (int i = 0; i < n; i++)
			((Plasma__ResourceData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ResourceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ResourceData %p -> %p\n", q, p));
	*(Plasma__ResourceData*)p = *(Plasma__ResourceData*)q;
}

void Plasma__RecommendedMapResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__RecommendedMapResult::MapName = NULL;
	this->Plasma__RecommendedMapResult::Message = NULL;
	/* transient soap skipped */
}

void Plasma__RecommendedMapResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->Plasma__RecommendedMapResult::MapName);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__RecommendedMapResult::Message);
	/* transient soap skipped */
}

int Plasma__RecommendedMapResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__RecommendedMapResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__RecommendedMapResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__RecommendedMapResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__RecommendedMapResult(struct soap *soap, const char *tag, int id, const Plasma__RecommendedMapResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__RecommendedMapResult), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:MapName", -1, &(a->Plasma__RecommendedMapResult::MapName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Message", -1, &(a->Plasma__RecommendedMapResult::Message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__RecommendedMapResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__RecommendedMapResult(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__RecommendedMapResult * SOAP_FMAC4 soap_get_Plasma__RecommendedMapResult(struct soap *soap, Plasma__RecommendedMapResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__RecommendedMapResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__RecommendedMapResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__RecommendedMapResult(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__RecommendedMapResult * SOAP_FMAC4 soap_in_Plasma__RecommendedMapResult(struct soap *soap, const char *tag, Plasma__RecommendedMapResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__RecommendedMapResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__RecommendedMapResult, sizeof(Plasma__RecommendedMapResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__RecommendedMapResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__RecommendedMapResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_MapName1 = 1, soap_flag_Message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MapName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:MapName", &(a->Plasma__RecommendedMapResult::MapName), "xsd:string"))
				{	soap_flag_MapName1--;
					continue;
				}
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Message", &(a->Plasma__RecommendedMapResult::Message), "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__RecommendedMapResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__RecommendedMapResult, 0, sizeof(Plasma__RecommendedMapResult), 0, soap_copy_Plasma__RecommendedMapResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__RecommendedMapResult * SOAP_FMAC6 soap_new_Plasma__RecommendedMapResult(struct soap *soap, int n)
{	return soap_instantiate_Plasma__RecommendedMapResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__RecommendedMapResult(struct soap *soap, Plasma__RecommendedMapResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__RecommendedMapResult * SOAP_FMAC4 soap_instantiate_Plasma__RecommendedMapResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__RecommendedMapResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__RecommendedMapResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__RecommendedMapResult;
		if (size)
			*size = sizeof(Plasma__RecommendedMapResult);
		((Plasma__RecommendedMapResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__RecommendedMapResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__RecommendedMapResult);
		for (int i = 0; i < n; i++)
			((Plasma__RecommendedMapResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__RecommendedMapResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__RecommendedMapResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__RecommendedMapResult %p -> %p\n", q, p));
	*(Plasma__RecommendedMapResult*)p = *(Plasma__RecommendedMapResult*)q;
}

void Plasma__EloInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->Plasma__EloInfo::Elo);
	soap_default_double(soap, &this->Plasma__EloInfo::Weight);
	/* transient soap skipped */
}

void Plasma__EloInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int Plasma__EloInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__EloInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__EloInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__EloInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__EloInfo(struct soap *soap, const char *tag, int id, const Plasma__EloInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__EloInfo), type))
		return soap->error;
	if (soap_out_double(soap, "Plasma:Elo", -1, &(a->Plasma__EloInfo::Elo), ""))
		return soap->error;
	if (soap_out_double(soap, "Plasma:Weight", -1, &(a->Plasma__EloInfo::Weight), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__EloInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__EloInfo(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__EloInfo * SOAP_FMAC4 soap_get_Plasma__EloInfo(struct soap *soap, Plasma__EloInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__EloInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__EloInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__EloInfo(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__EloInfo * SOAP_FMAC4 soap_in_Plasma__EloInfo(struct soap *soap, const char *tag, Plasma__EloInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__EloInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__EloInfo, sizeof(Plasma__EloInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__EloInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__EloInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Elo1 = 1, soap_flag_Weight1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Elo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Plasma:Elo", &(a->Plasma__EloInfo::Elo), "xsd:double"))
				{	soap_flag_Elo1--;
					continue;
				}
			if (soap_flag_Weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Plasma:Weight", &(a->Plasma__EloInfo::Weight), "xsd:double"))
				{	soap_flag_Weight1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__EloInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__EloInfo, 0, sizeof(Plasma__EloInfo), 0, soap_copy_Plasma__EloInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Elo1 > 0 || soap_flag_Weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__EloInfo * SOAP_FMAC6 soap_new_Plasma__EloInfo(struct soap *soap, int n)
{	return soap_instantiate_Plasma__EloInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__EloInfo(struct soap *soap, Plasma__EloInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__EloInfo * SOAP_FMAC4 soap_instantiate_Plasma__EloInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__EloInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__EloInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__EloInfo;
		if (size)
			*size = sizeof(Plasma__EloInfo);
		((Plasma__EloInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__EloInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__EloInfo);
		for (int i = 0; i < n; i++)
			((Plasma__EloInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__EloInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__EloInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__EloInfo %p -> %p\n", q, p));
	*(Plasma__EloInfo*)p = *(Plasma__EloInfo*)q;
}

void Plasma__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->Plasma__ArrayOfString::string);
	/* transient soap skipped */
}

void Plasma__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->Plasma__ArrayOfString::string);
	/* transient soap skipped */
}

int Plasma__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfString(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfString), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "Plasma:string", -1, &(a->Plasma__ArrayOfString::string), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfString * SOAP_FMAC4 soap_get_Plasma__ArrayOfString(struct soap *soap, Plasma__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfString * SOAP_FMAC4 soap_in_Plasma__ArrayOfString(struct soap *soap, const char *tag, Plasma__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfString, sizeof(Plasma__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "Plasma:string", &(a->Plasma__ArrayOfString::string), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfString, 0, sizeof(Plasma__ArrayOfString), 0, soap_copy_Plasma__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfString * SOAP_FMAC6 soap_new_Plasma__ArrayOfString(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfString(struct soap *soap, Plasma__ArrayOfString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfString * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfString;
		if (size)
			*size = sizeof(Plasma__ArrayOfString);
		((Plasma__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfString);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfString %p -> %p\n", q, p));
	*(Plasma__ArrayOfString*)p = *(Plasma__ArrayOfString*)q;
}

void Plasma__BotTeam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__BotTeam::AllyID);
	this->Plasma__BotTeam::BotName = NULL;
	soap_default_int(soap, &this->Plasma__BotTeam::TeamID);
	/* transient soap skipped */
}

void Plasma__BotTeam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__BotTeam::AllyID, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BotTeam::BotName);
	soap_embedded(soap, &this->Plasma__BotTeam::TeamID, SOAP_TYPE_int);
	/* transient soap skipped */
}

int Plasma__BotTeam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__BotTeam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__BotTeam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__BotTeam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__BotTeam(struct soap *soap, const char *tag, int id, const Plasma__BotTeam *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__BotTeam), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AllyID", -1, &(a->Plasma__BotTeam::AllyID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:BotName", -1, &(a->Plasma__BotTeam::BotName), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:TeamID", -1, &(a->Plasma__BotTeam::TeamID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__BotTeam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__BotTeam(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__BotTeam * SOAP_FMAC4 soap_get_Plasma__BotTeam(struct soap *soap, Plasma__BotTeam *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__BotTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__BotTeam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__BotTeam(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__BotTeam * SOAP_FMAC4 soap_in_Plasma__BotTeam(struct soap *soap, const char *tag, Plasma__BotTeam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__BotTeam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__BotTeam, sizeof(Plasma__BotTeam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__BotTeam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__BotTeam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AllyID1 = 1, soap_flag_BotName1 = 1, soap_flag_TeamID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AllyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AllyID", &(a->Plasma__BotTeam::AllyID), "xsd:int"))
				{	soap_flag_AllyID1--;
					continue;
				}
			if (soap_flag_BotName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:BotName", &(a->Plasma__BotTeam::BotName), "xsd:string"))
				{	soap_flag_BotName1--;
					continue;
				}
			if (soap_flag_TeamID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:TeamID", &(a->Plasma__BotTeam::TeamID), "xsd:int"))
				{	soap_flag_TeamID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__BotTeam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__BotTeam, 0, sizeof(Plasma__BotTeam), 0, soap_copy_Plasma__BotTeam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AllyID1 > 0 || soap_flag_TeamID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__BotTeam * SOAP_FMAC6 soap_new_Plasma__BotTeam(struct soap *soap, int n)
{	return soap_instantiate_Plasma__BotTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__BotTeam(struct soap *soap, Plasma__BotTeam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__BotTeam * SOAP_FMAC4 soap_instantiate_Plasma__BotTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__BotTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__BotTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__BotTeam;
		if (size)
			*size = sizeof(Plasma__BotTeam);
		((Plasma__BotTeam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__BotTeam[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__BotTeam);
		for (int i = 0; i < n; i++)
			((Plasma__BotTeam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__BotTeam*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__BotTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__BotTeam %p -> %p\n", q, p));
	*(Plasma__BotTeam*)p = *(Plasma__BotTeam*)q;
}

void Plasma__ArrayOfBotTeam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, &this->Plasma__ArrayOfBotTeam::BotTeam);
	/* transient soap skipped */
}

void Plasma__ArrayOfBotTeam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, &this->Plasma__ArrayOfBotTeam::BotTeam);
	/* transient soap skipped */
}

int Plasma__ArrayOfBotTeam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfBotTeam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfBotTeam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfBotTeam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfBotTeam(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfBotTeam *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfBotTeam), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, "Plasma:BotTeam", -1, &(a->Plasma__ArrayOfBotTeam::BotTeam), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfBotTeam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfBotTeam(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfBotTeam * SOAP_FMAC4 soap_get_Plasma__ArrayOfBotTeam(struct soap *soap, Plasma__ArrayOfBotTeam *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfBotTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfBotTeam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfBotTeam(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfBotTeam * SOAP_FMAC4 soap_in_Plasma__ArrayOfBotTeam(struct soap *soap, const char *tag, Plasma__ArrayOfBotTeam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfBotTeam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfBotTeam, sizeof(Plasma__ArrayOfBotTeam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfBotTeam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfBotTeam *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, "Plasma:BotTeam", &(a->Plasma__ArrayOfBotTeam::BotTeam), "Plasma:BotTeam"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfBotTeam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfBotTeam, 0, sizeof(Plasma__ArrayOfBotTeam), 0, soap_copy_Plasma__ArrayOfBotTeam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfBotTeam * SOAP_FMAC6 soap_new_Plasma__ArrayOfBotTeam(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfBotTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfBotTeam(struct soap *soap, Plasma__ArrayOfBotTeam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfBotTeam * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfBotTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfBotTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfBotTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfBotTeam;
		if (size)
			*size = sizeof(Plasma__ArrayOfBotTeam);
		((Plasma__ArrayOfBotTeam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfBotTeam[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfBotTeam);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfBotTeam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfBotTeam*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfBotTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfBotTeam %p -> %p\n", q, p));
	*(Plasma__ArrayOfBotTeam*)p = *(Plasma__ArrayOfBotTeam*)q;
}

void Plasma__BalanceTeamsResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Plasma__BalanceTeamsResult::BalancedTeams = NULL;
	this->Plasma__BalanceTeamsResult::Bots = NULL;
	this->Plasma__BalanceTeamsResult::Message = NULL;
	/* transient soap skipped */
}

void Plasma__BalanceTeamsResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToPlasma__ArrayOfAccountTeam(soap, &this->Plasma__BalanceTeamsResult::BalancedTeams);
	soap_serialize_PointerToPlasma__ArrayOfBotTeam(soap, &this->Plasma__BalanceTeamsResult::Bots);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__BalanceTeamsResult::Message);
	/* transient soap skipped */
}

int Plasma__BalanceTeamsResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__BalanceTeamsResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__BalanceTeamsResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__BalanceTeamsResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__BalanceTeamsResult(struct soap *soap, const char *tag, int id, const Plasma__BalanceTeamsResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__BalanceTeamsResult), type))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:BalancedTeams", -1, &(a->Plasma__BalanceTeamsResult::BalancedTeams), ""))
		return soap->error;
	if (soap_out_PointerToPlasma__ArrayOfBotTeam(soap, "Plasma:Bots", -1, &(a->Plasma__BalanceTeamsResult::Bots), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Message", -1, &(a->Plasma__BalanceTeamsResult::Message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__BalanceTeamsResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__BalanceTeamsResult(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__BalanceTeamsResult * SOAP_FMAC4 soap_get_Plasma__BalanceTeamsResult(struct soap *soap, Plasma__BalanceTeamsResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__BalanceTeamsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__BalanceTeamsResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__BalanceTeamsResult(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__BalanceTeamsResult * SOAP_FMAC4 soap_in_Plasma__BalanceTeamsResult(struct soap *soap, const char *tag, Plasma__BalanceTeamsResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__BalanceTeamsResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__BalanceTeamsResult, sizeof(Plasma__BalanceTeamsResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__BalanceTeamsResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__BalanceTeamsResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_BalancedTeams1 = 1, soap_flag_Bots1 = 1, soap_flag_Message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BalancedTeams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfAccountTeam(soap, "Plasma:BalancedTeams", &(a->Plasma__BalanceTeamsResult::BalancedTeams), "Plasma:ArrayOfAccountTeam"))
				{	soap_flag_BalancedTeams1--;
					continue;
				}
			if (soap_flag_Bots1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlasma__ArrayOfBotTeam(soap, "Plasma:Bots", &(a->Plasma__BalanceTeamsResult::Bots), "Plasma:ArrayOfBotTeam"))
				{	soap_flag_Bots1--;
					continue;
				}
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Message", &(a->Plasma__BalanceTeamsResult::Message), "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__BalanceTeamsResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__BalanceTeamsResult, 0, sizeof(Plasma__BalanceTeamsResult), 0, soap_copy_Plasma__BalanceTeamsResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__BalanceTeamsResult * SOAP_FMAC6 soap_new_Plasma__BalanceTeamsResult(struct soap *soap, int n)
{	return soap_instantiate_Plasma__BalanceTeamsResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__BalanceTeamsResult(struct soap *soap, Plasma__BalanceTeamsResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__BalanceTeamsResult * SOAP_FMAC4 soap_instantiate_Plasma__BalanceTeamsResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__BalanceTeamsResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__BalanceTeamsResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__BalanceTeamsResult;
		if (size)
			*size = sizeof(Plasma__BalanceTeamsResult);
		((Plasma__BalanceTeamsResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__BalanceTeamsResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__BalanceTeamsResult);
		for (int i = 0; i < n; i++)
			((Plasma__BalanceTeamsResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__BalanceTeamsResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__BalanceTeamsResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__BalanceTeamsResult %p -> %p\n", q, p));
	*(Plasma__BalanceTeamsResult*)p = *(Plasma__BalanceTeamsResult*)q;
}

void Plasma__AccountTeam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->Plasma__AccountTeam::AccountID);
	soap_default_int(soap, &this->Plasma__AccountTeam::AllyID);
	this->Plasma__AccountTeam::Name = NULL;
	soap_default_bool(soap, &this->Plasma__AccountTeam::Spectate);
	soap_default_int(soap, &this->Plasma__AccountTeam::TeamID);
	/* transient soap skipped */
}

void Plasma__AccountTeam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->Plasma__AccountTeam::AccountID, SOAP_TYPE_int);
	soap_embedded(soap, &this->Plasma__AccountTeam::AllyID, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->Plasma__AccountTeam::Name);
	soap_embedded(soap, &this->Plasma__AccountTeam::TeamID, SOAP_TYPE_int);
	/* transient soap skipped */
}

int Plasma__AccountTeam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__AccountTeam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__AccountTeam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__AccountTeam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__AccountTeam(struct soap *soap, const char *tag, int id, const Plasma__AccountTeam *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__AccountTeam), type))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AccountID", -1, &(a->Plasma__AccountTeam::AccountID), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:AllyID", -1, &(a->Plasma__AccountTeam::AllyID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Plasma:Name", -1, &(a->Plasma__AccountTeam::Name), ""))
		return soap->error;
	if (soap_out_bool(soap, "Plasma:Spectate", -1, &(a->Plasma__AccountTeam::Spectate), ""))
		return soap->error;
	if (soap_out_int(soap, "Plasma:TeamID", -1, &(a->Plasma__AccountTeam::TeamID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__AccountTeam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__AccountTeam(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__AccountTeam * SOAP_FMAC4 soap_get_Plasma__AccountTeam(struct soap *soap, Plasma__AccountTeam *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__AccountTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__AccountTeam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__AccountTeam(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__AccountTeam * SOAP_FMAC4 soap_in_Plasma__AccountTeam(struct soap *soap, const char *tag, Plasma__AccountTeam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__AccountTeam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__AccountTeam, sizeof(Plasma__AccountTeam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__AccountTeam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__AccountTeam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_AccountID1 = 1, soap_flag_AllyID1 = 1, soap_flag_Name1 = 1, soap_flag_Spectate1 = 1, soap_flag_TeamID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccountID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AccountID", &(a->Plasma__AccountTeam::AccountID), "xsd:int"))
				{	soap_flag_AccountID1--;
					continue;
				}
			if (soap_flag_AllyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:AllyID", &(a->Plasma__AccountTeam::AllyID), "xsd:int"))
				{	soap_flag_AllyID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Plasma:Name", &(a->Plasma__AccountTeam::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Spectate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Plasma:Spectate", &(a->Plasma__AccountTeam::Spectate), "xsd:boolean"))
				{	soap_flag_Spectate1--;
					continue;
				}
			if (soap_flag_TeamID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Plasma:TeamID", &(a->Plasma__AccountTeam::TeamID), "xsd:int"))
				{	soap_flag_TeamID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__AccountTeam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__AccountTeam, 0, sizeof(Plasma__AccountTeam), 0, soap_copy_Plasma__AccountTeam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccountID1 > 0 || soap_flag_AllyID1 > 0 || soap_flag_Spectate1 > 0 || soap_flag_TeamID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__AccountTeam * SOAP_FMAC6 soap_new_Plasma__AccountTeam(struct soap *soap, int n)
{	return soap_instantiate_Plasma__AccountTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__AccountTeam(struct soap *soap, Plasma__AccountTeam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__AccountTeam * SOAP_FMAC4 soap_instantiate_Plasma__AccountTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__AccountTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__AccountTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__AccountTeam;
		if (size)
			*size = sizeof(Plasma__AccountTeam);
		((Plasma__AccountTeam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__AccountTeam[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__AccountTeam);
		for (int i = 0; i < n; i++)
			((Plasma__AccountTeam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__AccountTeam*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__AccountTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__AccountTeam %p -> %p\n", q, p));
	*(Plasma__AccountTeam*)p = *(Plasma__AccountTeam*)q;
}

void Plasma__ArrayOfAccountTeam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, &this->Plasma__ArrayOfAccountTeam::AccountTeam);
	/* transient soap skipped */
}

void Plasma__ArrayOfAccountTeam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, &this->Plasma__ArrayOfAccountTeam::AccountTeam);
	/* transient soap skipped */
}

int Plasma__ArrayOfAccountTeam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Plasma__ArrayOfAccountTeam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int Plasma__ArrayOfAccountTeam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Plasma__ArrayOfAccountTeam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Plasma__ArrayOfAccountTeam(struct soap *soap, const char *tag, int id, const Plasma__ArrayOfAccountTeam *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Plasma__ArrayOfAccountTeam), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, "Plasma:AccountTeam", -1, &(a->Plasma__ArrayOfAccountTeam::AccountTeam), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Plasma__ArrayOfAccountTeam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Plasma__ArrayOfAccountTeam(soap, this, tag, type);
}

SOAP_FMAC3 Plasma__ArrayOfAccountTeam * SOAP_FMAC4 soap_get_Plasma__ArrayOfAccountTeam(struct soap *soap, Plasma__ArrayOfAccountTeam *p, const char *tag, const char *type)
{
	if ((p = soap_in_Plasma__ArrayOfAccountTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *Plasma__ArrayOfAccountTeam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Plasma__ArrayOfAccountTeam(soap, tag, this, type);
}

SOAP_FMAC3 Plasma__ArrayOfAccountTeam * SOAP_FMAC4 soap_in_Plasma__ArrayOfAccountTeam(struct soap *soap, const char *tag, Plasma__ArrayOfAccountTeam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Plasma__ArrayOfAccountTeam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Plasma__ArrayOfAccountTeam, sizeof(Plasma__ArrayOfAccountTeam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Plasma__ArrayOfAccountTeam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Plasma__ArrayOfAccountTeam *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, "Plasma:AccountTeam", &(a->Plasma__ArrayOfAccountTeam::AccountTeam), "Plasma:AccountTeam"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Plasma__ArrayOfAccountTeam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Plasma__ArrayOfAccountTeam, 0, sizeof(Plasma__ArrayOfAccountTeam), 0, soap_copy_Plasma__ArrayOfAccountTeam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 Plasma__ArrayOfAccountTeam * SOAP_FMAC6 soap_new_Plasma__ArrayOfAccountTeam(struct soap *soap, int n)
{	return soap_instantiate_Plasma__ArrayOfAccountTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_Plasma__ArrayOfAccountTeam(struct soap *soap, Plasma__ArrayOfAccountTeam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 Plasma__ArrayOfAccountTeam * SOAP_FMAC4 soap_instantiate_Plasma__ArrayOfAccountTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Plasma__ArrayOfAccountTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Plasma__ArrayOfAccountTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new Plasma__ArrayOfAccountTeam;
		if (size)
			*size = sizeof(Plasma__ArrayOfAccountTeam);
		((Plasma__ArrayOfAccountTeam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new Plasma__ArrayOfAccountTeam[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Plasma__ArrayOfAccountTeam);
		for (int i = 0; i < n; i++)
			((Plasma__ArrayOfAccountTeam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Plasma__ArrayOfAccountTeam*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Plasma__ArrayOfAccountTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Plasma__ArrayOfAccountTeam %p -> %p\n", q, p));
	*(Plasma__ArrayOfAccountTeam*)p = *(Plasma__ArrayOfAccountTeam*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__VerifyAccountData(struct soap *soap, struct __Plasma3__VerifyAccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__VerifyAccountData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__VerifyAccountData(struct soap *soap, const struct __Plasma3__VerifyAccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__VerifyAccountData(soap, &a->Plasma__VerifyAccountData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__VerifyAccountData(struct soap *soap, const struct __Plasma3__VerifyAccountData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__VerifyAccountData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__VerifyAccountData(struct soap *soap, const char *tag, int id, const struct __Plasma3__VerifyAccountData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__VerifyAccountData(soap, "Plasma:VerifyAccountData", -1, &a->Plasma__VerifyAccountData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__VerifyAccountData * SOAP_FMAC4 soap_get___Plasma3__VerifyAccountData(struct soap *soap, struct __Plasma3__VerifyAccountData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__VerifyAccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__VerifyAccountData * SOAP_FMAC4 soap_in___Plasma3__VerifyAccountData(struct soap *soap, const char *tag, struct __Plasma3__VerifyAccountData *a, const char *type)
{
	short soap_flag_Plasma__VerifyAccountData = 1;
	short soap_flag;
	a = (struct __Plasma3__VerifyAccountData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__VerifyAccountData, sizeof(struct __Plasma3__VerifyAccountData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__VerifyAccountData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__VerifyAccountData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__VerifyAccountData(soap, "Plasma:VerifyAccountData", &a->Plasma__VerifyAccountData, ""))
				{	soap_flag_Plasma__VerifyAccountData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__VerifyAccountData * SOAP_FMAC6 soap_new___Plasma3__VerifyAccountData(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__VerifyAccountData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__VerifyAccountData(struct soap *soap, struct __Plasma3__VerifyAccountData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__VerifyAccountData * SOAP_FMAC4 soap_instantiate___Plasma3__VerifyAccountData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__VerifyAccountData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__VerifyAccountData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__VerifyAccountData;
		if (size)
			*size = sizeof(struct __Plasma3__VerifyAccountData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__VerifyAccountData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__VerifyAccountData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__VerifyAccountData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__VerifyAccountData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__VerifyAccountData %p -> %p\n", q, p));
	*(struct __Plasma3__VerifyAccountData*)p = *(struct __Plasma3__VerifyAccountData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__SubmitStackTrace(struct soap *soap, struct __Plasma3__SubmitStackTrace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitStackTrace = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__SubmitStackTrace(struct soap *soap, const struct __Plasma3__SubmitStackTrace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitStackTrace(soap, &a->Plasma__SubmitStackTrace);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__SubmitStackTrace(struct soap *soap, const struct __Plasma3__SubmitStackTrace *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__SubmitStackTrace(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__SubmitStackTrace(struct soap *soap, const char *tag, int id, const struct __Plasma3__SubmitStackTrace *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitStackTrace(soap, "Plasma:SubmitStackTrace", -1, &a->Plasma__SubmitStackTrace, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__SubmitStackTrace * SOAP_FMAC4 soap_get___Plasma3__SubmitStackTrace(struct soap *soap, struct __Plasma3__SubmitStackTrace *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__SubmitStackTrace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__SubmitStackTrace * SOAP_FMAC4 soap_in___Plasma3__SubmitStackTrace(struct soap *soap, const char *tag, struct __Plasma3__SubmitStackTrace *a, const char *type)
{
	short soap_flag_Plasma__SubmitStackTrace = 1;
	short soap_flag;
	a = (struct __Plasma3__SubmitStackTrace *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__SubmitStackTrace, sizeof(struct __Plasma3__SubmitStackTrace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__SubmitStackTrace(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitStackTrace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitStackTrace(soap, "Plasma:SubmitStackTrace", &a->Plasma__SubmitStackTrace, ""))
				{	soap_flag_Plasma__SubmitStackTrace--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__SubmitStackTrace * SOAP_FMAC6 soap_new___Plasma3__SubmitStackTrace(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__SubmitStackTrace(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__SubmitStackTrace(struct soap *soap, struct __Plasma3__SubmitStackTrace *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__SubmitStackTrace * SOAP_FMAC4 soap_instantiate___Plasma3__SubmitStackTrace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__SubmitStackTrace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__SubmitStackTrace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__SubmitStackTrace;
		if (size)
			*size = sizeof(struct __Plasma3__SubmitStackTrace);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__SubmitStackTrace[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__SubmitStackTrace);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__SubmitStackTrace*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__SubmitStackTrace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__SubmitStackTrace %p -> %p\n", q, p));
	*(struct __Plasma3__SubmitStackTrace*)p = *(struct __Plasma3__SubmitStackTrace*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__SubmitSpringBattleResult(struct soap *soap, struct __Plasma3__SubmitSpringBattleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitSpringBattleResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__SubmitSpringBattleResult(struct soap *soap, const struct __Plasma3__SubmitSpringBattleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitSpringBattleResult(soap, &a->Plasma__SubmitSpringBattleResult);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__SubmitSpringBattleResult(struct soap *soap, const struct __Plasma3__SubmitSpringBattleResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__SubmitSpringBattleResult(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__SubmitSpringBattleResult(struct soap *soap, const char *tag, int id, const struct __Plasma3__SubmitSpringBattleResult *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitSpringBattleResult(soap, "Plasma:SubmitSpringBattleResult", -1, &a->Plasma__SubmitSpringBattleResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__SubmitSpringBattleResult * SOAP_FMAC4 soap_get___Plasma3__SubmitSpringBattleResult(struct soap *soap, struct __Plasma3__SubmitSpringBattleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__SubmitSpringBattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__SubmitSpringBattleResult * SOAP_FMAC4 soap_in___Plasma3__SubmitSpringBattleResult(struct soap *soap, const char *tag, struct __Plasma3__SubmitSpringBattleResult *a, const char *type)
{
	short soap_flag_Plasma__SubmitSpringBattleResult = 1;
	short soap_flag;
	a = (struct __Plasma3__SubmitSpringBattleResult *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__SubmitSpringBattleResult, sizeof(struct __Plasma3__SubmitSpringBattleResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__SubmitSpringBattleResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitSpringBattleResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitSpringBattleResult(soap, "Plasma:SubmitSpringBattleResult", &a->Plasma__SubmitSpringBattleResult, ""))
				{	soap_flag_Plasma__SubmitSpringBattleResult--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__SubmitSpringBattleResult * SOAP_FMAC6 soap_new___Plasma3__SubmitSpringBattleResult(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__SubmitSpringBattleResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__SubmitSpringBattleResult(struct soap *soap, struct __Plasma3__SubmitSpringBattleResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__SubmitSpringBattleResult * SOAP_FMAC4 soap_instantiate___Plasma3__SubmitSpringBattleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__SubmitSpringBattleResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__SubmitSpringBattleResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__SubmitSpringBattleResult;
		if (size)
			*size = sizeof(struct __Plasma3__SubmitSpringBattleResult);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__SubmitSpringBattleResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__SubmitSpringBattleResult);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__SubmitSpringBattleResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__SubmitSpringBattleResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__SubmitSpringBattleResult %p -> %p\n", q, p));
	*(struct __Plasma3__SubmitSpringBattleResult*)p = *(struct __Plasma3__SubmitSpringBattleResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__SubmitMissionScore(struct soap *soap, struct __Plasma3__SubmitMissionScore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitMissionScore = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__SubmitMissionScore(struct soap *soap, const struct __Plasma3__SubmitMissionScore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitMissionScore(soap, &a->Plasma__SubmitMissionScore);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__SubmitMissionScore(struct soap *soap, const struct __Plasma3__SubmitMissionScore *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__SubmitMissionScore(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__SubmitMissionScore(struct soap *soap, const char *tag, int id, const struct __Plasma3__SubmitMissionScore *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitMissionScore(soap, "Plasma:SubmitMissionScore", -1, &a->Plasma__SubmitMissionScore, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__SubmitMissionScore * SOAP_FMAC4 soap_get___Plasma3__SubmitMissionScore(struct soap *soap, struct __Plasma3__SubmitMissionScore *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__SubmitMissionScore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__SubmitMissionScore * SOAP_FMAC4 soap_in___Plasma3__SubmitMissionScore(struct soap *soap, const char *tag, struct __Plasma3__SubmitMissionScore *a, const char *type)
{
	short soap_flag_Plasma__SubmitMissionScore = 1;
	short soap_flag;
	a = (struct __Plasma3__SubmitMissionScore *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__SubmitMissionScore, sizeof(struct __Plasma3__SubmitMissionScore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__SubmitMissionScore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitMissionScore && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitMissionScore(soap, "Plasma:SubmitMissionScore", &a->Plasma__SubmitMissionScore, ""))
				{	soap_flag_Plasma__SubmitMissionScore--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__SubmitMissionScore * SOAP_FMAC6 soap_new___Plasma3__SubmitMissionScore(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__SubmitMissionScore(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__SubmitMissionScore(struct soap *soap, struct __Plasma3__SubmitMissionScore *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__SubmitMissionScore * SOAP_FMAC4 soap_instantiate___Plasma3__SubmitMissionScore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__SubmitMissionScore(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__SubmitMissionScore, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__SubmitMissionScore;
		if (size)
			*size = sizeof(struct __Plasma3__SubmitMissionScore);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__SubmitMissionScore[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__SubmitMissionScore);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__SubmitMissionScore*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__SubmitMissionScore(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__SubmitMissionScore %p -> %p\n", q, p));
	*(struct __Plasma3__SubmitMissionScore*)p = *(struct __Plasma3__SubmitMissionScore*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__RegisterResource(struct soap *soap, struct __Plasma3__RegisterResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__RegisterResource = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__RegisterResource(struct soap *soap, const struct __Plasma3__RegisterResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__RegisterResource(soap, &a->Plasma__RegisterResource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__RegisterResource(struct soap *soap, const struct __Plasma3__RegisterResource *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__RegisterResource(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__RegisterResource(struct soap *soap, const char *tag, int id, const struct __Plasma3__RegisterResource *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__RegisterResource(soap, "Plasma:RegisterResource", -1, &a->Plasma__RegisterResource, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__RegisterResource * SOAP_FMAC4 soap_get___Plasma3__RegisterResource(struct soap *soap, struct __Plasma3__RegisterResource *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__RegisterResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__RegisterResource * SOAP_FMAC4 soap_in___Plasma3__RegisterResource(struct soap *soap, const char *tag, struct __Plasma3__RegisterResource *a, const char *type)
{
	short soap_flag_Plasma__RegisterResource = 1;
	short soap_flag;
	a = (struct __Plasma3__RegisterResource *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__RegisterResource, sizeof(struct __Plasma3__RegisterResource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__RegisterResource(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__RegisterResource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__RegisterResource(soap, "Plasma:RegisterResource", &a->Plasma__RegisterResource, ""))
				{	soap_flag_Plasma__RegisterResource--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__RegisterResource * SOAP_FMAC6 soap_new___Plasma3__RegisterResource(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__RegisterResource(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__RegisterResource(struct soap *soap, struct __Plasma3__RegisterResource *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__RegisterResource * SOAP_FMAC4 soap_instantiate___Plasma3__RegisterResource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__RegisterResource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__RegisterResource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__RegisterResource;
		if (size)
			*size = sizeof(struct __Plasma3__RegisterResource);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__RegisterResource[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__RegisterResource);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__RegisterResource*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__RegisterResource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__RegisterResource %p -> %p\n", q, p));
	*(struct __Plasma3__RegisterResource*)p = *(struct __Plasma3__RegisterResource*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__NotifyMissionRun(struct soap *soap, struct __Plasma3__NotifyMissionRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__NotifyMissionRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__NotifyMissionRun(struct soap *soap, const struct __Plasma3__NotifyMissionRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__NotifyMissionRun(soap, &a->Plasma__NotifyMissionRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__NotifyMissionRun(struct soap *soap, const struct __Plasma3__NotifyMissionRun *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__NotifyMissionRun(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__NotifyMissionRun(struct soap *soap, const char *tag, int id, const struct __Plasma3__NotifyMissionRun *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__NotifyMissionRun(soap, "Plasma:NotifyMissionRun", -1, &a->Plasma__NotifyMissionRun, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__NotifyMissionRun * SOAP_FMAC4 soap_get___Plasma3__NotifyMissionRun(struct soap *soap, struct __Plasma3__NotifyMissionRun *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__NotifyMissionRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__NotifyMissionRun * SOAP_FMAC4 soap_in___Plasma3__NotifyMissionRun(struct soap *soap, const char *tag, struct __Plasma3__NotifyMissionRun *a, const char *type)
{
	short soap_flag_Plasma__NotifyMissionRun = 1;
	short soap_flag;
	a = (struct __Plasma3__NotifyMissionRun *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__NotifyMissionRun, sizeof(struct __Plasma3__NotifyMissionRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__NotifyMissionRun(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__NotifyMissionRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__NotifyMissionRun(soap, "Plasma:NotifyMissionRun", &a->Plasma__NotifyMissionRun, ""))
				{	soap_flag_Plasma__NotifyMissionRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__NotifyMissionRun * SOAP_FMAC6 soap_new___Plasma3__NotifyMissionRun(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__NotifyMissionRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__NotifyMissionRun(struct soap *soap, struct __Plasma3__NotifyMissionRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__NotifyMissionRun * SOAP_FMAC4 soap_instantiate___Plasma3__NotifyMissionRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__NotifyMissionRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__NotifyMissionRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__NotifyMissionRun;
		if (size)
			*size = sizeof(struct __Plasma3__NotifyMissionRun);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__NotifyMissionRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__NotifyMissionRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__NotifyMissionRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__NotifyMissionRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__NotifyMissionRun %p -> %p\n", q, p));
	*(struct __Plasma3__NotifyMissionRun*)p = *(struct __Plasma3__NotifyMissionRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma3__GetSpringBattleStartSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetSpringBattleStartSetup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetSpringBattleStartSetup(struct soap *soap, const struct __Plasma3__GetSpringBattleStartSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetup(soap, &a->Plasma__GetSpringBattleStartSetup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetSpringBattleStartSetup(struct soap *soap, const struct __Plasma3__GetSpringBattleStartSetup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetSpringBattleStartSetup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetSpringBattleStartSetup(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetSpringBattleStartSetup *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetSpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetup", -1, &a->Plasma__GetSpringBattleStartSetup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetSpringBattleStartSetup * SOAP_FMAC4 soap_get___Plasma3__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma3__GetSpringBattleStartSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetSpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetSpringBattleStartSetup * SOAP_FMAC4 soap_in___Plasma3__GetSpringBattleStartSetup(struct soap *soap, const char *tag, struct __Plasma3__GetSpringBattleStartSetup *a, const char *type)
{
	short soap_flag_Plasma__GetSpringBattleStartSetup = 1;
	short soap_flag;
	a = (struct __Plasma3__GetSpringBattleStartSetup *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetSpringBattleStartSetup, sizeof(struct __Plasma3__GetSpringBattleStartSetup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetSpringBattleStartSetup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetSpringBattleStartSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetSpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetup", &a->Plasma__GetSpringBattleStartSetup, ""))
				{	soap_flag_Plasma__GetSpringBattleStartSetup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetSpringBattleStartSetup * SOAP_FMAC6 soap_new___Plasma3__GetSpringBattleStartSetup(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetSpringBattleStartSetup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma3__GetSpringBattleStartSetup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetSpringBattleStartSetup * SOAP_FMAC4 soap_instantiate___Plasma3__GetSpringBattleStartSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetSpringBattleStartSetup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetSpringBattleStartSetup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetSpringBattleStartSetup;
		if (size)
			*size = sizeof(struct __Plasma3__GetSpringBattleStartSetup);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetSpringBattleStartSetup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetSpringBattleStartSetup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetSpringBattleStartSetup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetSpringBattleStartSetup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetSpringBattleStartSetup %p -> %p\n", q, p));
	*(struct __Plasma3__GetSpringBattleStartSetup*)p = *(struct __Plasma3__GetSpringBattleStartSetup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetScriptMissionData(struct soap *soap, struct __Plasma3__GetScriptMissionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetScriptMissionData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetScriptMissionData(struct soap *soap, const struct __Plasma3__GetScriptMissionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetScriptMissionData(soap, &a->Plasma__GetScriptMissionData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetScriptMissionData(struct soap *soap, const struct __Plasma3__GetScriptMissionData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetScriptMissionData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetScriptMissionData(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetScriptMissionData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetScriptMissionData(soap, "Plasma:GetScriptMissionData", -1, &a->Plasma__GetScriptMissionData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetScriptMissionData * SOAP_FMAC4 soap_get___Plasma3__GetScriptMissionData(struct soap *soap, struct __Plasma3__GetScriptMissionData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetScriptMissionData * SOAP_FMAC4 soap_in___Plasma3__GetScriptMissionData(struct soap *soap, const char *tag, struct __Plasma3__GetScriptMissionData *a, const char *type)
{
	short soap_flag_Plasma__GetScriptMissionData = 1;
	short soap_flag;
	a = (struct __Plasma3__GetScriptMissionData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetScriptMissionData, sizeof(struct __Plasma3__GetScriptMissionData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetScriptMissionData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetScriptMissionData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetScriptMissionData(soap, "Plasma:GetScriptMissionData", &a->Plasma__GetScriptMissionData, ""))
				{	soap_flag_Plasma__GetScriptMissionData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetScriptMissionData * SOAP_FMAC6 soap_new___Plasma3__GetScriptMissionData(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetScriptMissionData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetScriptMissionData(struct soap *soap, struct __Plasma3__GetScriptMissionData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetScriptMissionData * SOAP_FMAC4 soap_instantiate___Plasma3__GetScriptMissionData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetScriptMissionData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetScriptMissionData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetScriptMissionData;
		if (size)
			*size = sizeof(struct __Plasma3__GetScriptMissionData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetScriptMissionData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetScriptMissionData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetScriptMissionData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetScriptMissionData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetScriptMissionData %p -> %p\n", q, p));
	*(struct __Plasma3__GetScriptMissionData*)p = *(struct __Plasma3__GetScriptMissionData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetResourceList(struct soap *soap, struct __Plasma3__GetResourceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetResourceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetResourceList(struct soap *soap, const struct __Plasma3__GetResourceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetResourceList(soap, &a->Plasma__GetResourceList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetResourceList(struct soap *soap, const struct __Plasma3__GetResourceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetResourceList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetResourceList(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetResourceList *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetResourceList(soap, "Plasma:GetResourceList", -1, &a->Plasma__GetResourceList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetResourceList * SOAP_FMAC4 soap_get___Plasma3__GetResourceList(struct soap *soap, struct __Plasma3__GetResourceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetResourceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetResourceList * SOAP_FMAC4 soap_in___Plasma3__GetResourceList(struct soap *soap, const char *tag, struct __Plasma3__GetResourceList *a, const char *type)
{
	short soap_flag_Plasma__GetResourceList = 1;
	short soap_flag;
	a = (struct __Plasma3__GetResourceList *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetResourceList, sizeof(struct __Plasma3__GetResourceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetResourceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetResourceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetResourceList(soap, "Plasma:GetResourceList", &a->Plasma__GetResourceList, ""))
				{	soap_flag_Plasma__GetResourceList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetResourceList * SOAP_FMAC6 soap_new___Plasma3__GetResourceList(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetResourceList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetResourceList(struct soap *soap, struct __Plasma3__GetResourceList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetResourceList * SOAP_FMAC4 soap_instantiate___Plasma3__GetResourceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetResourceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetResourceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetResourceList;
		if (size)
			*size = sizeof(struct __Plasma3__GetResourceList);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetResourceList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetResourceList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetResourceList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetResourceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetResourceList %p -> %p\n", q, p));
	*(struct __Plasma3__GetResourceList*)p = *(struct __Plasma3__GetResourceList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetResourceData(struct soap *soap, struct __Plasma3__GetResourceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetResourceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetResourceData(struct soap *soap, const struct __Plasma3__GetResourceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetResourceData(soap, &a->Plasma__GetResourceData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetResourceData(struct soap *soap, const struct __Plasma3__GetResourceData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetResourceData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetResourceData(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetResourceData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetResourceData(soap, "Plasma:GetResourceData", -1, &a->Plasma__GetResourceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetResourceData * SOAP_FMAC4 soap_get___Plasma3__GetResourceData(struct soap *soap, struct __Plasma3__GetResourceData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetResourceData * SOAP_FMAC4 soap_in___Plasma3__GetResourceData(struct soap *soap, const char *tag, struct __Plasma3__GetResourceData *a, const char *type)
{
	short soap_flag_Plasma__GetResourceData = 1;
	short soap_flag;
	a = (struct __Plasma3__GetResourceData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetResourceData, sizeof(struct __Plasma3__GetResourceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetResourceData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetResourceData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetResourceData(soap, "Plasma:GetResourceData", &a->Plasma__GetResourceData, ""))
				{	soap_flag_Plasma__GetResourceData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetResourceData * SOAP_FMAC6 soap_new___Plasma3__GetResourceData(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetResourceData(struct soap *soap, struct __Plasma3__GetResourceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetResourceData * SOAP_FMAC4 soap_instantiate___Plasma3__GetResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetResourceData;
		if (size)
			*size = sizeof(struct __Plasma3__GetResourceData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetResourceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetResourceData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetResourceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetResourceData %p -> %p\n", q, p));
	*(struct __Plasma3__GetResourceData*)p = *(struct __Plasma3__GetResourceData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetRecommendedMap(struct soap *soap, struct __Plasma3__GetRecommendedMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetRecommendedMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetRecommendedMap(struct soap *soap, const struct __Plasma3__GetRecommendedMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetRecommendedMap(soap, &a->Plasma__GetRecommendedMap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetRecommendedMap(struct soap *soap, const struct __Plasma3__GetRecommendedMap *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetRecommendedMap(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetRecommendedMap(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetRecommendedMap *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetRecommendedMap(soap, "Plasma:GetRecommendedMap", -1, &a->Plasma__GetRecommendedMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetRecommendedMap * SOAP_FMAC4 soap_get___Plasma3__GetRecommendedMap(struct soap *soap, struct __Plasma3__GetRecommendedMap *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetRecommendedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetRecommendedMap * SOAP_FMAC4 soap_in___Plasma3__GetRecommendedMap(struct soap *soap, const char *tag, struct __Plasma3__GetRecommendedMap *a, const char *type)
{
	short soap_flag_Plasma__GetRecommendedMap = 1;
	short soap_flag;
	a = (struct __Plasma3__GetRecommendedMap *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetRecommendedMap, sizeof(struct __Plasma3__GetRecommendedMap), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetRecommendedMap(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetRecommendedMap && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetRecommendedMap(soap, "Plasma:GetRecommendedMap", &a->Plasma__GetRecommendedMap, ""))
				{	soap_flag_Plasma__GetRecommendedMap--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetRecommendedMap * SOAP_FMAC6 soap_new___Plasma3__GetRecommendedMap(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetRecommendedMap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetRecommendedMap(struct soap *soap, struct __Plasma3__GetRecommendedMap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetRecommendedMap * SOAP_FMAC4 soap_instantiate___Plasma3__GetRecommendedMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetRecommendedMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetRecommendedMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetRecommendedMap;
		if (size)
			*size = sizeof(struct __Plasma3__GetRecommendedMap);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetRecommendedMap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetRecommendedMap);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetRecommendedMap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetRecommendedMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetRecommendedMap %p -> %p\n", q, p));
	*(struct __Plasma3__GetRecommendedMap*)p = *(struct __Plasma3__GetRecommendedMap*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetEloTop10(struct soap *soap, struct __Plasma3__GetEloTop10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloTop10 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetEloTop10(struct soap *soap, const struct __Plasma3__GetEloTop10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloTop10(soap, &a->Plasma__GetEloTop10);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetEloTop10(struct soap *soap, const struct __Plasma3__GetEloTop10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetEloTop10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetEloTop10(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetEloTop10 *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloTop10(soap, "Plasma:GetEloTop10", -1, &a->Plasma__GetEloTop10, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetEloTop10 * SOAP_FMAC4 soap_get___Plasma3__GetEloTop10(struct soap *soap, struct __Plasma3__GetEloTop10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetEloTop10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetEloTop10 * SOAP_FMAC4 soap_in___Plasma3__GetEloTop10(struct soap *soap, const char *tag, struct __Plasma3__GetEloTop10 *a, const char *type)
{
	short soap_flag_Plasma__GetEloTop10 = 1;
	short soap_flag;
	a = (struct __Plasma3__GetEloTop10 *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetEloTop10, sizeof(struct __Plasma3__GetEloTop10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetEloTop10(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloTop10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloTop10(soap, "Plasma:GetEloTop10", &a->Plasma__GetEloTop10, ""))
				{	soap_flag_Plasma__GetEloTop10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetEloTop10 * SOAP_FMAC6 soap_new___Plasma3__GetEloTop10(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetEloTop10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetEloTop10(struct soap *soap, struct __Plasma3__GetEloTop10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetEloTop10 * SOAP_FMAC4 soap_instantiate___Plasma3__GetEloTop10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetEloTop10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetEloTop10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetEloTop10;
		if (size)
			*size = sizeof(struct __Plasma3__GetEloTop10);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetEloTop10[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetEloTop10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetEloTop10*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetEloTop10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetEloTop10 %p -> %p\n", q, p));
	*(struct __Plasma3__GetEloTop10*)p = *(struct __Plasma3__GetEloTop10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetEloByName(struct soap *soap, struct __Plasma3__GetEloByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloByName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetEloByName(struct soap *soap, const struct __Plasma3__GetEloByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloByName(soap, &a->Plasma__GetEloByName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetEloByName(struct soap *soap, const struct __Plasma3__GetEloByName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetEloByName(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetEloByName(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetEloByName *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloByName(soap, "Plasma:GetEloByName", -1, &a->Plasma__GetEloByName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetEloByName * SOAP_FMAC4 soap_get___Plasma3__GetEloByName(struct soap *soap, struct __Plasma3__GetEloByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetEloByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetEloByName * SOAP_FMAC4 soap_in___Plasma3__GetEloByName(struct soap *soap, const char *tag, struct __Plasma3__GetEloByName *a, const char *type)
{
	short soap_flag_Plasma__GetEloByName = 1;
	short soap_flag;
	a = (struct __Plasma3__GetEloByName *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetEloByName, sizeof(struct __Plasma3__GetEloByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetEloByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloByName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloByName(soap, "Plasma:GetEloByName", &a->Plasma__GetEloByName, ""))
				{	soap_flag_Plasma__GetEloByName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetEloByName * SOAP_FMAC6 soap_new___Plasma3__GetEloByName(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetEloByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetEloByName(struct soap *soap, struct __Plasma3__GetEloByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetEloByName * SOAP_FMAC4 soap_instantiate___Plasma3__GetEloByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetEloByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetEloByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetEloByName;
		if (size)
			*size = sizeof(struct __Plasma3__GetEloByName);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetEloByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetEloByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetEloByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetEloByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetEloByName %p -> %p\n", q, p));
	*(struct __Plasma3__GetEloByName*)p = *(struct __Plasma3__GetEloByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__GetEloByAccountID(struct soap *soap, struct __Plasma3__GetEloByAccountID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloByAccountID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__GetEloByAccountID(struct soap *soap, const struct __Plasma3__GetEloByAccountID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloByAccountID(soap, &a->Plasma__GetEloByAccountID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__GetEloByAccountID(struct soap *soap, const struct __Plasma3__GetEloByAccountID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__GetEloByAccountID(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__GetEloByAccountID(struct soap *soap, const char *tag, int id, const struct __Plasma3__GetEloByAccountID *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloByAccountID(soap, "Plasma:GetEloByAccountID", -1, &a->Plasma__GetEloByAccountID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__GetEloByAccountID * SOAP_FMAC4 soap_get___Plasma3__GetEloByAccountID(struct soap *soap, struct __Plasma3__GetEloByAccountID *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__GetEloByAccountID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__GetEloByAccountID * SOAP_FMAC4 soap_in___Plasma3__GetEloByAccountID(struct soap *soap, const char *tag, struct __Plasma3__GetEloByAccountID *a, const char *type)
{
	short soap_flag_Plasma__GetEloByAccountID = 1;
	short soap_flag;
	a = (struct __Plasma3__GetEloByAccountID *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__GetEloByAccountID, sizeof(struct __Plasma3__GetEloByAccountID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__GetEloByAccountID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloByAccountID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloByAccountID(soap, "Plasma:GetEloByAccountID", &a->Plasma__GetEloByAccountID, ""))
				{	soap_flag_Plasma__GetEloByAccountID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__GetEloByAccountID * SOAP_FMAC6 soap_new___Plasma3__GetEloByAccountID(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__GetEloByAccountID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__GetEloByAccountID(struct soap *soap, struct __Plasma3__GetEloByAccountID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__GetEloByAccountID * SOAP_FMAC4 soap_instantiate___Plasma3__GetEloByAccountID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__GetEloByAccountID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__GetEloByAccountID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__GetEloByAccountID;
		if (size)
			*size = sizeof(struct __Plasma3__GetEloByAccountID);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__GetEloByAccountID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__GetEloByAccountID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__GetEloByAccountID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__GetEloByAccountID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__GetEloByAccountID %p -> %p\n", q, p));
	*(struct __Plasma3__GetEloByAccountID*)p = *(struct __Plasma3__GetEloByAccountID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__DownloadFile(struct soap *soap, struct __Plasma3__DownloadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__DownloadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__DownloadFile(struct soap *soap, const struct __Plasma3__DownloadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__DownloadFile(soap, &a->Plasma__DownloadFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__DownloadFile(struct soap *soap, const struct __Plasma3__DownloadFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__DownloadFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__DownloadFile(struct soap *soap, const char *tag, int id, const struct __Plasma3__DownloadFile *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__DownloadFile(soap, "Plasma:DownloadFile", -1, &a->Plasma__DownloadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__DownloadFile * SOAP_FMAC4 soap_get___Plasma3__DownloadFile(struct soap *soap, struct __Plasma3__DownloadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__DownloadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__DownloadFile * SOAP_FMAC4 soap_in___Plasma3__DownloadFile(struct soap *soap, const char *tag, struct __Plasma3__DownloadFile *a, const char *type)
{
	short soap_flag_Plasma__DownloadFile = 1;
	short soap_flag;
	a = (struct __Plasma3__DownloadFile *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__DownloadFile, sizeof(struct __Plasma3__DownloadFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__DownloadFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__DownloadFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__DownloadFile(soap, "Plasma:DownloadFile", &a->Plasma__DownloadFile, ""))
				{	soap_flag_Plasma__DownloadFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__DownloadFile * SOAP_FMAC6 soap_new___Plasma3__DownloadFile(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__DownloadFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__DownloadFile(struct soap *soap, struct __Plasma3__DownloadFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__DownloadFile * SOAP_FMAC4 soap_instantiate___Plasma3__DownloadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__DownloadFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__DownloadFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__DownloadFile;
		if (size)
			*size = sizeof(struct __Plasma3__DownloadFile);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__DownloadFile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__DownloadFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__DownloadFile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__DownloadFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__DownloadFile %p -> %p\n", q, p));
	*(struct __Plasma3__DownloadFile*)p = *(struct __Plasma3__DownloadFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__BalanceTeams(struct soap *soap, struct __Plasma3__BalanceTeams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__BalanceTeams = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__BalanceTeams(struct soap *soap, const struct __Plasma3__BalanceTeams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__BalanceTeams(soap, &a->Plasma__BalanceTeams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__BalanceTeams(struct soap *soap, const struct __Plasma3__BalanceTeams *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__BalanceTeams(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__BalanceTeams(struct soap *soap, const char *tag, int id, const struct __Plasma3__BalanceTeams *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__BalanceTeams(soap, "Plasma:BalanceTeams", -1, &a->Plasma__BalanceTeams, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__BalanceTeams * SOAP_FMAC4 soap_get___Plasma3__BalanceTeams(struct soap *soap, struct __Plasma3__BalanceTeams *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__BalanceTeams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__BalanceTeams * SOAP_FMAC4 soap_in___Plasma3__BalanceTeams(struct soap *soap, const char *tag, struct __Plasma3__BalanceTeams *a, const char *type)
{
	short soap_flag_Plasma__BalanceTeams = 1;
	short soap_flag;
	a = (struct __Plasma3__BalanceTeams *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__BalanceTeams, sizeof(struct __Plasma3__BalanceTeams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__BalanceTeams(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__BalanceTeams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__BalanceTeams(soap, "Plasma:BalanceTeams", &a->Plasma__BalanceTeams, ""))
				{	soap_flag_Plasma__BalanceTeams--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__BalanceTeams * SOAP_FMAC6 soap_new___Plasma3__BalanceTeams(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__BalanceTeams(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__BalanceTeams(struct soap *soap, struct __Plasma3__BalanceTeams *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__BalanceTeams * SOAP_FMAC4 soap_instantiate___Plasma3__BalanceTeams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__BalanceTeams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__BalanceTeams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__BalanceTeams;
		if (size)
			*size = sizeof(struct __Plasma3__BalanceTeams);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__BalanceTeams[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__BalanceTeams);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__BalanceTeams*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__BalanceTeams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__BalanceTeams %p -> %p\n", q, p));
	*(struct __Plasma3__BalanceTeams*)p = *(struct __Plasma3__BalanceTeams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma3__AutohostPlayerJoined(struct soap *soap, struct __Plasma3__AutohostPlayerJoined *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__AutohostPlayerJoined = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma3__AutohostPlayerJoined(struct soap *soap, const struct __Plasma3__AutohostPlayerJoined *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__AutohostPlayerJoined(soap, &a->Plasma__AutohostPlayerJoined);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma3__AutohostPlayerJoined(struct soap *soap, const struct __Plasma3__AutohostPlayerJoined *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma3__AutohostPlayerJoined(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma3__AutohostPlayerJoined(struct soap *soap, const char *tag, int id, const struct __Plasma3__AutohostPlayerJoined *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__AutohostPlayerJoined(soap, "Plasma:AutohostPlayerJoined", -1, &a->Plasma__AutohostPlayerJoined, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma3__AutohostPlayerJoined * SOAP_FMAC4 soap_get___Plasma3__AutohostPlayerJoined(struct soap *soap, struct __Plasma3__AutohostPlayerJoined *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma3__AutohostPlayerJoined(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma3__AutohostPlayerJoined * SOAP_FMAC4 soap_in___Plasma3__AutohostPlayerJoined(struct soap *soap, const char *tag, struct __Plasma3__AutohostPlayerJoined *a, const char *type)
{
	short soap_flag_Plasma__AutohostPlayerJoined = 1;
	short soap_flag;
	a = (struct __Plasma3__AutohostPlayerJoined *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma3__AutohostPlayerJoined, sizeof(struct __Plasma3__AutohostPlayerJoined), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma3__AutohostPlayerJoined(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__AutohostPlayerJoined && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__AutohostPlayerJoined(soap, "Plasma:AutohostPlayerJoined", &a->Plasma__AutohostPlayerJoined, ""))
				{	soap_flag_Plasma__AutohostPlayerJoined--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma3__AutohostPlayerJoined * SOAP_FMAC6 soap_new___Plasma3__AutohostPlayerJoined(struct soap *soap, int n)
{	return soap_instantiate___Plasma3__AutohostPlayerJoined(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma3__AutohostPlayerJoined(struct soap *soap, struct __Plasma3__AutohostPlayerJoined *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma3__AutohostPlayerJoined * SOAP_FMAC4 soap_instantiate___Plasma3__AutohostPlayerJoined(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma3__AutohostPlayerJoined(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma3__AutohostPlayerJoined, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma3__AutohostPlayerJoined;
		if (size)
			*size = sizeof(struct __Plasma3__AutohostPlayerJoined);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma3__AutohostPlayerJoined[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma3__AutohostPlayerJoined);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma3__AutohostPlayerJoined*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma3__AutohostPlayerJoined(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma3__AutohostPlayerJoined %p -> %p\n", q, p));
	*(struct __Plasma3__AutohostPlayerJoined*)p = *(struct __Plasma3__AutohostPlayerJoined*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__VerifyAccountData(struct soap *soap, struct __Plasma2__VerifyAccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__VerifyAccountData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__VerifyAccountData(struct soap *soap, const struct __Plasma2__VerifyAccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__VerifyAccountData(soap, &a->Plasma__VerifyAccountData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__VerifyAccountData(struct soap *soap, const struct __Plasma2__VerifyAccountData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__VerifyAccountData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__VerifyAccountData(struct soap *soap, const char *tag, int id, const struct __Plasma2__VerifyAccountData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__VerifyAccountData(soap, "Plasma:VerifyAccountData", -1, &a->Plasma__VerifyAccountData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__VerifyAccountData * SOAP_FMAC4 soap_get___Plasma2__VerifyAccountData(struct soap *soap, struct __Plasma2__VerifyAccountData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__VerifyAccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__VerifyAccountData * SOAP_FMAC4 soap_in___Plasma2__VerifyAccountData(struct soap *soap, const char *tag, struct __Plasma2__VerifyAccountData *a, const char *type)
{
	short soap_flag_Plasma__VerifyAccountData = 1;
	short soap_flag;
	a = (struct __Plasma2__VerifyAccountData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__VerifyAccountData, sizeof(struct __Plasma2__VerifyAccountData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__VerifyAccountData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__VerifyAccountData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__VerifyAccountData(soap, "Plasma:VerifyAccountData", &a->Plasma__VerifyAccountData, ""))
				{	soap_flag_Plasma__VerifyAccountData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__VerifyAccountData * SOAP_FMAC6 soap_new___Plasma2__VerifyAccountData(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__VerifyAccountData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__VerifyAccountData(struct soap *soap, struct __Plasma2__VerifyAccountData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__VerifyAccountData * SOAP_FMAC4 soap_instantiate___Plasma2__VerifyAccountData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__VerifyAccountData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__VerifyAccountData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__VerifyAccountData;
		if (size)
			*size = sizeof(struct __Plasma2__VerifyAccountData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__VerifyAccountData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__VerifyAccountData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__VerifyAccountData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__VerifyAccountData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__VerifyAccountData %p -> %p\n", q, p));
	*(struct __Plasma2__VerifyAccountData*)p = *(struct __Plasma2__VerifyAccountData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__SubmitStackTrace(struct soap *soap, struct __Plasma2__SubmitStackTrace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitStackTrace = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__SubmitStackTrace(struct soap *soap, const struct __Plasma2__SubmitStackTrace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitStackTrace(soap, &a->Plasma__SubmitStackTrace);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__SubmitStackTrace(struct soap *soap, const struct __Plasma2__SubmitStackTrace *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__SubmitStackTrace(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__SubmitStackTrace(struct soap *soap, const char *tag, int id, const struct __Plasma2__SubmitStackTrace *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitStackTrace(soap, "Plasma:SubmitStackTrace", -1, &a->Plasma__SubmitStackTrace, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__SubmitStackTrace * SOAP_FMAC4 soap_get___Plasma2__SubmitStackTrace(struct soap *soap, struct __Plasma2__SubmitStackTrace *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__SubmitStackTrace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__SubmitStackTrace * SOAP_FMAC4 soap_in___Plasma2__SubmitStackTrace(struct soap *soap, const char *tag, struct __Plasma2__SubmitStackTrace *a, const char *type)
{
	short soap_flag_Plasma__SubmitStackTrace = 1;
	short soap_flag;
	a = (struct __Plasma2__SubmitStackTrace *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__SubmitStackTrace, sizeof(struct __Plasma2__SubmitStackTrace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__SubmitStackTrace(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitStackTrace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitStackTrace(soap, "Plasma:SubmitStackTrace", &a->Plasma__SubmitStackTrace, ""))
				{	soap_flag_Plasma__SubmitStackTrace--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__SubmitStackTrace * SOAP_FMAC6 soap_new___Plasma2__SubmitStackTrace(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__SubmitStackTrace(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__SubmitStackTrace(struct soap *soap, struct __Plasma2__SubmitStackTrace *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__SubmitStackTrace * SOAP_FMAC4 soap_instantiate___Plasma2__SubmitStackTrace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__SubmitStackTrace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__SubmitStackTrace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__SubmitStackTrace;
		if (size)
			*size = sizeof(struct __Plasma2__SubmitStackTrace);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__SubmitStackTrace[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__SubmitStackTrace);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__SubmitStackTrace*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__SubmitStackTrace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__SubmitStackTrace %p -> %p\n", q, p));
	*(struct __Plasma2__SubmitStackTrace*)p = *(struct __Plasma2__SubmitStackTrace*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__SubmitSpringBattleResult(struct soap *soap, struct __Plasma2__SubmitSpringBattleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitSpringBattleResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__SubmitSpringBattleResult(struct soap *soap, const struct __Plasma2__SubmitSpringBattleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitSpringBattleResult(soap, &a->Plasma__SubmitSpringBattleResult);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__SubmitSpringBattleResult(struct soap *soap, const struct __Plasma2__SubmitSpringBattleResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__SubmitSpringBattleResult(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__SubmitSpringBattleResult(struct soap *soap, const char *tag, int id, const struct __Plasma2__SubmitSpringBattleResult *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitSpringBattleResult(soap, "Plasma:SubmitSpringBattleResult", -1, &a->Plasma__SubmitSpringBattleResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__SubmitSpringBattleResult * SOAP_FMAC4 soap_get___Plasma2__SubmitSpringBattleResult(struct soap *soap, struct __Plasma2__SubmitSpringBattleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__SubmitSpringBattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__SubmitSpringBattleResult * SOAP_FMAC4 soap_in___Plasma2__SubmitSpringBattleResult(struct soap *soap, const char *tag, struct __Plasma2__SubmitSpringBattleResult *a, const char *type)
{
	short soap_flag_Plasma__SubmitSpringBattleResult = 1;
	short soap_flag;
	a = (struct __Plasma2__SubmitSpringBattleResult *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__SubmitSpringBattleResult, sizeof(struct __Plasma2__SubmitSpringBattleResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__SubmitSpringBattleResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitSpringBattleResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitSpringBattleResult(soap, "Plasma:SubmitSpringBattleResult", &a->Plasma__SubmitSpringBattleResult, ""))
				{	soap_flag_Plasma__SubmitSpringBattleResult--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__SubmitSpringBattleResult * SOAP_FMAC6 soap_new___Plasma2__SubmitSpringBattleResult(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__SubmitSpringBattleResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__SubmitSpringBattleResult(struct soap *soap, struct __Plasma2__SubmitSpringBattleResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__SubmitSpringBattleResult * SOAP_FMAC4 soap_instantiate___Plasma2__SubmitSpringBattleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__SubmitSpringBattleResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__SubmitSpringBattleResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__SubmitSpringBattleResult;
		if (size)
			*size = sizeof(struct __Plasma2__SubmitSpringBattleResult);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__SubmitSpringBattleResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__SubmitSpringBattleResult);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__SubmitSpringBattleResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__SubmitSpringBattleResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__SubmitSpringBattleResult %p -> %p\n", q, p));
	*(struct __Plasma2__SubmitSpringBattleResult*)p = *(struct __Plasma2__SubmitSpringBattleResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__SubmitMissionScore(struct soap *soap, struct __Plasma2__SubmitMissionScore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__SubmitMissionScore = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__SubmitMissionScore(struct soap *soap, const struct __Plasma2__SubmitMissionScore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__SubmitMissionScore(soap, &a->Plasma__SubmitMissionScore);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__SubmitMissionScore(struct soap *soap, const struct __Plasma2__SubmitMissionScore *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__SubmitMissionScore(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__SubmitMissionScore(struct soap *soap, const char *tag, int id, const struct __Plasma2__SubmitMissionScore *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__SubmitMissionScore(soap, "Plasma:SubmitMissionScore", -1, &a->Plasma__SubmitMissionScore, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__SubmitMissionScore * SOAP_FMAC4 soap_get___Plasma2__SubmitMissionScore(struct soap *soap, struct __Plasma2__SubmitMissionScore *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__SubmitMissionScore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__SubmitMissionScore * SOAP_FMAC4 soap_in___Plasma2__SubmitMissionScore(struct soap *soap, const char *tag, struct __Plasma2__SubmitMissionScore *a, const char *type)
{
	short soap_flag_Plasma__SubmitMissionScore = 1;
	short soap_flag;
	a = (struct __Plasma2__SubmitMissionScore *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__SubmitMissionScore, sizeof(struct __Plasma2__SubmitMissionScore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__SubmitMissionScore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__SubmitMissionScore && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__SubmitMissionScore(soap, "Plasma:SubmitMissionScore", &a->Plasma__SubmitMissionScore, ""))
				{	soap_flag_Plasma__SubmitMissionScore--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__SubmitMissionScore * SOAP_FMAC6 soap_new___Plasma2__SubmitMissionScore(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__SubmitMissionScore(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__SubmitMissionScore(struct soap *soap, struct __Plasma2__SubmitMissionScore *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__SubmitMissionScore * SOAP_FMAC4 soap_instantiate___Plasma2__SubmitMissionScore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__SubmitMissionScore(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__SubmitMissionScore, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__SubmitMissionScore;
		if (size)
			*size = sizeof(struct __Plasma2__SubmitMissionScore);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__SubmitMissionScore[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__SubmitMissionScore);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__SubmitMissionScore*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__SubmitMissionScore(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__SubmitMissionScore %p -> %p\n", q, p));
	*(struct __Plasma2__SubmitMissionScore*)p = *(struct __Plasma2__SubmitMissionScore*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__RegisterResource(struct soap *soap, struct __Plasma2__RegisterResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__RegisterResource = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__RegisterResource(struct soap *soap, const struct __Plasma2__RegisterResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__RegisterResource(soap, &a->Plasma__RegisterResource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__RegisterResource(struct soap *soap, const struct __Plasma2__RegisterResource *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__RegisterResource(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__RegisterResource(struct soap *soap, const char *tag, int id, const struct __Plasma2__RegisterResource *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__RegisterResource(soap, "Plasma:RegisterResource", -1, &a->Plasma__RegisterResource, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__RegisterResource * SOAP_FMAC4 soap_get___Plasma2__RegisterResource(struct soap *soap, struct __Plasma2__RegisterResource *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__RegisterResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__RegisterResource * SOAP_FMAC4 soap_in___Plasma2__RegisterResource(struct soap *soap, const char *tag, struct __Plasma2__RegisterResource *a, const char *type)
{
	short soap_flag_Plasma__RegisterResource = 1;
	short soap_flag;
	a = (struct __Plasma2__RegisterResource *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__RegisterResource, sizeof(struct __Plasma2__RegisterResource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__RegisterResource(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__RegisterResource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__RegisterResource(soap, "Plasma:RegisterResource", &a->Plasma__RegisterResource, ""))
				{	soap_flag_Plasma__RegisterResource--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__RegisterResource * SOAP_FMAC6 soap_new___Plasma2__RegisterResource(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__RegisterResource(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__RegisterResource(struct soap *soap, struct __Plasma2__RegisterResource *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__RegisterResource * SOAP_FMAC4 soap_instantiate___Plasma2__RegisterResource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__RegisterResource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__RegisterResource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__RegisterResource;
		if (size)
			*size = sizeof(struct __Plasma2__RegisterResource);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__RegisterResource[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__RegisterResource);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__RegisterResource*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__RegisterResource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__RegisterResource %p -> %p\n", q, p));
	*(struct __Plasma2__RegisterResource*)p = *(struct __Plasma2__RegisterResource*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__NotifyMissionRun(struct soap *soap, struct __Plasma2__NotifyMissionRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__NotifyMissionRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__NotifyMissionRun(struct soap *soap, const struct __Plasma2__NotifyMissionRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__NotifyMissionRun(soap, &a->Plasma__NotifyMissionRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__NotifyMissionRun(struct soap *soap, const struct __Plasma2__NotifyMissionRun *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__NotifyMissionRun(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__NotifyMissionRun(struct soap *soap, const char *tag, int id, const struct __Plasma2__NotifyMissionRun *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__NotifyMissionRun(soap, "Plasma:NotifyMissionRun", -1, &a->Plasma__NotifyMissionRun, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__NotifyMissionRun * SOAP_FMAC4 soap_get___Plasma2__NotifyMissionRun(struct soap *soap, struct __Plasma2__NotifyMissionRun *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__NotifyMissionRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__NotifyMissionRun * SOAP_FMAC4 soap_in___Plasma2__NotifyMissionRun(struct soap *soap, const char *tag, struct __Plasma2__NotifyMissionRun *a, const char *type)
{
	short soap_flag_Plasma__NotifyMissionRun = 1;
	short soap_flag;
	a = (struct __Plasma2__NotifyMissionRun *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__NotifyMissionRun, sizeof(struct __Plasma2__NotifyMissionRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__NotifyMissionRun(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__NotifyMissionRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__NotifyMissionRun(soap, "Plasma:NotifyMissionRun", &a->Plasma__NotifyMissionRun, ""))
				{	soap_flag_Plasma__NotifyMissionRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__NotifyMissionRun * SOAP_FMAC6 soap_new___Plasma2__NotifyMissionRun(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__NotifyMissionRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__NotifyMissionRun(struct soap *soap, struct __Plasma2__NotifyMissionRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__NotifyMissionRun * SOAP_FMAC4 soap_instantiate___Plasma2__NotifyMissionRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__NotifyMissionRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__NotifyMissionRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__NotifyMissionRun;
		if (size)
			*size = sizeof(struct __Plasma2__NotifyMissionRun);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__NotifyMissionRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__NotifyMissionRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__NotifyMissionRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__NotifyMissionRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__NotifyMissionRun %p -> %p\n", q, p));
	*(struct __Plasma2__NotifyMissionRun*)p = *(struct __Plasma2__NotifyMissionRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma2__GetSpringBattleStartSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetSpringBattleStartSetup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetSpringBattleStartSetup(struct soap *soap, const struct __Plasma2__GetSpringBattleStartSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetup(soap, &a->Plasma__GetSpringBattleStartSetup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetSpringBattleStartSetup(struct soap *soap, const struct __Plasma2__GetSpringBattleStartSetup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetSpringBattleStartSetup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetSpringBattleStartSetup(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetSpringBattleStartSetup *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetSpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetup", -1, &a->Plasma__GetSpringBattleStartSetup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetSpringBattleStartSetup * SOAP_FMAC4 soap_get___Plasma2__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma2__GetSpringBattleStartSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetSpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetSpringBattleStartSetup * SOAP_FMAC4 soap_in___Plasma2__GetSpringBattleStartSetup(struct soap *soap, const char *tag, struct __Plasma2__GetSpringBattleStartSetup *a, const char *type)
{
	short soap_flag_Plasma__GetSpringBattleStartSetup = 1;
	short soap_flag;
	a = (struct __Plasma2__GetSpringBattleStartSetup *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetSpringBattleStartSetup, sizeof(struct __Plasma2__GetSpringBattleStartSetup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetSpringBattleStartSetup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetSpringBattleStartSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetSpringBattleStartSetup(soap, "Plasma:GetSpringBattleStartSetup", &a->Plasma__GetSpringBattleStartSetup, ""))
				{	soap_flag_Plasma__GetSpringBattleStartSetup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetSpringBattleStartSetup * SOAP_FMAC6 soap_new___Plasma2__GetSpringBattleStartSetup(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetSpringBattleStartSetup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetSpringBattleStartSetup(struct soap *soap, struct __Plasma2__GetSpringBattleStartSetup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetSpringBattleStartSetup * SOAP_FMAC4 soap_instantiate___Plasma2__GetSpringBattleStartSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetSpringBattleStartSetup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetSpringBattleStartSetup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetSpringBattleStartSetup;
		if (size)
			*size = sizeof(struct __Plasma2__GetSpringBattleStartSetup);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetSpringBattleStartSetup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetSpringBattleStartSetup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetSpringBattleStartSetup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetSpringBattleStartSetup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetSpringBattleStartSetup %p -> %p\n", q, p));
	*(struct __Plasma2__GetSpringBattleStartSetup*)p = *(struct __Plasma2__GetSpringBattleStartSetup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetScriptMissionData(struct soap *soap, struct __Plasma2__GetScriptMissionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetScriptMissionData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetScriptMissionData(struct soap *soap, const struct __Plasma2__GetScriptMissionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetScriptMissionData(soap, &a->Plasma__GetScriptMissionData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetScriptMissionData(struct soap *soap, const struct __Plasma2__GetScriptMissionData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetScriptMissionData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetScriptMissionData(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetScriptMissionData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetScriptMissionData(soap, "Plasma:GetScriptMissionData", -1, &a->Plasma__GetScriptMissionData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetScriptMissionData * SOAP_FMAC4 soap_get___Plasma2__GetScriptMissionData(struct soap *soap, struct __Plasma2__GetScriptMissionData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetScriptMissionData * SOAP_FMAC4 soap_in___Plasma2__GetScriptMissionData(struct soap *soap, const char *tag, struct __Plasma2__GetScriptMissionData *a, const char *type)
{
	short soap_flag_Plasma__GetScriptMissionData = 1;
	short soap_flag;
	a = (struct __Plasma2__GetScriptMissionData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetScriptMissionData, sizeof(struct __Plasma2__GetScriptMissionData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetScriptMissionData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetScriptMissionData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetScriptMissionData(soap, "Plasma:GetScriptMissionData", &a->Plasma__GetScriptMissionData, ""))
				{	soap_flag_Plasma__GetScriptMissionData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetScriptMissionData * SOAP_FMAC6 soap_new___Plasma2__GetScriptMissionData(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetScriptMissionData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetScriptMissionData(struct soap *soap, struct __Plasma2__GetScriptMissionData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetScriptMissionData * SOAP_FMAC4 soap_instantiate___Plasma2__GetScriptMissionData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetScriptMissionData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetScriptMissionData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetScriptMissionData;
		if (size)
			*size = sizeof(struct __Plasma2__GetScriptMissionData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetScriptMissionData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetScriptMissionData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetScriptMissionData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetScriptMissionData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetScriptMissionData %p -> %p\n", q, p));
	*(struct __Plasma2__GetScriptMissionData*)p = *(struct __Plasma2__GetScriptMissionData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetResourceList(struct soap *soap, struct __Plasma2__GetResourceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetResourceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetResourceList(struct soap *soap, const struct __Plasma2__GetResourceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetResourceList(soap, &a->Plasma__GetResourceList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetResourceList(struct soap *soap, const struct __Plasma2__GetResourceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetResourceList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetResourceList(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetResourceList *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetResourceList(soap, "Plasma:GetResourceList", -1, &a->Plasma__GetResourceList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetResourceList * SOAP_FMAC4 soap_get___Plasma2__GetResourceList(struct soap *soap, struct __Plasma2__GetResourceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetResourceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetResourceList * SOAP_FMAC4 soap_in___Plasma2__GetResourceList(struct soap *soap, const char *tag, struct __Plasma2__GetResourceList *a, const char *type)
{
	short soap_flag_Plasma__GetResourceList = 1;
	short soap_flag;
	a = (struct __Plasma2__GetResourceList *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetResourceList, sizeof(struct __Plasma2__GetResourceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetResourceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetResourceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetResourceList(soap, "Plasma:GetResourceList", &a->Plasma__GetResourceList, ""))
				{	soap_flag_Plasma__GetResourceList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetResourceList * SOAP_FMAC6 soap_new___Plasma2__GetResourceList(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetResourceList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetResourceList(struct soap *soap, struct __Plasma2__GetResourceList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetResourceList * SOAP_FMAC4 soap_instantiate___Plasma2__GetResourceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetResourceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetResourceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetResourceList;
		if (size)
			*size = sizeof(struct __Plasma2__GetResourceList);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetResourceList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetResourceList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetResourceList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetResourceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetResourceList %p -> %p\n", q, p));
	*(struct __Plasma2__GetResourceList*)p = *(struct __Plasma2__GetResourceList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetResourceData(struct soap *soap, struct __Plasma2__GetResourceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetResourceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetResourceData(struct soap *soap, const struct __Plasma2__GetResourceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetResourceData(soap, &a->Plasma__GetResourceData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetResourceData(struct soap *soap, const struct __Plasma2__GetResourceData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetResourceData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetResourceData(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetResourceData *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetResourceData(soap, "Plasma:GetResourceData", -1, &a->Plasma__GetResourceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetResourceData * SOAP_FMAC4 soap_get___Plasma2__GetResourceData(struct soap *soap, struct __Plasma2__GetResourceData *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetResourceData * SOAP_FMAC4 soap_in___Plasma2__GetResourceData(struct soap *soap, const char *tag, struct __Plasma2__GetResourceData *a, const char *type)
{
	short soap_flag_Plasma__GetResourceData = 1;
	short soap_flag;
	a = (struct __Plasma2__GetResourceData *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetResourceData, sizeof(struct __Plasma2__GetResourceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetResourceData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetResourceData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetResourceData(soap, "Plasma:GetResourceData", &a->Plasma__GetResourceData, ""))
				{	soap_flag_Plasma__GetResourceData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetResourceData * SOAP_FMAC6 soap_new___Plasma2__GetResourceData(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetResourceData(struct soap *soap, struct __Plasma2__GetResourceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetResourceData * SOAP_FMAC4 soap_instantiate___Plasma2__GetResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetResourceData;
		if (size)
			*size = sizeof(struct __Plasma2__GetResourceData);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetResourceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetResourceData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetResourceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetResourceData %p -> %p\n", q, p));
	*(struct __Plasma2__GetResourceData*)p = *(struct __Plasma2__GetResourceData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetRecommendedMap(struct soap *soap, struct __Plasma2__GetRecommendedMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetRecommendedMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetRecommendedMap(struct soap *soap, const struct __Plasma2__GetRecommendedMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetRecommendedMap(soap, &a->Plasma__GetRecommendedMap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetRecommendedMap(struct soap *soap, const struct __Plasma2__GetRecommendedMap *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetRecommendedMap(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetRecommendedMap(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetRecommendedMap *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetRecommendedMap(soap, "Plasma:GetRecommendedMap", -1, &a->Plasma__GetRecommendedMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetRecommendedMap * SOAP_FMAC4 soap_get___Plasma2__GetRecommendedMap(struct soap *soap, struct __Plasma2__GetRecommendedMap *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetRecommendedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetRecommendedMap * SOAP_FMAC4 soap_in___Plasma2__GetRecommendedMap(struct soap *soap, const char *tag, struct __Plasma2__GetRecommendedMap *a, const char *type)
{
	short soap_flag_Plasma__GetRecommendedMap = 1;
	short soap_flag;
	a = (struct __Plasma2__GetRecommendedMap *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetRecommendedMap, sizeof(struct __Plasma2__GetRecommendedMap), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetRecommendedMap(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetRecommendedMap && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetRecommendedMap(soap, "Plasma:GetRecommendedMap", &a->Plasma__GetRecommendedMap, ""))
				{	soap_flag_Plasma__GetRecommendedMap--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetRecommendedMap * SOAP_FMAC6 soap_new___Plasma2__GetRecommendedMap(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetRecommendedMap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetRecommendedMap(struct soap *soap, struct __Plasma2__GetRecommendedMap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetRecommendedMap * SOAP_FMAC4 soap_instantiate___Plasma2__GetRecommendedMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetRecommendedMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetRecommendedMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetRecommendedMap;
		if (size)
			*size = sizeof(struct __Plasma2__GetRecommendedMap);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetRecommendedMap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetRecommendedMap);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetRecommendedMap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetRecommendedMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetRecommendedMap %p -> %p\n", q, p));
	*(struct __Plasma2__GetRecommendedMap*)p = *(struct __Plasma2__GetRecommendedMap*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetEloTop10(struct soap *soap, struct __Plasma2__GetEloTop10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloTop10 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetEloTop10(struct soap *soap, const struct __Plasma2__GetEloTop10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloTop10(soap, &a->Plasma__GetEloTop10);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetEloTop10(struct soap *soap, const struct __Plasma2__GetEloTop10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetEloTop10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetEloTop10(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetEloTop10 *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloTop10(soap, "Plasma:GetEloTop10", -1, &a->Plasma__GetEloTop10, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetEloTop10 * SOAP_FMAC4 soap_get___Plasma2__GetEloTop10(struct soap *soap, struct __Plasma2__GetEloTop10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetEloTop10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetEloTop10 * SOAP_FMAC4 soap_in___Plasma2__GetEloTop10(struct soap *soap, const char *tag, struct __Plasma2__GetEloTop10 *a, const char *type)
{
	short soap_flag_Plasma__GetEloTop10 = 1;
	short soap_flag;
	a = (struct __Plasma2__GetEloTop10 *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetEloTop10, sizeof(struct __Plasma2__GetEloTop10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetEloTop10(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloTop10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloTop10(soap, "Plasma:GetEloTop10", &a->Plasma__GetEloTop10, ""))
				{	soap_flag_Plasma__GetEloTop10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetEloTop10 * SOAP_FMAC6 soap_new___Plasma2__GetEloTop10(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetEloTop10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetEloTop10(struct soap *soap, struct __Plasma2__GetEloTop10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetEloTop10 * SOAP_FMAC4 soap_instantiate___Plasma2__GetEloTop10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetEloTop10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetEloTop10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetEloTop10;
		if (size)
			*size = sizeof(struct __Plasma2__GetEloTop10);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetEloTop10[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetEloTop10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetEloTop10*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetEloTop10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetEloTop10 %p -> %p\n", q, p));
	*(struct __Plasma2__GetEloTop10*)p = *(struct __Plasma2__GetEloTop10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetEloByName(struct soap *soap, struct __Plasma2__GetEloByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloByName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetEloByName(struct soap *soap, const struct __Plasma2__GetEloByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloByName(soap, &a->Plasma__GetEloByName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetEloByName(struct soap *soap, const struct __Plasma2__GetEloByName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetEloByName(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetEloByName(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetEloByName *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloByName(soap, "Plasma:GetEloByName", -1, &a->Plasma__GetEloByName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetEloByName * SOAP_FMAC4 soap_get___Plasma2__GetEloByName(struct soap *soap, struct __Plasma2__GetEloByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetEloByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetEloByName * SOAP_FMAC4 soap_in___Plasma2__GetEloByName(struct soap *soap, const char *tag, struct __Plasma2__GetEloByName *a, const char *type)
{
	short soap_flag_Plasma__GetEloByName = 1;
	short soap_flag;
	a = (struct __Plasma2__GetEloByName *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetEloByName, sizeof(struct __Plasma2__GetEloByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetEloByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloByName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloByName(soap, "Plasma:GetEloByName", &a->Plasma__GetEloByName, ""))
				{	soap_flag_Plasma__GetEloByName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetEloByName * SOAP_FMAC6 soap_new___Plasma2__GetEloByName(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetEloByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetEloByName(struct soap *soap, struct __Plasma2__GetEloByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetEloByName * SOAP_FMAC4 soap_instantiate___Plasma2__GetEloByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetEloByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetEloByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetEloByName;
		if (size)
			*size = sizeof(struct __Plasma2__GetEloByName);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetEloByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetEloByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetEloByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetEloByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetEloByName %p -> %p\n", q, p));
	*(struct __Plasma2__GetEloByName*)p = *(struct __Plasma2__GetEloByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__GetEloByAccountID(struct soap *soap, struct __Plasma2__GetEloByAccountID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__GetEloByAccountID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__GetEloByAccountID(struct soap *soap, const struct __Plasma2__GetEloByAccountID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__GetEloByAccountID(soap, &a->Plasma__GetEloByAccountID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__GetEloByAccountID(struct soap *soap, const struct __Plasma2__GetEloByAccountID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__GetEloByAccountID(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__GetEloByAccountID(struct soap *soap, const char *tag, int id, const struct __Plasma2__GetEloByAccountID *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__GetEloByAccountID(soap, "Plasma:GetEloByAccountID", -1, &a->Plasma__GetEloByAccountID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__GetEloByAccountID * SOAP_FMAC4 soap_get___Plasma2__GetEloByAccountID(struct soap *soap, struct __Plasma2__GetEloByAccountID *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__GetEloByAccountID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__GetEloByAccountID * SOAP_FMAC4 soap_in___Plasma2__GetEloByAccountID(struct soap *soap, const char *tag, struct __Plasma2__GetEloByAccountID *a, const char *type)
{
	short soap_flag_Plasma__GetEloByAccountID = 1;
	short soap_flag;
	a = (struct __Plasma2__GetEloByAccountID *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__GetEloByAccountID, sizeof(struct __Plasma2__GetEloByAccountID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__GetEloByAccountID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__GetEloByAccountID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__GetEloByAccountID(soap, "Plasma:GetEloByAccountID", &a->Plasma__GetEloByAccountID, ""))
				{	soap_flag_Plasma__GetEloByAccountID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__GetEloByAccountID * SOAP_FMAC6 soap_new___Plasma2__GetEloByAccountID(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__GetEloByAccountID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__GetEloByAccountID(struct soap *soap, struct __Plasma2__GetEloByAccountID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__GetEloByAccountID * SOAP_FMAC4 soap_instantiate___Plasma2__GetEloByAccountID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__GetEloByAccountID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__GetEloByAccountID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__GetEloByAccountID;
		if (size)
			*size = sizeof(struct __Plasma2__GetEloByAccountID);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__GetEloByAccountID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__GetEloByAccountID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__GetEloByAccountID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__GetEloByAccountID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__GetEloByAccountID %p -> %p\n", q, p));
	*(struct __Plasma2__GetEloByAccountID*)p = *(struct __Plasma2__GetEloByAccountID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__DownloadFile(struct soap *soap, struct __Plasma2__DownloadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__DownloadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__DownloadFile(struct soap *soap, const struct __Plasma2__DownloadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__DownloadFile(soap, &a->Plasma__DownloadFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__DownloadFile(struct soap *soap, const struct __Plasma2__DownloadFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__DownloadFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__DownloadFile(struct soap *soap, const char *tag, int id, const struct __Plasma2__DownloadFile *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__DownloadFile(soap, "Plasma:DownloadFile", -1, &a->Plasma__DownloadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__DownloadFile * SOAP_FMAC4 soap_get___Plasma2__DownloadFile(struct soap *soap, struct __Plasma2__DownloadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__DownloadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__DownloadFile * SOAP_FMAC4 soap_in___Plasma2__DownloadFile(struct soap *soap, const char *tag, struct __Plasma2__DownloadFile *a, const char *type)
{
	short soap_flag_Plasma__DownloadFile = 1;
	short soap_flag;
	a = (struct __Plasma2__DownloadFile *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__DownloadFile, sizeof(struct __Plasma2__DownloadFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__DownloadFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__DownloadFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__DownloadFile(soap, "Plasma:DownloadFile", &a->Plasma__DownloadFile, ""))
				{	soap_flag_Plasma__DownloadFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__DownloadFile * SOAP_FMAC6 soap_new___Plasma2__DownloadFile(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__DownloadFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__DownloadFile(struct soap *soap, struct __Plasma2__DownloadFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__DownloadFile * SOAP_FMAC4 soap_instantiate___Plasma2__DownloadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__DownloadFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__DownloadFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__DownloadFile;
		if (size)
			*size = sizeof(struct __Plasma2__DownloadFile);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__DownloadFile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__DownloadFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__DownloadFile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__DownloadFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__DownloadFile %p -> %p\n", q, p));
	*(struct __Plasma2__DownloadFile*)p = *(struct __Plasma2__DownloadFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__BalanceTeams(struct soap *soap, struct __Plasma2__BalanceTeams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__BalanceTeams = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__BalanceTeams(struct soap *soap, const struct __Plasma2__BalanceTeams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__BalanceTeams(soap, &a->Plasma__BalanceTeams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__BalanceTeams(struct soap *soap, const struct __Plasma2__BalanceTeams *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__BalanceTeams(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__BalanceTeams(struct soap *soap, const char *tag, int id, const struct __Plasma2__BalanceTeams *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__BalanceTeams(soap, "Plasma:BalanceTeams", -1, &a->Plasma__BalanceTeams, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__BalanceTeams * SOAP_FMAC4 soap_get___Plasma2__BalanceTeams(struct soap *soap, struct __Plasma2__BalanceTeams *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__BalanceTeams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__BalanceTeams * SOAP_FMAC4 soap_in___Plasma2__BalanceTeams(struct soap *soap, const char *tag, struct __Plasma2__BalanceTeams *a, const char *type)
{
	short soap_flag_Plasma__BalanceTeams = 1;
	short soap_flag;
	a = (struct __Plasma2__BalanceTeams *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__BalanceTeams, sizeof(struct __Plasma2__BalanceTeams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__BalanceTeams(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__BalanceTeams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__BalanceTeams(soap, "Plasma:BalanceTeams", &a->Plasma__BalanceTeams, ""))
				{	soap_flag_Plasma__BalanceTeams--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__BalanceTeams * SOAP_FMAC6 soap_new___Plasma2__BalanceTeams(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__BalanceTeams(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__BalanceTeams(struct soap *soap, struct __Plasma2__BalanceTeams *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__BalanceTeams * SOAP_FMAC4 soap_instantiate___Plasma2__BalanceTeams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__BalanceTeams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__BalanceTeams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__BalanceTeams;
		if (size)
			*size = sizeof(struct __Plasma2__BalanceTeams);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__BalanceTeams[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__BalanceTeams);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__BalanceTeams*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__BalanceTeams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__BalanceTeams %p -> %p\n", q, p));
	*(struct __Plasma2__BalanceTeams*)p = *(struct __Plasma2__BalanceTeams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Plasma2__AutohostPlayerJoined(struct soap *soap, struct __Plasma2__AutohostPlayerJoined *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Plasma__AutohostPlayerJoined = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Plasma2__AutohostPlayerJoined(struct soap *soap, const struct __Plasma2__AutohostPlayerJoined *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Plasma__AutohostPlayerJoined(soap, &a->Plasma__AutohostPlayerJoined);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Plasma2__AutohostPlayerJoined(struct soap *soap, const struct __Plasma2__AutohostPlayerJoined *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Plasma2__AutohostPlayerJoined(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Plasma2__AutohostPlayerJoined(struct soap *soap, const char *tag, int id, const struct __Plasma2__AutohostPlayerJoined *a, const char *type)
{
	if (soap_out_PointerTo_Plasma__AutohostPlayerJoined(soap, "Plasma:AutohostPlayerJoined", -1, &a->Plasma__AutohostPlayerJoined, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Plasma2__AutohostPlayerJoined * SOAP_FMAC4 soap_get___Plasma2__AutohostPlayerJoined(struct soap *soap, struct __Plasma2__AutohostPlayerJoined *p, const char *tag, const char *type)
{
	if ((p = soap_in___Plasma2__AutohostPlayerJoined(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __Plasma2__AutohostPlayerJoined * SOAP_FMAC4 soap_in___Plasma2__AutohostPlayerJoined(struct soap *soap, const char *tag, struct __Plasma2__AutohostPlayerJoined *a, const char *type)
{
	short soap_flag_Plasma__AutohostPlayerJoined = 1;
	short soap_flag;
	a = (struct __Plasma2__AutohostPlayerJoined *)soap_id_enter(soap, "", a, SOAP_TYPE___Plasma2__AutohostPlayerJoined, sizeof(struct __Plasma2__AutohostPlayerJoined), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Plasma2__AutohostPlayerJoined(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Plasma__AutohostPlayerJoined && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Plasma__AutohostPlayerJoined(soap, "Plasma:AutohostPlayerJoined", &a->Plasma__AutohostPlayerJoined, ""))
				{	soap_flag_Plasma__AutohostPlayerJoined--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __Plasma2__AutohostPlayerJoined * SOAP_FMAC6 soap_new___Plasma2__AutohostPlayerJoined(struct soap *soap, int n)
{	return soap_instantiate___Plasma2__AutohostPlayerJoined(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___Plasma2__AutohostPlayerJoined(struct soap *soap, struct __Plasma2__AutohostPlayerJoined *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __Plasma2__AutohostPlayerJoined * SOAP_FMAC4 soap_instantiate___Plasma2__AutohostPlayerJoined(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Plasma2__AutohostPlayerJoined(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___Plasma2__AutohostPlayerJoined, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __Plasma2__AutohostPlayerJoined;
		if (size)
			*size = sizeof(struct __Plasma2__AutohostPlayerJoined);
	}
	else
	{	cp->ptr = (void*)new struct __Plasma2__AutohostPlayerJoined[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Plasma2__AutohostPlayerJoined);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Plasma2__AutohostPlayerJoined*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Plasma2__AutohostPlayerJoined(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Plasma2__AutohostPlayerJoined %p -> %p\n", q, p));
	*(struct __Plasma2__AutohostPlayerJoined*)p = *(struct __Plasma2__AutohostPlayerJoined*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__VerifyAccountDataResponse(struct soap *soap, _Plasma__VerifyAccountDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__VerifyAccountDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__VerifyAccountDataResponse(struct soap *soap, _Plasma__VerifyAccountDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__VerifyAccountDataResponse);
	if (soap_out_PointerTo_Plasma__VerifyAccountDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__VerifyAccountDataResponse(struct soap *soap, const char *tag, int id, _Plasma__VerifyAccountDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__VerifyAccountDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountDataResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__VerifyAccountDataResponse(struct soap *soap, _Plasma__VerifyAccountDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__VerifyAccountDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__VerifyAccountDataResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__VerifyAccountDataResponse(struct soap *soap, const char *tag, _Plasma__VerifyAccountDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__VerifyAccountDataResponse **)soap_malloc(soap, sizeof(_Plasma__VerifyAccountDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__VerifyAccountDataResponse *)soap_instantiate__Plasma__VerifyAccountDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__VerifyAccountDataResponse ** p = (_Plasma__VerifyAccountDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__VerifyAccountDataResponse, sizeof(_Plasma__VerifyAccountDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__VerifyAccountData(struct soap *soap, _Plasma__VerifyAccountData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__VerifyAccountData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__VerifyAccountData(struct soap *soap, _Plasma__VerifyAccountData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__VerifyAccountData);
	if (soap_out_PointerTo_Plasma__VerifyAccountData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__VerifyAccountData(struct soap *soap, const char *tag, int id, _Plasma__VerifyAccountData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__VerifyAccountData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__VerifyAccountData ** SOAP_FMAC4 soap_get_PointerTo_Plasma__VerifyAccountData(struct soap *soap, _Plasma__VerifyAccountData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__VerifyAccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__VerifyAccountData ** SOAP_FMAC4 soap_in_PointerTo_Plasma__VerifyAccountData(struct soap *soap, const char *tag, _Plasma__VerifyAccountData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__VerifyAccountData **)soap_malloc(soap, sizeof(_Plasma__VerifyAccountData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__VerifyAccountData *)soap_instantiate__Plasma__VerifyAccountData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__VerifyAccountData ** p = (_Plasma__VerifyAccountData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__VerifyAccountData, sizeof(_Plasma__VerifyAccountData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitStackTraceResponse(struct soap *soap, _Plasma__SubmitStackTraceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitStackTraceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitStackTraceResponse(struct soap *soap, _Plasma__SubmitStackTraceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitStackTraceResponse);
	if (soap_out_PointerTo_Plasma__SubmitStackTraceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitStackTraceResponse(struct soap *soap, const char *tag, int id, _Plasma__SubmitStackTraceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitStackTraceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTraceResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitStackTraceResponse(struct soap *soap, _Plasma__SubmitStackTraceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitStackTraceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitStackTraceResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitStackTraceResponse(struct soap *soap, const char *tag, _Plasma__SubmitStackTraceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitStackTraceResponse **)soap_malloc(soap, sizeof(_Plasma__SubmitStackTraceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitStackTraceResponse *)soap_instantiate__Plasma__SubmitStackTraceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitStackTraceResponse ** p = (_Plasma__SubmitStackTraceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitStackTraceResponse, sizeof(_Plasma__SubmitStackTraceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitStackTrace(struct soap *soap, _Plasma__SubmitStackTrace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitStackTrace))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitStackTrace(struct soap *soap, _Plasma__SubmitStackTrace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitStackTrace);
	if (soap_out_PointerTo_Plasma__SubmitStackTrace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitStackTrace(struct soap *soap, const char *tag, int id, _Plasma__SubmitStackTrace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitStackTrace);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitStackTrace ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitStackTrace(struct soap *soap, _Plasma__SubmitStackTrace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitStackTrace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitStackTrace ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitStackTrace(struct soap *soap, const char *tag, _Plasma__SubmitStackTrace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitStackTrace **)soap_malloc(soap, sizeof(_Plasma__SubmitStackTrace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitStackTrace *)soap_instantiate__Plasma__SubmitStackTrace(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitStackTrace ** p = (_Plasma__SubmitStackTrace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitStackTrace, sizeof(_Plasma__SubmitStackTrace), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitSpringBattleResultResponse(struct soap *soap, _Plasma__SubmitSpringBattleResultResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitSpringBattleResultResponse(struct soap *soap, _Plasma__SubmitSpringBattleResultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResultResponse);
	if (soap_out_PointerTo_Plasma__SubmitSpringBattleResultResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitSpringBattleResultResponse(struct soap *soap, const char *tag, int id, _Plasma__SubmitSpringBattleResultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResultResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitSpringBattleResultResponse(struct soap *soap, _Plasma__SubmitSpringBattleResultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitSpringBattleResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResultResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitSpringBattleResultResponse(struct soap *soap, const char *tag, _Plasma__SubmitSpringBattleResultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitSpringBattleResultResponse **)soap_malloc(soap, sizeof(_Plasma__SubmitSpringBattleResultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitSpringBattleResultResponse *)soap_instantiate__Plasma__SubmitSpringBattleResultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitSpringBattleResultResponse ** p = (_Plasma__SubmitSpringBattleResultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitSpringBattleResultResponse, sizeof(_Plasma__SubmitSpringBattleResultResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitSpringBattleResult(struct soap *soap, _Plasma__SubmitSpringBattleResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitSpringBattleResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitSpringBattleResult(struct soap *soap, _Plasma__SubmitSpringBattleResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitSpringBattleResult);
	if (soap_out_PointerTo_Plasma__SubmitSpringBattleResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitSpringBattleResult(struct soap *soap, const char *tag, int id, _Plasma__SubmitSpringBattleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitSpringBattleResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResult ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitSpringBattleResult(struct soap *soap, _Plasma__SubmitSpringBattleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitSpringBattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitSpringBattleResult ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitSpringBattleResult(struct soap *soap, const char *tag, _Plasma__SubmitSpringBattleResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitSpringBattleResult **)soap_malloc(soap, sizeof(_Plasma__SubmitSpringBattleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitSpringBattleResult *)soap_instantiate__Plasma__SubmitSpringBattleResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitSpringBattleResult ** p = (_Plasma__SubmitSpringBattleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitSpringBattleResult, sizeof(_Plasma__SubmitSpringBattleResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitMissionScoreResponse(struct soap *soap, _Plasma__SubmitMissionScoreResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitMissionScoreResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitMissionScoreResponse(struct soap *soap, _Plasma__SubmitMissionScoreResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitMissionScoreResponse);
	if (soap_out_PointerTo_Plasma__SubmitMissionScoreResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitMissionScoreResponse(struct soap *soap, const char *tag, int id, _Plasma__SubmitMissionScoreResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitMissionScoreResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScoreResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitMissionScoreResponse(struct soap *soap, _Plasma__SubmitMissionScoreResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitMissionScoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitMissionScoreResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitMissionScoreResponse(struct soap *soap, const char *tag, _Plasma__SubmitMissionScoreResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitMissionScoreResponse **)soap_malloc(soap, sizeof(_Plasma__SubmitMissionScoreResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitMissionScoreResponse *)soap_instantiate__Plasma__SubmitMissionScoreResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitMissionScoreResponse ** p = (_Plasma__SubmitMissionScoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitMissionScoreResponse, sizeof(_Plasma__SubmitMissionScoreResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__SubmitMissionScore(struct soap *soap, _Plasma__SubmitMissionScore *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__SubmitMissionScore))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__SubmitMissionScore(struct soap *soap, _Plasma__SubmitMissionScore *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__SubmitMissionScore);
	if (soap_out_PointerTo_Plasma__SubmitMissionScore(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__SubmitMissionScore(struct soap *soap, const char *tag, int id, _Plasma__SubmitMissionScore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__SubmitMissionScore);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__SubmitMissionScore ** SOAP_FMAC4 soap_get_PointerTo_Plasma__SubmitMissionScore(struct soap *soap, _Plasma__SubmitMissionScore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__SubmitMissionScore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__SubmitMissionScore ** SOAP_FMAC4 soap_in_PointerTo_Plasma__SubmitMissionScore(struct soap *soap, const char *tag, _Plasma__SubmitMissionScore **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__SubmitMissionScore **)soap_malloc(soap, sizeof(_Plasma__SubmitMissionScore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__SubmitMissionScore *)soap_instantiate__Plasma__SubmitMissionScore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__SubmitMissionScore ** p = (_Plasma__SubmitMissionScore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__SubmitMissionScore, sizeof(_Plasma__SubmitMissionScore), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__RegisterResourceResponse(struct soap *soap, _Plasma__RegisterResourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__RegisterResourceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__RegisterResourceResponse(struct soap *soap, _Plasma__RegisterResourceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__RegisterResourceResponse);
	if (soap_out_PointerTo_Plasma__RegisterResourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__RegisterResourceResponse(struct soap *soap, const char *tag, int id, _Plasma__RegisterResourceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__RegisterResourceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__RegisterResourceResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__RegisterResourceResponse(struct soap *soap, _Plasma__RegisterResourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__RegisterResourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__RegisterResourceResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__RegisterResourceResponse(struct soap *soap, const char *tag, _Plasma__RegisterResourceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__RegisterResourceResponse **)soap_malloc(soap, sizeof(_Plasma__RegisterResourceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__RegisterResourceResponse *)soap_instantiate__Plasma__RegisterResourceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__RegisterResourceResponse ** p = (_Plasma__RegisterResourceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__RegisterResourceResponse, sizeof(_Plasma__RegisterResourceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__RegisterResource(struct soap *soap, _Plasma__RegisterResource *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__RegisterResource))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__RegisterResource(struct soap *soap, _Plasma__RegisterResource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__RegisterResource);
	if (soap_out_PointerTo_Plasma__RegisterResource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__RegisterResource(struct soap *soap, const char *tag, int id, _Plasma__RegisterResource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__RegisterResource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__RegisterResource ** SOAP_FMAC4 soap_get_PointerTo_Plasma__RegisterResource(struct soap *soap, _Plasma__RegisterResource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__RegisterResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__RegisterResource ** SOAP_FMAC4 soap_in_PointerTo_Plasma__RegisterResource(struct soap *soap, const char *tag, _Plasma__RegisterResource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__RegisterResource **)soap_malloc(soap, sizeof(_Plasma__RegisterResource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__RegisterResource *)soap_instantiate__Plasma__RegisterResource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__RegisterResource ** p = (_Plasma__RegisterResource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__RegisterResource, sizeof(_Plasma__RegisterResource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__NotifyMissionRunResponse(struct soap *soap, _Plasma__NotifyMissionRunResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__NotifyMissionRunResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__NotifyMissionRunResponse(struct soap *soap, _Plasma__NotifyMissionRunResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__NotifyMissionRunResponse);
	if (soap_out_PointerTo_Plasma__NotifyMissionRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__NotifyMissionRunResponse(struct soap *soap, const char *tag, int id, _Plasma__NotifyMissionRunResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__NotifyMissionRunResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRunResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__NotifyMissionRunResponse(struct soap *soap, _Plasma__NotifyMissionRunResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__NotifyMissionRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__NotifyMissionRunResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__NotifyMissionRunResponse(struct soap *soap, const char *tag, _Plasma__NotifyMissionRunResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__NotifyMissionRunResponse **)soap_malloc(soap, sizeof(_Plasma__NotifyMissionRunResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__NotifyMissionRunResponse *)soap_instantiate__Plasma__NotifyMissionRunResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__NotifyMissionRunResponse ** p = (_Plasma__NotifyMissionRunResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__NotifyMissionRunResponse, sizeof(_Plasma__NotifyMissionRunResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__NotifyMissionRun(struct soap *soap, _Plasma__NotifyMissionRun *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__NotifyMissionRun))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__NotifyMissionRun(struct soap *soap, _Plasma__NotifyMissionRun *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__NotifyMissionRun);
	if (soap_out_PointerTo_Plasma__NotifyMissionRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__NotifyMissionRun(struct soap *soap, const char *tag, int id, _Plasma__NotifyMissionRun *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__NotifyMissionRun);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__NotifyMissionRun ** SOAP_FMAC4 soap_get_PointerTo_Plasma__NotifyMissionRun(struct soap *soap, _Plasma__NotifyMissionRun **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__NotifyMissionRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__NotifyMissionRun ** SOAP_FMAC4 soap_in_PointerTo_Plasma__NotifyMissionRun(struct soap *soap, const char *tag, _Plasma__NotifyMissionRun **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__NotifyMissionRun **)soap_malloc(soap, sizeof(_Plasma__NotifyMissionRun *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__NotifyMissionRun *)soap_instantiate__Plasma__NotifyMissionRun(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__NotifyMissionRun ** p = (_Plasma__NotifyMissionRun **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__NotifyMissionRun, sizeof(_Plasma__NotifyMissionRun), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, _Plasma__GetSpringBattleStartSetupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, _Plasma__GetSpringBattleStartSetupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetupResponse);
	if (soap_out_PointerTo_Plasma__GetSpringBattleStartSetupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, const char *tag, int id, _Plasma__GetSpringBattleStartSetupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetupResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, _Plasma__GetSpringBattleStartSetupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetSpringBattleStartSetupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetupResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetSpringBattleStartSetupResponse(struct soap *soap, const char *tag, _Plasma__GetSpringBattleStartSetupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetSpringBattleStartSetupResponse **)soap_malloc(soap, sizeof(_Plasma__GetSpringBattleStartSetupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetSpringBattleStartSetupResponse *)soap_instantiate__Plasma__GetSpringBattleStartSetupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetSpringBattleStartSetupResponse ** p = (_Plasma__GetSpringBattleStartSetupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetSpringBattleStartSetupResponse, sizeof(_Plasma__GetSpringBattleStartSetupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetSpringBattleStartSetup(struct soap *soap, _Plasma__GetSpringBattleStartSetup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetSpringBattleStartSetup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetSpringBattleStartSetup(struct soap *soap, _Plasma__GetSpringBattleStartSetup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetSpringBattleStartSetup);
	if (soap_out_PointerTo_Plasma__GetSpringBattleStartSetup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetSpringBattleStartSetup(struct soap *soap, const char *tag, int id, _Plasma__GetSpringBattleStartSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetSpringBattleStartSetup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetup ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetSpringBattleStartSetup(struct soap *soap, _Plasma__GetSpringBattleStartSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetSpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetSpringBattleStartSetup ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetSpringBattleStartSetup(struct soap *soap, const char *tag, _Plasma__GetSpringBattleStartSetup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetSpringBattleStartSetup **)soap_malloc(soap, sizeof(_Plasma__GetSpringBattleStartSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetSpringBattleStartSetup *)soap_instantiate__Plasma__GetSpringBattleStartSetup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetSpringBattleStartSetup ** p = (_Plasma__GetSpringBattleStartSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetSpringBattleStartSetup, sizeof(_Plasma__GetSpringBattleStartSetup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetScriptMissionDataResponse(struct soap *soap, _Plasma__GetScriptMissionDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetScriptMissionDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetScriptMissionDataResponse(struct soap *soap, _Plasma__GetScriptMissionDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetScriptMissionDataResponse);
	if (soap_out_PointerTo_Plasma__GetScriptMissionDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetScriptMissionDataResponse(struct soap *soap, const char *tag, int id, _Plasma__GetScriptMissionDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetScriptMissionDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionDataResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetScriptMissionDataResponse(struct soap *soap, _Plasma__GetScriptMissionDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetScriptMissionDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetScriptMissionDataResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetScriptMissionDataResponse(struct soap *soap, const char *tag, _Plasma__GetScriptMissionDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetScriptMissionDataResponse **)soap_malloc(soap, sizeof(_Plasma__GetScriptMissionDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetScriptMissionDataResponse *)soap_instantiate__Plasma__GetScriptMissionDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetScriptMissionDataResponse ** p = (_Plasma__GetScriptMissionDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetScriptMissionDataResponse, sizeof(_Plasma__GetScriptMissionDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetScriptMissionData(struct soap *soap, _Plasma__GetScriptMissionData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetScriptMissionData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetScriptMissionData(struct soap *soap, _Plasma__GetScriptMissionData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetScriptMissionData);
	if (soap_out_PointerTo_Plasma__GetScriptMissionData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetScriptMissionData(struct soap *soap, const char *tag, int id, _Plasma__GetScriptMissionData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetScriptMissionData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetScriptMissionData ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetScriptMissionData(struct soap *soap, _Plasma__GetScriptMissionData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetScriptMissionData ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetScriptMissionData(struct soap *soap, const char *tag, _Plasma__GetScriptMissionData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetScriptMissionData **)soap_malloc(soap, sizeof(_Plasma__GetScriptMissionData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetScriptMissionData *)soap_instantiate__Plasma__GetScriptMissionData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetScriptMissionData ** p = (_Plasma__GetScriptMissionData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetScriptMissionData, sizeof(_Plasma__GetScriptMissionData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetResourceListResponse(struct soap *soap, _Plasma__GetResourceListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetResourceListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetResourceListResponse(struct soap *soap, _Plasma__GetResourceListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetResourceListResponse);
	if (soap_out_PointerTo_Plasma__GetResourceListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetResourceListResponse(struct soap *soap, const char *tag, int id, _Plasma__GetResourceListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetResourceListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetResourceListResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetResourceListResponse(struct soap *soap, _Plasma__GetResourceListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetResourceListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetResourceListResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetResourceListResponse(struct soap *soap, const char *tag, _Plasma__GetResourceListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetResourceListResponse **)soap_malloc(soap, sizeof(_Plasma__GetResourceListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetResourceListResponse *)soap_instantiate__Plasma__GetResourceListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetResourceListResponse ** p = (_Plasma__GetResourceListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetResourceListResponse, sizeof(_Plasma__GetResourceListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetResourceList(struct soap *soap, _Plasma__GetResourceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetResourceList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetResourceList(struct soap *soap, _Plasma__GetResourceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetResourceList);
	if (soap_out_PointerTo_Plasma__GetResourceList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetResourceList(struct soap *soap, const char *tag, int id, _Plasma__GetResourceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetResourceList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetResourceList ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetResourceList(struct soap *soap, _Plasma__GetResourceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetResourceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetResourceList ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetResourceList(struct soap *soap, const char *tag, _Plasma__GetResourceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetResourceList **)soap_malloc(soap, sizeof(_Plasma__GetResourceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetResourceList *)soap_instantiate__Plasma__GetResourceList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetResourceList ** p = (_Plasma__GetResourceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetResourceList, sizeof(_Plasma__GetResourceList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetResourceDataResponse(struct soap *soap, _Plasma__GetResourceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetResourceDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetResourceDataResponse(struct soap *soap, _Plasma__GetResourceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetResourceDataResponse);
	if (soap_out_PointerTo_Plasma__GetResourceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetResourceDataResponse(struct soap *soap, const char *tag, int id, _Plasma__GetResourceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetResourceDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetResourceDataResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetResourceDataResponse(struct soap *soap, _Plasma__GetResourceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetResourceDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetResourceDataResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetResourceDataResponse(struct soap *soap, const char *tag, _Plasma__GetResourceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetResourceDataResponse **)soap_malloc(soap, sizeof(_Plasma__GetResourceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetResourceDataResponse *)soap_instantiate__Plasma__GetResourceDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetResourceDataResponse ** p = (_Plasma__GetResourceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetResourceDataResponse, sizeof(_Plasma__GetResourceDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetResourceData(struct soap *soap, _Plasma__GetResourceData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetResourceData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetResourceData(struct soap *soap, _Plasma__GetResourceData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetResourceData);
	if (soap_out_PointerTo_Plasma__GetResourceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetResourceData(struct soap *soap, const char *tag, int id, _Plasma__GetResourceData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetResourceData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetResourceData ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetResourceData(struct soap *soap, _Plasma__GetResourceData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetResourceData ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetResourceData(struct soap *soap, const char *tag, _Plasma__GetResourceData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetResourceData **)soap_malloc(soap, sizeof(_Plasma__GetResourceData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetResourceData *)soap_instantiate__Plasma__GetResourceData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetResourceData ** p = (_Plasma__GetResourceData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetResourceData, sizeof(_Plasma__GetResourceData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetRecommendedMapResponse(struct soap *soap, _Plasma__GetRecommendedMapResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetRecommendedMapResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetRecommendedMapResponse(struct soap *soap, _Plasma__GetRecommendedMapResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetRecommendedMapResponse);
	if (soap_out_PointerTo_Plasma__GetRecommendedMapResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetRecommendedMapResponse(struct soap *soap, const char *tag, int id, _Plasma__GetRecommendedMapResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetRecommendedMapResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMapResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetRecommendedMapResponse(struct soap *soap, _Plasma__GetRecommendedMapResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetRecommendedMapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetRecommendedMapResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetRecommendedMapResponse(struct soap *soap, const char *tag, _Plasma__GetRecommendedMapResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetRecommendedMapResponse **)soap_malloc(soap, sizeof(_Plasma__GetRecommendedMapResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetRecommendedMapResponse *)soap_instantiate__Plasma__GetRecommendedMapResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetRecommendedMapResponse ** p = (_Plasma__GetRecommendedMapResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetRecommendedMapResponse, sizeof(_Plasma__GetRecommendedMapResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetRecommendedMap(struct soap *soap, _Plasma__GetRecommendedMap *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetRecommendedMap))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetRecommendedMap(struct soap *soap, _Plasma__GetRecommendedMap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetRecommendedMap);
	if (soap_out_PointerTo_Plasma__GetRecommendedMap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetRecommendedMap(struct soap *soap, const char *tag, int id, _Plasma__GetRecommendedMap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetRecommendedMap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetRecommendedMap ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetRecommendedMap(struct soap *soap, _Plasma__GetRecommendedMap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetRecommendedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetRecommendedMap ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetRecommendedMap(struct soap *soap, const char *tag, _Plasma__GetRecommendedMap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetRecommendedMap **)soap_malloc(soap, sizeof(_Plasma__GetRecommendedMap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetRecommendedMap *)soap_instantiate__Plasma__GetRecommendedMap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetRecommendedMap ** p = (_Plasma__GetRecommendedMap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetRecommendedMap, sizeof(_Plasma__GetRecommendedMap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloTop10Response(struct soap *soap, _Plasma__GetEloTop10Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloTop10Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloTop10Response(struct soap *soap, _Plasma__GetEloTop10Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloTop10Response);
	if (soap_out_PointerTo_Plasma__GetEloTop10Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloTop10Response(struct soap *soap, const char *tag, int id, _Plasma__GetEloTop10Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloTop10Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10Response ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloTop10Response(struct soap *soap, _Plasma__GetEloTop10Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloTop10Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloTop10Response ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloTop10Response(struct soap *soap, const char *tag, _Plasma__GetEloTop10Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloTop10Response **)soap_malloc(soap, sizeof(_Plasma__GetEloTop10Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloTop10Response *)soap_instantiate__Plasma__GetEloTop10Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloTop10Response ** p = (_Plasma__GetEloTop10Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloTop10Response, sizeof(_Plasma__GetEloTop10Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloTop10(struct soap *soap, _Plasma__GetEloTop10 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloTop10))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloTop10(struct soap *soap, _Plasma__GetEloTop10 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloTop10);
	if (soap_out_PointerTo_Plasma__GetEloTop10(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloTop10(struct soap *soap, const char *tag, int id, _Plasma__GetEloTop10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloTop10);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloTop10 ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloTop10(struct soap *soap, _Plasma__GetEloTop10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloTop10(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloTop10 ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloTop10(struct soap *soap, const char *tag, _Plasma__GetEloTop10 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloTop10 **)soap_malloc(soap, sizeof(_Plasma__GetEloTop10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloTop10 *)soap_instantiate__Plasma__GetEloTop10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloTop10 ** p = (_Plasma__GetEloTop10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloTop10, sizeof(_Plasma__GetEloTop10), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloByNameResponse(struct soap *soap, _Plasma__GetEloByNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloByNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloByNameResponse(struct soap *soap, _Plasma__GetEloByNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloByNameResponse);
	if (soap_out_PointerTo_Plasma__GetEloByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloByNameResponse(struct soap *soap, const char *tag, int id, _Plasma__GetEloByNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloByNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloByNameResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloByNameResponse(struct soap *soap, _Plasma__GetEloByNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloByNameResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloByNameResponse(struct soap *soap, const char *tag, _Plasma__GetEloByNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloByNameResponse **)soap_malloc(soap, sizeof(_Plasma__GetEloByNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloByNameResponse *)soap_instantiate__Plasma__GetEloByNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloByNameResponse ** p = (_Plasma__GetEloByNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloByNameResponse, sizeof(_Plasma__GetEloByNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloByName(struct soap *soap, _Plasma__GetEloByName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloByName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloByName(struct soap *soap, _Plasma__GetEloByName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloByName);
	if (soap_out_PointerTo_Plasma__GetEloByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloByName(struct soap *soap, const char *tag, int id, _Plasma__GetEloByName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloByName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloByName ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloByName(struct soap *soap, _Plasma__GetEloByName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloByName ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloByName(struct soap *soap, const char *tag, _Plasma__GetEloByName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloByName **)soap_malloc(soap, sizeof(_Plasma__GetEloByName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloByName *)soap_instantiate__Plasma__GetEloByName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloByName ** p = (_Plasma__GetEloByName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloByName, sizeof(_Plasma__GetEloByName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloByAccountIDResponse(struct soap *soap, _Plasma__GetEloByAccountIDResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloByAccountIDResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloByAccountIDResponse(struct soap *soap, _Plasma__GetEloByAccountIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloByAccountIDResponse);
	if (soap_out_PointerTo_Plasma__GetEloByAccountIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloByAccountIDResponse(struct soap *soap, const char *tag, int id, _Plasma__GetEloByAccountIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloByAccountIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountIDResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloByAccountIDResponse(struct soap *soap, _Plasma__GetEloByAccountIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloByAccountIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloByAccountIDResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloByAccountIDResponse(struct soap *soap, const char *tag, _Plasma__GetEloByAccountIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloByAccountIDResponse **)soap_malloc(soap, sizeof(_Plasma__GetEloByAccountIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloByAccountIDResponse *)soap_instantiate__Plasma__GetEloByAccountIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloByAccountIDResponse ** p = (_Plasma__GetEloByAccountIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloByAccountIDResponse, sizeof(_Plasma__GetEloByAccountIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__GetEloByAccountID(struct soap *soap, _Plasma__GetEloByAccountID *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__GetEloByAccountID))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__GetEloByAccountID(struct soap *soap, _Plasma__GetEloByAccountID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__GetEloByAccountID);
	if (soap_out_PointerTo_Plasma__GetEloByAccountID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__GetEloByAccountID(struct soap *soap, const char *tag, int id, _Plasma__GetEloByAccountID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__GetEloByAccountID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__GetEloByAccountID ** SOAP_FMAC4 soap_get_PointerTo_Plasma__GetEloByAccountID(struct soap *soap, _Plasma__GetEloByAccountID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__GetEloByAccountID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__GetEloByAccountID ** SOAP_FMAC4 soap_in_PointerTo_Plasma__GetEloByAccountID(struct soap *soap, const char *tag, _Plasma__GetEloByAccountID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__GetEloByAccountID **)soap_malloc(soap, sizeof(_Plasma__GetEloByAccountID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__GetEloByAccountID *)soap_instantiate__Plasma__GetEloByAccountID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__GetEloByAccountID ** p = (_Plasma__GetEloByAccountID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__GetEloByAccountID, sizeof(_Plasma__GetEloByAccountID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__DownloadFileResponse(struct soap *soap, _Plasma__DownloadFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__DownloadFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__DownloadFileResponse(struct soap *soap, _Plasma__DownloadFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__DownloadFileResponse);
	if (soap_out_PointerTo_Plasma__DownloadFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__DownloadFileResponse(struct soap *soap, const char *tag, int id, _Plasma__DownloadFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__DownloadFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__DownloadFileResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__DownloadFileResponse(struct soap *soap, _Plasma__DownloadFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__DownloadFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__DownloadFileResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__DownloadFileResponse(struct soap *soap, const char *tag, _Plasma__DownloadFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__DownloadFileResponse **)soap_malloc(soap, sizeof(_Plasma__DownloadFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__DownloadFileResponse *)soap_instantiate__Plasma__DownloadFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__DownloadFileResponse ** p = (_Plasma__DownloadFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__DownloadFileResponse, sizeof(_Plasma__DownloadFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__DownloadFile(struct soap *soap, _Plasma__DownloadFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__DownloadFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__DownloadFile(struct soap *soap, _Plasma__DownloadFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__DownloadFile);
	if (soap_out_PointerTo_Plasma__DownloadFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__DownloadFile(struct soap *soap, const char *tag, int id, _Plasma__DownloadFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__DownloadFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__DownloadFile ** SOAP_FMAC4 soap_get_PointerTo_Plasma__DownloadFile(struct soap *soap, _Plasma__DownloadFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__DownloadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__DownloadFile ** SOAP_FMAC4 soap_in_PointerTo_Plasma__DownloadFile(struct soap *soap, const char *tag, _Plasma__DownloadFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__DownloadFile **)soap_malloc(soap, sizeof(_Plasma__DownloadFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__DownloadFile *)soap_instantiate__Plasma__DownloadFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__DownloadFile ** p = (_Plasma__DownloadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__DownloadFile, sizeof(_Plasma__DownloadFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__BalanceTeamsResponse(struct soap *soap, _Plasma__BalanceTeamsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__BalanceTeamsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__BalanceTeamsResponse(struct soap *soap, _Plasma__BalanceTeamsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__BalanceTeamsResponse);
	if (soap_out_PointerTo_Plasma__BalanceTeamsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__BalanceTeamsResponse(struct soap *soap, const char *tag, int id, _Plasma__BalanceTeamsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__BalanceTeamsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__BalanceTeamsResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__BalanceTeamsResponse(struct soap *soap, _Plasma__BalanceTeamsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__BalanceTeamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__BalanceTeamsResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__BalanceTeamsResponse(struct soap *soap, const char *tag, _Plasma__BalanceTeamsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__BalanceTeamsResponse **)soap_malloc(soap, sizeof(_Plasma__BalanceTeamsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__BalanceTeamsResponse *)soap_instantiate__Plasma__BalanceTeamsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__BalanceTeamsResponse ** p = (_Plasma__BalanceTeamsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__BalanceTeamsResponse, sizeof(_Plasma__BalanceTeamsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__BalanceTeams(struct soap *soap, _Plasma__BalanceTeams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__BalanceTeams))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__BalanceTeams(struct soap *soap, _Plasma__BalanceTeams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__BalanceTeams);
	if (soap_out_PointerTo_Plasma__BalanceTeams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__BalanceTeams(struct soap *soap, const char *tag, int id, _Plasma__BalanceTeams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__BalanceTeams);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__BalanceTeams ** SOAP_FMAC4 soap_get_PointerTo_Plasma__BalanceTeams(struct soap *soap, _Plasma__BalanceTeams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__BalanceTeams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__BalanceTeams ** SOAP_FMAC4 soap_in_PointerTo_Plasma__BalanceTeams(struct soap *soap, const char *tag, _Plasma__BalanceTeams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__BalanceTeams **)soap_malloc(soap, sizeof(_Plasma__BalanceTeams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__BalanceTeams *)soap_instantiate__Plasma__BalanceTeams(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__BalanceTeams ** p = (_Plasma__BalanceTeams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__BalanceTeams, sizeof(_Plasma__BalanceTeams), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__AutohostPlayerJoinedResponse(struct soap *soap, _Plasma__AutohostPlayerJoinedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__AutohostPlayerJoinedResponse(struct soap *soap, _Plasma__AutohostPlayerJoinedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoinedResponse);
	if (soap_out_PointerTo_Plasma__AutohostPlayerJoinedResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__AutohostPlayerJoinedResponse(struct soap *soap, const char *tag, int id, _Plasma__AutohostPlayerJoinedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoinedResponse ** SOAP_FMAC4 soap_get_PointerTo_Plasma__AutohostPlayerJoinedResponse(struct soap *soap, _Plasma__AutohostPlayerJoinedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__AutohostPlayerJoinedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoinedResponse ** SOAP_FMAC4 soap_in_PointerTo_Plasma__AutohostPlayerJoinedResponse(struct soap *soap, const char *tag, _Plasma__AutohostPlayerJoinedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__AutohostPlayerJoinedResponse **)soap_malloc(soap, sizeof(_Plasma__AutohostPlayerJoinedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__AutohostPlayerJoinedResponse *)soap_instantiate__Plasma__AutohostPlayerJoinedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__AutohostPlayerJoinedResponse ** p = (_Plasma__AutohostPlayerJoinedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__AutohostPlayerJoinedResponse, sizeof(_Plasma__AutohostPlayerJoinedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Plasma__AutohostPlayerJoined(struct soap *soap, _Plasma__AutohostPlayerJoined *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__Plasma__AutohostPlayerJoined))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Plasma__AutohostPlayerJoined(struct soap *soap, _Plasma__AutohostPlayerJoined *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Plasma__AutohostPlayerJoined);
	if (soap_out_PointerTo_Plasma__AutohostPlayerJoined(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Plasma__AutohostPlayerJoined(struct soap *soap, const char *tag, int id, _Plasma__AutohostPlayerJoined *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__Plasma__AutohostPlayerJoined);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoined ** SOAP_FMAC4 soap_get_PointerTo_Plasma__AutohostPlayerJoined(struct soap *soap, _Plasma__AutohostPlayerJoined **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Plasma__AutohostPlayerJoined(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _Plasma__AutohostPlayerJoined ** SOAP_FMAC4 soap_in_PointerTo_Plasma__AutohostPlayerJoined(struct soap *soap, const char *tag, _Plasma__AutohostPlayerJoined **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Plasma__AutohostPlayerJoined **)soap_malloc(soap, sizeof(_Plasma__AutohostPlayerJoined *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Plasma__AutohostPlayerJoined *)soap_instantiate__Plasma__AutohostPlayerJoined(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Plasma__AutohostPlayerJoined ** p = (_Plasma__AutohostPlayerJoined **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Plasma__AutohostPlayerJoined, sizeof(_Plasma__AutohostPlayerJoined), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfBattlePlayerResult(struct soap *soap, Plasma__ArrayOfBattlePlayerResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfBattlePlayerResult(struct soap *soap, Plasma__ArrayOfBattlePlayerResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfBattlePlayerResult);
	if (soap_out_PointerToPlasma__ArrayOfBattlePlayerResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfBattlePlayerResult(struct soap *soap, const char *tag, int id, Plasma__ArrayOfBattlePlayerResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattlePlayerResult ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfBattlePlayerResult(struct soap *soap, Plasma__ArrayOfBattlePlayerResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfBattlePlayerResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfBattlePlayerResult ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfBattlePlayerResult(struct soap *soap, const char *tag, Plasma__ArrayOfBattlePlayerResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfBattlePlayerResult **)soap_malloc(soap, sizeof(Plasma__ArrayOfBattlePlayerResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfBattlePlayerResult *)soap_instantiate_Plasma__ArrayOfBattlePlayerResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfBattlePlayerResult ** p = (Plasma__ArrayOfBattlePlayerResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfBattlePlayerResult, sizeof(Plasma__ArrayOfBattlePlayerResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__BattleResult(struct soap *soap, Plasma__BattleResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__BattleResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__BattleResult(struct soap *soap, Plasma__BattleResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__BattleResult);
	if (soap_out_PointerToPlasma__BattleResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__BattleResult(struct soap *soap, const char *tag, int id, Plasma__BattleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__BattleResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__BattleResult ** SOAP_FMAC4 soap_get_PointerToPlasma__BattleResult(struct soap *soap, Plasma__BattleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__BattleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__BattleResult ** SOAP_FMAC4 soap_in_PointerToPlasma__BattleResult(struct soap *soap, const char *tag, Plasma__BattleResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__BattleResult **)soap_malloc(soap, sizeof(Plasma__BattleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__BattleResult *)soap_instantiate_Plasma__BattleResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__BattleResult ** p = (Plasma__BattleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__BattleResult, sizeof(Plasma__BattleResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__SpringBattleStartSetup(struct soap *soap, Plasma__SpringBattleStartSetup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__SpringBattleStartSetup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__SpringBattleStartSetup(struct soap *soap, Plasma__SpringBattleStartSetup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__SpringBattleStartSetup);
	if (soap_out_PointerToPlasma__SpringBattleStartSetup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__SpringBattleStartSetup(struct soap *soap, const char *tag, int id, Plasma__SpringBattleStartSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__SpringBattleStartSetup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__SpringBattleStartSetup ** SOAP_FMAC4 soap_get_PointerToPlasma__SpringBattleStartSetup(struct soap *soap, Plasma__SpringBattleStartSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__SpringBattleStartSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__SpringBattleStartSetup ** SOAP_FMAC4 soap_in_PointerToPlasma__SpringBattleStartSetup(struct soap *soap, const char *tag, Plasma__SpringBattleStartSetup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__SpringBattleStartSetup **)soap_malloc(soap, sizeof(Plasma__SpringBattleStartSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__SpringBattleStartSetup *)soap_instantiate_Plasma__SpringBattleStartSetup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__SpringBattleStartSetup ** p = (Plasma__SpringBattleStartSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__SpringBattleStartSetup, sizeof(Plasma__SpringBattleStartSetup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, Plasma__ArrayOfBattleStartSetupPlayer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, Plasma__ArrayOfBattleStartSetupPlayer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfBattleStartSetupPlayer);
	if (soap_out_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, const char *tag, int id, Plasma__ArrayOfBattleStartSetupPlayer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfBattleStartSetupPlayer ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, Plasma__ArrayOfBattleStartSetupPlayer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfBattleStartSetupPlayer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfBattleStartSetupPlayer ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfBattleStartSetupPlayer(struct soap *soap, const char *tag, Plasma__ArrayOfBattleStartSetupPlayer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfBattleStartSetupPlayer **)soap_malloc(soap, sizeof(Plasma__ArrayOfBattleStartSetupPlayer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfBattleStartSetupPlayer *)soap_instantiate_Plasma__ArrayOfBattleStartSetupPlayer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfBattleStartSetupPlayer ** p = (Plasma__ArrayOfBattleStartSetupPlayer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfBattleStartSetupPlayer, sizeof(Plasma__ArrayOfBattleStartSetupPlayer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ScriptMissionData(struct soap *soap, Plasma__ScriptMissionData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ScriptMissionData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ScriptMissionData(struct soap *soap, Plasma__ScriptMissionData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ScriptMissionData);
	if (soap_out_PointerToPlasma__ScriptMissionData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ScriptMissionData(struct soap *soap, const char *tag, int id, Plasma__ScriptMissionData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ScriptMissionData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ScriptMissionData ** SOAP_FMAC4 soap_get_PointerToPlasma__ScriptMissionData(struct soap *soap, Plasma__ScriptMissionData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ScriptMissionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ScriptMissionData ** SOAP_FMAC4 soap_in_PointerToPlasma__ScriptMissionData(struct soap *soap, const char *tag, Plasma__ScriptMissionData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ScriptMissionData **)soap_malloc(soap, sizeof(Plasma__ScriptMissionData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ScriptMissionData *)soap_instantiate_Plasma__ScriptMissionData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ScriptMissionData ** p = (Plasma__ScriptMissionData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ScriptMissionData, sizeof(Plasma__ScriptMissionData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfResourceData(struct soap *soap, Plasma__ArrayOfResourceData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfResourceData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfResourceData(struct soap *soap, Plasma__ArrayOfResourceData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfResourceData);
	if (soap_out_PointerToPlasma__ArrayOfResourceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfResourceData(struct soap *soap, const char *tag, int id, Plasma__ArrayOfResourceData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfResourceData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfResourceData ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfResourceData(struct soap *soap, Plasma__ArrayOfResourceData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfResourceData ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfResourceData(struct soap *soap, const char *tag, Plasma__ArrayOfResourceData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfResourceData **)soap_malloc(soap, sizeof(Plasma__ArrayOfResourceData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfResourceData *)soap_instantiate_Plasma__ArrayOfResourceData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfResourceData ** p = (Plasma__ArrayOfResourceData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfResourceData, sizeof(Plasma__ArrayOfResourceData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__RecommendedMapResult(struct soap *soap, Plasma__RecommendedMapResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__RecommendedMapResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__RecommendedMapResult(struct soap *soap, Plasma__RecommendedMapResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__RecommendedMapResult);
	if (soap_out_PointerToPlasma__RecommendedMapResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__RecommendedMapResult(struct soap *soap, const char *tag, int id, Plasma__RecommendedMapResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__RecommendedMapResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__RecommendedMapResult ** SOAP_FMAC4 soap_get_PointerToPlasma__RecommendedMapResult(struct soap *soap, Plasma__RecommendedMapResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__RecommendedMapResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__RecommendedMapResult ** SOAP_FMAC4 soap_in_PointerToPlasma__RecommendedMapResult(struct soap *soap, const char *tag, Plasma__RecommendedMapResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__RecommendedMapResult **)soap_malloc(soap, sizeof(Plasma__RecommendedMapResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__RecommendedMapResult *)soap_instantiate_Plasma__RecommendedMapResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__RecommendedMapResult ** p = (Plasma__RecommendedMapResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__RecommendedMapResult, sizeof(Plasma__RecommendedMapResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__EloInfo(struct soap *soap, Plasma__EloInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__EloInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__EloInfo(struct soap *soap, Plasma__EloInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__EloInfo);
	if (soap_out_PointerToPlasma__EloInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__EloInfo(struct soap *soap, const char *tag, int id, Plasma__EloInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__EloInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__EloInfo ** SOAP_FMAC4 soap_get_PointerToPlasma__EloInfo(struct soap *soap, Plasma__EloInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__EloInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__EloInfo ** SOAP_FMAC4 soap_in_PointerToPlasma__EloInfo(struct soap *soap, const char *tag, Plasma__EloInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__EloInfo **)soap_malloc(soap, sizeof(Plasma__EloInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__EloInfo *)soap_instantiate_Plasma__EloInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__EloInfo ** p = (Plasma__EloInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__EloInfo, sizeof(Plasma__EloInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__BalanceTeamsResult(struct soap *soap, Plasma__BalanceTeamsResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__BalanceTeamsResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__BalanceTeamsResult(struct soap *soap, Plasma__BalanceTeamsResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__BalanceTeamsResult);
	if (soap_out_PointerToPlasma__BalanceTeamsResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__BalanceTeamsResult(struct soap *soap, const char *tag, int id, Plasma__BalanceTeamsResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__BalanceTeamsResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__BalanceTeamsResult ** SOAP_FMAC4 soap_get_PointerToPlasma__BalanceTeamsResult(struct soap *soap, Plasma__BalanceTeamsResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__BalanceTeamsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__BalanceTeamsResult ** SOAP_FMAC4 soap_in_PointerToPlasma__BalanceTeamsResult(struct soap *soap, const char *tag, Plasma__BalanceTeamsResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__BalanceTeamsResult **)soap_malloc(soap, sizeof(Plasma__BalanceTeamsResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__BalanceTeamsResult *)soap_instantiate_Plasma__BalanceTeamsResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__BalanceTeamsResult ** p = (Plasma__BalanceTeamsResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__BalanceTeamsResult, sizeof(Plasma__BalanceTeamsResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__PlayerStats(struct soap *soap, Plasma__PlayerStats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__PlayerStats))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__PlayerStats(struct soap *soap, Plasma__PlayerStats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__PlayerStats);
	if (soap_out_PointerToPlasma__PlayerStats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__PlayerStats(struct soap *soap, const char *tag, int id, Plasma__PlayerStats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__PlayerStats);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__PlayerStats ** SOAP_FMAC4 soap_get_PointerToPlasma__PlayerStats(struct soap *soap, Plasma__PlayerStats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__PlayerStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__PlayerStats ** SOAP_FMAC4 soap_in_PointerToPlasma__PlayerStats(struct soap *soap, const char *tag, Plasma__PlayerStats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__PlayerStats **)soap_malloc(soap, sizeof(Plasma__PlayerStats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__PlayerStats *)soap_instantiate_Plasma__PlayerStats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__PlayerStats ** p = (Plasma__PlayerStats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__PlayerStats, sizeof(Plasma__PlayerStats), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__PlayerAward(struct soap *soap, Plasma__PlayerAward *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__PlayerAward))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__PlayerAward(struct soap *soap, Plasma__PlayerAward *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__PlayerAward);
	if (soap_out_PointerToPlasma__PlayerAward(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__PlayerAward(struct soap *soap, const char *tag, int id, Plasma__PlayerAward *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__PlayerAward);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__PlayerAward ** SOAP_FMAC4 soap_get_PointerToPlasma__PlayerAward(struct soap *soap, Plasma__PlayerAward **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__PlayerAward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__PlayerAward ** SOAP_FMAC4 soap_in_PointerToPlasma__PlayerAward(struct soap *soap, const char *tag, Plasma__PlayerAward **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__PlayerAward **)soap_malloc(soap, sizeof(Plasma__PlayerAward *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__PlayerAward *)soap_instantiate_Plasma__PlayerAward(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__PlayerAward ** p = (Plasma__PlayerAward **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__PlayerAward, sizeof(Plasma__PlayerAward), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfPlayerStats(struct soap *soap, Plasma__ArrayOfPlayerStats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfPlayerStats))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfPlayerStats(struct soap *soap, Plasma__ArrayOfPlayerStats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfPlayerStats);
	if (soap_out_PointerToPlasma__ArrayOfPlayerStats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfPlayerStats(struct soap *soap, const char *tag, int id, Plasma__ArrayOfPlayerStats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfPlayerStats);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerStats ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfPlayerStats(struct soap *soap, Plasma__ArrayOfPlayerStats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfPlayerStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfPlayerStats ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfPlayerStats(struct soap *soap, const char *tag, Plasma__ArrayOfPlayerStats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfPlayerStats **)soap_malloc(soap, sizeof(Plasma__ArrayOfPlayerStats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfPlayerStats *)soap_instantiate_Plasma__ArrayOfPlayerStats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfPlayerStats ** p = (Plasma__ArrayOfPlayerStats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfPlayerStats, sizeof(Plasma__ArrayOfPlayerStats), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfPlayerAward(struct soap *soap, Plasma__ArrayOfPlayerAward *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfPlayerAward))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfPlayerAward(struct soap *soap, Plasma__ArrayOfPlayerAward *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfPlayerAward);
	if (soap_out_PointerToPlasma__ArrayOfPlayerAward(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfPlayerAward(struct soap *soap, const char *tag, int id, Plasma__ArrayOfPlayerAward *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfPlayerAward);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfPlayerAward ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfPlayerAward(struct soap *soap, Plasma__ArrayOfPlayerAward **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfPlayerAward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfPlayerAward ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfPlayerAward(struct soap *soap, const char *tag, Plasma__ArrayOfPlayerAward **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfPlayerAward **)soap_malloc(soap, sizeof(Plasma__ArrayOfPlayerAward *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfPlayerAward *)soap_instantiate_Plasma__ArrayOfPlayerAward(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfPlayerAward ** p = (Plasma__ArrayOfPlayerAward **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfPlayerAward, sizeof(Plasma__ArrayOfPlayerAward), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__BattlePlayerResult(struct soap *soap, Plasma__BattlePlayerResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__BattlePlayerResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__BattlePlayerResult(struct soap *soap, Plasma__BattlePlayerResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__BattlePlayerResult);
	if (soap_out_PointerToPlasma__BattlePlayerResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__BattlePlayerResult(struct soap *soap, const char *tag, int id, Plasma__BattlePlayerResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__BattlePlayerResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__BattlePlayerResult ** SOAP_FMAC4 soap_get_PointerToPlasma__BattlePlayerResult(struct soap *soap, Plasma__BattlePlayerResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__BattlePlayerResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__BattlePlayerResult ** SOAP_FMAC4 soap_in_PointerToPlasma__BattlePlayerResult(struct soap *soap, const char *tag, Plasma__BattlePlayerResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__BattlePlayerResult **)soap_malloc(soap, sizeof(Plasma__BattlePlayerResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__BattlePlayerResult *)soap_instantiate_Plasma__BattlePlayerResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__BattlePlayerResult ** p = (Plasma__BattlePlayerResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__BattlePlayerResult, sizeof(Plasma__BattlePlayerResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__UserCustomParameters(struct soap *soap, Plasma__UserCustomParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__UserCustomParameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__UserCustomParameters(struct soap *soap, Plasma__UserCustomParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__UserCustomParameters);
	if (soap_out_PointerToPlasma__UserCustomParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__UserCustomParameters(struct soap *soap, const char *tag, int id, Plasma__UserCustomParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__UserCustomParameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__UserCustomParameters ** SOAP_FMAC4 soap_get_PointerToPlasma__UserCustomParameters(struct soap *soap, Plasma__UserCustomParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__UserCustomParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__UserCustomParameters ** SOAP_FMAC4 soap_in_PointerToPlasma__UserCustomParameters(struct soap *soap, const char *tag, Plasma__UserCustomParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__UserCustomParameters **)soap_malloc(soap, sizeof(Plasma__UserCustomParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__UserCustomParameters *)soap_instantiate_Plasma__UserCustomParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__UserCustomParameters ** p = (Plasma__UserCustomParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__UserCustomParameters, sizeof(Plasma__UserCustomParameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ScriptKeyValuePair(struct soap *soap, Plasma__ScriptKeyValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ScriptKeyValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ScriptKeyValuePair(struct soap *soap, Plasma__ScriptKeyValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ScriptKeyValuePair);
	if (soap_out_PointerToPlasma__ScriptKeyValuePair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ScriptKeyValuePair(struct soap *soap, const char *tag, int id, Plasma__ScriptKeyValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ScriptKeyValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ScriptKeyValuePair ** SOAP_FMAC4 soap_get_PointerToPlasma__ScriptKeyValuePair(struct soap *soap, Plasma__ScriptKeyValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ScriptKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ScriptKeyValuePair ** SOAP_FMAC4 soap_in_PointerToPlasma__ScriptKeyValuePair(struct soap *soap, const char *tag, Plasma__ScriptKeyValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ScriptKeyValuePair **)soap_malloc(soap, sizeof(Plasma__ScriptKeyValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ScriptKeyValuePair *)soap_instantiate_Plasma__ScriptKeyValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ScriptKeyValuePair ** p = (Plasma__ScriptKeyValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ScriptKeyValuePair, sizeof(Plasma__ScriptKeyValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfUserCustomParameters(struct soap *soap, Plasma__ArrayOfUserCustomParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfUserCustomParameters(struct soap *soap, Plasma__ArrayOfUserCustomParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfUserCustomParameters);
	if (soap_out_PointerToPlasma__ArrayOfUserCustomParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfUserCustomParameters(struct soap *soap, const char *tag, int id, Plasma__ArrayOfUserCustomParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfUserCustomParameters ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfUserCustomParameters(struct soap *soap, Plasma__ArrayOfUserCustomParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfUserCustomParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfUserCustomParameters ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfUserCustomParameters(struct soap *soap, const char *tag, Plasma__ArrayOfUserCustomParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfUserCustomParameters **)soap_malloc(soap, sizeof(Plasma__ArrayOfUserCustomParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfUserCustomParameters *)soap_instantiate_Plasma__ArrayOfUserCustomParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfUserCustomParameters ** p = (Plasma__ArrayOfUserCustomParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfUserCustomParameters, sizeof(Plasma__ArrayOfUserCustomParameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfScriptKeyValuePair(struct soap *soap, Plasma__ArrayOfScriptKeyValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfScriptKeyValuePair(struct soap *soap, Plasma__ArrayOfScriptKeyValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfScriptKeyValuePair);
	if (soap_out_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfScriptKeyValuePair(struct soap *soap, const char *tag, int id, Plasma__ArrayOfScriptKeyValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfScriptKeyValuePair ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfScriptKeyValuePair(struct soap *soap, Plasma__ArrayOfScriptKeyValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfScriptKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfScriptKeyValuePair ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfScriptKeyValuePair(struct soap *soap, const char *tag, Plasma__ArrayOfScriptKeyValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfScriptKeyValuePair **)soap_malloc(soap, sizeof(Plasma__ArrayOfScriptKeyValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfScriptKeyValuePair *)soap_instantiate_Plasma__ArrayOfScriptKeyValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfScriptKeyValuePair ** p = (Plasma__ArrayOfScriptKeyValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfScriptKeyValuePair, sizeof(Plasma__ArrayOfScriptKeyValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__BattleStartSetupPlayer(struct soap *soap, Plasma__BattleStartSetupPlayer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__BattleStartSetupPlayer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__BattleStartSetupPlayer(struct soap *soap, Plasma__BattleStartSetupPlayer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__BattleStartSetupPlayer);
	if (soap_out_PointerToPlasma__BattleStartSetupPlayer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, int id, Plasma__BattleStartSetupPlayer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__BattleStartSetupPlayer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__BattleStartSetupPlayer ** SOAP_FMAC4 soap_get_PointerToPlasma__BattleStartSetupPlayer(struct soap *soap, Plasma__BattleStartSetupPlayer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__BattleStartSetupPlayer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__BattleStartSetupPlayer ** SOAP_FMAC4 soap_in_PointerToPlasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, Plasma__BattleStartSetupPlayer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__BattleStartSetupPlayer **)soap_malloc(soap, sizeof(Plasma__BattleStartSetupPlayer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__BattleStartSetupPlayer *)soap_instantiate_Plasma__BattleStartSetupPlayer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__BattleStartSetupPlayer ** p = (Plasma__BattleStartSetupPlayer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__BattleStartSetupPlayer, sizeof(Plasma__BattleStartSetupPlayer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ResourceData(struct soap *soap, Plasma__ResourceData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ResourceData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ResourceData(struct soap *soap, Plasma__ResourceData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ResourceData);
	if (soap_out_PointerToPlasma__ResourceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ResourceData(struct soap *soap, const char *tag, int id, Plasma__ResourceData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ResourceData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ResourceData ** SOAP_FMAC4 soap_get_PointerToPlasma__ResourceData(struct soap *soap, Plasma__ResourceData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ResourceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ResourceData ** SOAP_FMAC4 soap_in_PointerToPlasma__ResourceData(struct soap *soap, const char *tag, Plasma__ResourceData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ResourceData **)soap_malloc(soap, sizeof(Plasma__ResourceData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ResourceData *)soap_instantiate_Plasma__ResourceData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ResourceData ** p = (Plasma__ResourceData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ResourceData, sizeof(Plasma__ResourceData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__SpringHashEntry(struct soap *soap, Plasma__SpringHashEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__SpringHashEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__SpringHashEntry(struct soap *soap, Plasma__SpringHashEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__SpringHashEntry);
	if (soap_out_PointerToPlasma__SpringHashEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__SpringHashEntry(struct soap *soap, const char *tag, int id, Plasma__SpringHashEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__SpringHashEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__SpringHashEntry ** SOAP_FMAC4 soap_get_PointerToPlasma__SpringHashEntry(struct soap *soap, Plasma__SpringHashEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__SpringHashEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__SpringHashEntry ** SOAP_FMAC4 soap_in_PointerToPlasma__SpringHashEntry(struct soap *soap, const char *tag, Plasma__SpringHashEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__SpringHashEntry **)soap_malloc(soap, sizeof(Plasma__SpringHashEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__SpringHashEntry *)soap_instantiate_Plasma__SpringHashEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__SpringHashEntry ** p = (Plasma__SpringHashEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__SpringHashEntry, sizeof(Plasma__SpringHashEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfSpringHashEntry(struct soap *soap, Plasma__ArrayOfSpringHashEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfSpringHashEntry(struct soap *soap, Plasma__ArrayOfSpringHashEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfSpringHashEntry);
	if (soap_out_PointerToPlasma__ArrayOfSpringHashEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfSpringHashEntry(struct soap *soap, const char *tag, int id, Plasma__ArrayOfSpringHashEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfSpringHashEntry ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfSpringHashEntry(struct soap *soap, Plasma__ArrayOfSpringHashEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfSpringHashEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfSpringHashEntry ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfSpringHashEntry(struct soap *soap, const char *tag, Plasma__ArrayOfSpringHashEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfSpringHashEntry **)soap_malloc(soap, sizeof(Plasma__ArrayOfSpringHashEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfSpringHashEntry *)soap_instantiate_Plasma__ArrayOfSpringHashEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfSpringHashEntry ** p = (Plasma__ArrayOfSpringHashEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfSpringHashEntry, sizeof(Plasma__ArrayOfSpringHashEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfString(struct soap *soap, Plasma__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfString(struct soap *soap, Plasma__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfString);
	if (soap_out_PointerToPlasma__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfString(struct soap *soap, const char *tag, int id, Plasma__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfString ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfString(struct soap *soap, Plasma__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfString ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfString(struct soap *soap, const char *tag, Plasma__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfString **)soap_malloc(soap, sizeof(Plasma__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfString *)soap_instantiate_Plasma__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfString ** p = (Plasma__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfString, sizeof(Plasma__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__BotTeam(struct soap *soap, Plasma__BotTeam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__BotTeam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__BotTeam(struct soap *soap, Plasma__BotTeam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__BotTeam);
	if (soap_out_PointerToPlasma__BotTeam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__BotTeam(struct soap *soap, const char *tag, int id, Plasma__BotTeam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__BotTeam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__BotTeam ** SOAP_FMAC4 soap_get_PointerToPlasma__BotTeam(struct soap *soap, Plasma__BotTeam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__BotTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__BotTeam ** SOAP_FMAC4 soap_in_PointerToPlasma__BotTeam(struct soap *soap, const char *tag, Plasma__BotTeam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__BotTeam **)soap_malloc(soap, sizeof(Plasma__BotTeam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__BotTeam *)soap_instantiate_Plasma__BotTeam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__BotTeam ** p = (Plasma__BotTeam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__BotTeam, sizeof(Plasma__BotTeam), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfBotTeam(struct soap *soap, Plasma__ArrayOfBotTeam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfBotTeam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfBotTeam(struct soap *soap, Plasma__ArrayOfBotTeam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfBotTeam);
	if (soap_out_PointerToPlasma__ArrayOfBotTeam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfBotTeam(struct soap *soap, const char *tag, int id, Plasma__ArrayOfBotTeam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfBotTeam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfBotTeam ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfBotTeam(struct soap *soap, Plasma__ArrayOfBotTeam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfBotTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfBotTeam ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfBotTeam(struct soap *soap, const char *tag, Plasma__ArrayOfBotTeam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfBotTeam **)soap_malloc(soap, sizeof(Plasma__ArrayOfBotTeam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfBotTeam *)soap_instantiate_Plasma__ArrayOfBotTeam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfBotTeam ** p = (Plasma__ArrayOfBotTeam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfBotTeam, sizeof(Plasma__ArrayOfBotTeam), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__ArrayOfAccountTeam(struct soap *soap, Plasma__ArrayOfAccountTeam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__ArrayOfAccountTeam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__ArrayOfAccountTeam(struct soap *soap, Plasma__ArrayOfAccountTeam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__ArrayOfAccountTeam);
	if (soap_out_PointerToPlasma__ArrayOfAccountTeam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__ArrayOfAccountTeam(struct soap *soap, const char *tag, int id, Plasma__ArrayOfAccountTeam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__ArrayOfAccountTeam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__ArrayOfAccountTeam ** SOAP_FMAC4 soap_get_PointerToPlasma__ArrayOfAccountTeam(struct soap *soap, Plasma__ArrayOfAccountTeam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__ArrayOfAccountTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__ArrayOfAccountTeam ** SOAP_FMAC4 soap_in_PointerToPlasma__ArrayOfAccountTeam(struct soap *soap, const char *tag, Plasma__ArrayOfAccountTeam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__ArrayOfAccountTeam **)soap_malloc(soap, sizeof(Plasma__ArrayOfAccountTeam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__ArrayOfAccountTeam *)soap_instantiate_Plasma__ArrayOfAccountTeam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__ArrayOfAccountTeam ** p = (Plasma__ArrayOfAccountTeam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__ArrayOfAccountTeam, sizeof(Plasma__ArrayOfAccountTeam), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlasma__AccountTeam(struct soap *soap, Plasma__AccountTeam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Plasma__AccountTeam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlasma__AccountTeam(struct soap *soap, Plasma__AccountTeam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlasma__AccountTeam);
	if (soap_out_PointerToPlasma__AccountTeam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlasma__AccountTeam(struct soap *soap, const char *tag, int id, Plasma__AccountTeam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Plasma__AccountTeam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Plasma__AccountTeam ** SOAP_FMAC4 soap_get_PointerToPlasma__AccountTeam(struct soap *soap, Plasma__AccountTeam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlasma__AccountTeam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 Plasma__AccountTeam ** SOAP_FMAC4 soap_in_PointerToPlasma__AccountTeam(struct soap *soap, const char *tag, Plasma__AccountTeam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Plasma__AccountTeam **)soap_malloc(soap, sizeof(Plasma__AccountTeam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Plasma__AccountTeam *)soap_instantiate_Plasma__AccountTeam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Plasma__AccountTeam ** p = (Plasma__AccountTeam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Plasma__AccountTeam, sizeof(Plasma__AccountTeam), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, std::vector<Plasma__PlayerStats * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, const std::vector<Plasma__PlayerStats * >*a)
{
	for (std::vector<Plasma__PlayerStats * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__PlayerStats(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, const char *tag, int id, const std::vector<Plasma__PlayerStats * >*a, const char *type)
{
	for (std::vector<Plasma__PlayerStats * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__PlayerStats(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__PlayerStats * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, const char *tag, std::vector<Plasma__PlayerStats * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, -1)))
		return NULL;
	Plasma__PlayerStats *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__PlayerStats, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerStats, sizeof(Plasma__PlayerStats), 1))
				break;
			if (!soap_in_PointerToPlasma__PlayerStats(soap, tag, NULL, "Plasma:PlayerStats"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__PlayerStats(soap, tag, &n, "Plasma:PlayerStats"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__PlayerStats * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerStats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, std::vector<Plasma__PlayerStats * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__PlayerStats * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__PlayerStats * >;
		if (size)
			*size = sizeof(std::vector<Plasma__PlayerStats * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__PlayerStats * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__PlayerStats * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__PlayerStats * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__PlayerStats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__PlayerStats * > %p -> %p\n", q, p));
	*(std::vector<Plasma__PlayerStats * >*)p = *(std::vector<Plasma__PlayerStats * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, std::vector<Plasma__PlayerAward * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, const std::vector<Plasma__PlayerAward * >*a)
{
	for (std::vector<Plasma__PlayerAward * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__PlayerAward(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, const char *tag, int id, const std::vector<Plasma__PlayerAward * >*a, const char *type)
{
	for (std::vector<Plasma__PlayerAward * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__PlayerAward(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__PlayerAward * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, const char *tag, std::vector<Plasma__PlayerAward * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, -1)))
		return NULL;
	Plasma__PlayerAward *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__PlayerAward, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerAward, sizeof(Plasma__PlayerAward), 1))
				break;
			if (!soap_in_PointerToPlasma__PlayerAward(soap, tag, NULL, "Plasma:PlayerAward"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__PlayerAward(soap, tag, &n, "Plasma:PlayerAward"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__PlayerAward * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerAward(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, std::vector<Plasma__PlayerAward * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__PlayerAward * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__PlayerAward(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__PlayerAward, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__PlayerAward * >;
		if (size)
			*size = sizeof(std::vector<Plasma__PlayerAward * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__PlayerAward * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__PlayerAward * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__PlayerAward * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__PlayerAward(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__PlayerAward * > %p -> %p\n", q, p));
	*(std::vector<Plasma__PlayerAward * >*)p = *(std::vector<Plasma__PlayerAward * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, std::vector<Plasma__BattlePlayerResult * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, const std::vector<Plasma__BattlePlayerResult * >*a)
{
	for (std::vector<Plasma__BattlePlayerResult * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__BattlePlayerResult(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, const char *tag, int id, const std::vector<Plasma__BattlePlayerResult * >*a, const char *type)
{
	for (std::vector<Plasma__BattlePlayerResult * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__BattlePlayerResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__BattlePlayerResult * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, const char *tag, std::vector<Plasma__BattlePlayerResult * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, -1)))
		return NULL;
	Plasma__BattlePlayerResult *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__BattlePlayerResult, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult, sizeof(Plasma__BattlePlayerResult), 1))
				break;
			if (!soap_in_PointerToPlasma__BattlePlayerResult(soap, tag, NULL, "Plasma:BattlePlayerResult"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__BattlePlayerResult(soap, tag, &n, "Plasma:BattlePlayerResult"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__BattlePlayerResult * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, std::vector<Plasma__BattlePlayerResult * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__BattlePlayerResult * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__BattlePlayerResult * >;
		if (size)
			*size = sizeof(std::vector<Plasma__BattlePlayerResult * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__BattlePlayerResult * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__BattlePlayerResult * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__BattlePlayerResult * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__BattlePlayerResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__BattlePlayerResult * > %p -> %p\n", q, p));
	*(std::vector<Plasma__BattlePlayerResult * >*)p = *(std::vector<Plasma__BattlePlayerResult * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, std::vector<Plasma__UserCustomParameters * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, const std::vector<Plasma__UserCustomParameters * >*a)
{
	for (std::vector<Plasma__UserCustomParameters * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__UserCustomParameters(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, const char *tag, int id, const std::vector<Plasma__UserCustomParameters * >*a, const char *type)
{
	for (std::vector<Plasma__UserCustomParameters * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__UserCustomParameters(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__UserCustomParameters * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, const char *tag, std::vector<Plasma__UserCustomParameters * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, -1)))
		return NULL;
	Plasma__UserCustomParameters *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__UserCustomParameters, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__UserCustomParameters, sizeof(Plasma__UserCustomParameters), 1))
				break;
			if (!soap_in_PointerToPlasma__UserCustomParameters(soap, tag, NULL, "Plasma:UserCustomParameters"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__UserCustomParameters(soap, tag, &n, "Plasma:UserCustomParameters"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__UserCustomParameters * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, std::vector<Plasma__UserCustomParameters * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__UserCustomParameters * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__UserCustomParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__UserCustomParameters * >;
		if (size)
			*size = sizeof(std::vector<Plasma__UserCustomParameters * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__UserCustomParameters * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__UserCustomParameters * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__UserCustomParameters * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__UserCustomParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__UserCustomParameters * > %p -> %p\n", q, p));
	*(std::vector<Plasma__UserCustomParameters * >*)p = *(std::vector<Plasma__UserCustomParameters * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, std::vector<Plasma__ScriptKeyValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, const std::vector<Plasma__ScriptKeyValuePair * >*a)
{
	for (std::vector<Plasma__ScriptKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__ScriptKeyValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, const char *tag, int id, const std::vector<Plasma__ScriptKeyValuePair * >*a, const char *type)
{
	for (std::vector<Plasma__ScriptKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__ScriptKeyValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__ScriptKeyValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, const char *tag, std::vector<Plasma__ScriptKeyValuePair * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, -1)))
		return NULL;
	Plasma__ScriptKeyValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__ScriptKeyValuePair, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair, sizeof(Plasma__ScriptKeyValuePair), 1))
				break;
			if (!soap_in_PointerToPlasma__ScriptKeyValuePair(soap, tag, NULL, "Plasma:ScriptKeyValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__ScriptKeyValuePair(soap, tag, &n, "Plasma:ScriptKeyValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__ScriptKeyValuePair * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, std::vector<Plasma__ScriptKeyValuePair * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__ScriptKeyValuePair * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__ScriptKeyValuePair * >;
		if (size)
			*size = sizeof(std::vector<Plasma__ScriptKeyValuePair * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__ScriptKeyValuePair * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__ScriptKeyValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__ScriptKeyValuePair * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__ScriptKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__ScriptKeyValuePair * > %p -> %p\n", q, p));
	*(std::vector<Plasma__ScriptKeyValuePair * >*)p = *(std::vector<Plasma__ScriptKeyValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, std::vector<Plasma__BattleStartSetupPlayer * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, const std::vector<Plasma__BattleStartSetupPlayer * >*a)
{
	for (std::vector<Plasma__BattleStartSetupPlayer * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__BattleStartSetupPlayer(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, int id, const std::vector<Plasma__BattleStartSetupPlayer * >*a, const char *type)
{
	for (std::vector<Plasma__BattleStartSetupPlayer * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__BattleStartSetupPlayer(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__BattleStartSetupPlayer * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, const char *tag, std::vector<Plasma__BattleStartSetupPlayer * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, -1)))
		return NULL;
	Plasma__BattleStartSetupPlayer *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__BattleStartSetupPlayer, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer, sizeof(Plasma__BattleStartSetupPlayer), 1))
				break;
			if (!soap_in_PointerToPlasma__BattleStartSetupPlayer(soap, tag, NULL, "Plasma:BattleStartSetupPlayer"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__BattleStartSetupPlayer(soap, tag, &n, "Plasma:BattleStartSetupPlayer"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__BattleStartSetupPlayer * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, std::vector<Plasma__BattleStartSetupPlayer * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__BattleStartSetupPlayer * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__BattleStartSetupPlayer * >;
		if (size)
			*size = sizeof(std::vector<Plasma__BattleStartSetupPlayer * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__BattleStartSetupPlayer * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__BattleStartSetupPlayer * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__BattleStartSetupPlayer * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__BattleStartSetupPlayer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__BattleStartSetupPlayer * > %p -> %p\n", q, p));
	*(std::vector<Plasma__BattleStartSetupPlayer * >*)p = *(std::vector<Plasma__BattleStartSetupPlayer * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, std::vector<Plasma__ResourceData * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, const std::vector<Plasma__ResourceData * >*a)
{
	for (std::vector<Plasma__ResourceData * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__ResourceData(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, const char *tag, int id, const std::vector<Plasma__ResourceData * >*a, const char *type)
{
	for (std::vector<Plasma__ResourceData * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__ResourceData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__ResourceData * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, const char *tag, std::vector<Plasma__ResourceData * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, -1)))
		return NULL;
	Plasma__ResourceData *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__ResourceData, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ResourceData, sizeof(Plasma__ResourceData), 1))
				break;
			if (!soap_in_PointerToPlasma__ResourceData(soap, tag, NULL, "Plasma:ResourceData"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__ResourceData(soap, tag, &n, "Plasma:ResourceData"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__ResourceData * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__ResourceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, std::vector<Plasma__ResourceData * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__ResourceData * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__ResourceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__ResourceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__ResourceData * >;
		if (size)
			*size = sizeof(std::vector<Plasma__ResourceData * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__ResourceData * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__ResourceData * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__ResourceData * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__ResourceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__ResourceData * > %p -> %p\n", q, p));
	*(std::vector<Plasma__ResourceData * >*)p = *(std::vector<Plasma__ResourceData * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, std::vector<Plasma__SpringHashEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, const std::vector<Plasma__SpringHashEntry * >*a)
{
	for (std::vector<Plasma__SpringHashEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__SpringHashEntry(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, const char *tag, int id, const std::vector<Plasma__SpringHashEntry * >*a, const char *type)
{
	for (std::vector<Plasma__SpringHashEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__SpringHashEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__SpringHashEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, const char *tag, std::vector<Plasma__SpringHashEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, -1)))
		return NULL;
	Plasma__SpringHashEntry *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__SpringHashEntry, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__SpringHashEntry, sizeof(Plasma__SpringHashEntry), 1))
				break;
			if (!soap_in_PointerToPlasma__SpringHashEntry(soap, tag, NULL, "Plasma:SpringHashEntry"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__SpringHashEntry(soap, tag, &n, "Plasma:SpringHashEntry"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__SpringHashEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, std::vector<Plasma__SpringHashEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__SpringHashEntry * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__SpringHashEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__SpringHashEntry * >;
		if (size)
			*size = sizeof(std::vector<Plasma__SpringHashEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__SpringHashEntry * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__SpringHashEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__SpringHashEntry * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__SpringHashEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__SpringHashEntry * > %p -> %p\n", q, p));
	*(std::vector<Plasma__SpringHashEntry * >*)p = *(std::vector<Plasma__SpringHashEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, std::vector<Plasma__BotTeam * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, const std::vector<Plasma__BotTeam * >*a)
{
	for (std::vector<Plasma__BotTeam * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__BotTeam(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, const char *tag, int id, const std::vector<Plasma__BotTeam * >*a, const char *type)
{
	for (std::vector<Plasma__BotTeam * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__BotTeam(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__BotTeam * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, const char *tag, std::vector<Plasma__BotTeam * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, -1)))
		return NULL;
	Plasma__BotTeam *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__BotTeam, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BotTeam, sizeof(Plasma__BotTeam), 1))
				break;
			if (!soap_in_PointerToPlasma__BotTeam(soap, tag, NULL, "Plasma:BotTeam"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__BotTeam(soap, tag, &n, "Plasma:BotTeam"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__BotTeam * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__BotTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, std::vector<Plasma__BotTeam * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__BotTeam * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__BotTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__BotTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__BotTeam * >;
		if (size)
			*size = sizeof(std::vector<Plasma__BotTeam * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__BotTeam * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__BotTeam * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__BotTeam * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__BotTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__BotTeam * > %p -> %p\n", q, p));
	*(std::vector<Plasma__BotTeam * >*)p = *(std::vector<Plasma__BotTeam * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, std::vector<Plasma__AccountTeam * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, const std::vector<Plasma__AccountTeam * >*a)
{
	for (std::vector<Plasma__AccountTeam * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToPlasma__AccountTeam(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, const char *tag, int id, const std::vector<Plasma__AccountTeam * >*a, const char *type)
{
	for (std::vector<Plasma__AccountTeam * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToPlasma__AccountTeam(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<Plasma__AccountTeam * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, const char *tag, std::vector<Plasma__AccountTeam * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, -1)))
		return NULL;
	Plasma__AccountTeam *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Plasma__AccountTeam, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__AccountTeam, sizeof(Plasma__AccountTeam), 1))
				break;
			if (!soap_in_PointerToPlasma__AccountTeam(soap, tag, NULL, "Plasma:AccountTeam"))
				break;
		}
		else
		{
			if (!soap_in_PointerToPlasma__AccountTeam(soap, tag, &n, "Plasma:AccountTeam"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<Plasma__AccountTeam * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToPlasma__AccountTeam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, std::vector<Plasma__AccountTeam * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<Plasma__AccountTeam * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToPlasma__AccountTeam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToPlasma__AccountTeam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<Plasma__AccountTeam * >;
		if (size)
			*size = sizeof(std::vector<Plasma__AccountTeam * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<Plasma__AccountTeam * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<Plasma__AccountTeam * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<Plasma__AccountTeam * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToPlasma__AccountTeam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<Plasma__AccountTeam * > %p -> %p\n", q, p));
	*(std::vector<Plasma__AccountTeam * >*)p = *(std::vector<Plasma__AccountTeam * >*)q;
}

/* End of soapC.cpp */
